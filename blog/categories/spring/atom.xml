<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Spring | TOO MUCH CODING]]></title>
  <link href="http://toomuchcoding.com/blog/categories/spring/atom.xml" rel="self"/>
  <link href="http://toomuchcoding.com/"/>
  <updated>2018-05-18T11:09:36+02:00</updated>
  <id>http://toomuchcoding.com/</id>
  <author>
    <name><![CDATA[Marcin Grzejszczak]]></name>
    <email><![CDATA[blog@toomuchcoding.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Post on Spring Blog]]></title>
    <link href="http://toomuchcoding.com/blog/2016/01/04/post-on-spring-blog/"/>
    <updated>2016-01-04T09:28:00-08:00</updated>
    <id>http://toomuchcoding.com/blog/2016/01/04/post-on-spring-blog</id>
    <content type="html"><![CDATA[<div class='post'>
Hi!<br /><br />Since December I'm working for Pivotal and the Spring Cloud team. I've just posted my first blog post on the Spring blog. Check it out!<br /><br /><a href="https://spring.io/blog/2016/01/04/testing-spring-cloud-projects">Testing Spring Cloud Projects</a></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring's @Primary Annotation in Action]]></title>
    <link href="http://toomuchcoding.com/blog/2013/12/12/springs-primary-annotation-in-action/"/>
    <updated>2013-12-12T00:00:00-08:00</updated>
    <id>http://toomuchcoding.com/blog/2013/12/12/springs-primary-annotation-in-action</id>
    <content type="html"><![CDATA[<div class='post'>
<br />Spring is a framework that never stops to amaze me. It's because of the fact that it offers plenty of different solutions that allow us, developers, to complete our tasks without writing millions of lines of code. Instead we are able to do the same in a much more readable, standardized manner. In this post I will try to describe one of its features that most likely is well known to all of you but in my opinion its importance is undervalued. The feature that I'll be talking about is the <span style="font-family: Courier New, Courier, monospace;"><a href="http://docs.spring.io/spring/docs/3.2.5.RELEASE/javadoc-api/org/springframework/context/annotation/Primary.html">@Primary</a></span> annotation.<br />
<!--more-->
<br /><a name='more'></a><br /><br /><h2>The problem</h2>On a couple of projects that I was working on we have come accross a common business problem - we had a point of entry to a more complex logic - some container, that would gather the results of several other processors into a single output (something like map-filter-reduce functions from the functional programming). To some extent it resembled the <a href="http://en.wikipedia.org/wiki/Composite_pattern">Composite</a> pattern. Putting it all together our approach was as follows:<br /><ol><li>We had a container that had an autowired list of processors implementing a common interface</li><li>Our container implemented the same interface as the elements of the autowired list</li><li>We wanted the client class that would use the container to have this whole processing work transparent - he is interesed only in the result</li><li>The processors have some logic (predicate) basing on which a processor is applicable to the current set of input data</li><li>The results of the processing were then combined into a list and then reduced to a single output</li></ol><div>There are numerous ways of dealing with this issue - I'll present one that uses Spring with the <span style="font-family: Courier New, Courier, monospace;">@Primary</span> annotation.</div><h2>The solution</h2>Let's start with defining how our use case will fit to the aforementioned preconditions. Our set of data is a Person class that looks as follows:<br /><br /><b>Person.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.person.domain;<br /><br />public final class Person {<br /> private final String name;<br /> private final int age;<br /> private final boolean stupid;<br /><br /> public Person(String name, int age, boolean stupid) {<br />  this.name = name;<br />  this.age = age;<br />  this.stupid = stupid;<br /> }<br /><br /> public String getName() {<br />  return name;<br /> }<br /><br /> public int getAge() {<br />  return age;<br /> }<br /><br /> public boolean isStupid() {<br />  return stupid;<br /> }<br />}<br /><br /></pre>Nothing out of the ordinary. Now let us define the contract:<br /><br /><b>PersonProcessingService.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.person.service;<br /><br />import com.blogspot.toomuchcoding.person.domain.Person;<br /><br />public interface PersonProcessingService {<br /> boolean isApplicableFor(Person person);<br /> String process(Person person);<br />}<br /></pre><br />As stated in the preconditions each implementaiton of the PersonProcessingService has to define two points of the contract :<br /><br /><ol><li>whether it is applicable for the current Person&nbsp;</li><li>how it processess a Person.</li></ol><br />Now let's take a look at some of the Processors that we have - I'll not post the code here cause it's pointless - you can check out the code later on <a href="https://github.com/marcingrzejszczak/too-much-coding/tree/master/Spring/Primary">Github</a> or on <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/6c9b91a33f7d40032ff7c650d17bf60bd8c34625/Spring/Primary/?at=default">Bitbucket</a>. We have the following @Component annotated implementations of PersonProcessingService:<br /><ul><li>AgePersonProcessingService</li><ul><li>is applicable if Person's age is greater or equal 18</li><li>returns a String containing "AGE" as processing takes place - that's kind of silly but it's just a demo right? :)</li></ul><li>IntelligencePersonProcessingService</li><ul><li>is applicable if a Person is stupid</li><li>returns a String containing "STUPID" as processing takes place</li></ul><li>NamePersonProcessingService</li><ul><li>is applicable if a Person has a name</li><li>returns a String containing "NAME" as processing takes place</li></ul></ul><div>The logic is fairly simple. Now our container of PersonProcessingServices would want to iterate for a given Person over the processors, check if the current processor is applicable (filter) and if that is the case add the String that is a result of processing of a Person to the list of responses (map - a function converting a Person to a String) and finaly join those responses by a comma (reduce). Let's check it out how it's done:<br /><br /><b>PersonProcessingServiceContainer.java</b></div><div><br /><pre class="brush:java">package com.blogspot.toomuchcoding.person.service;<br /><br />import java.util.ArrayList;<br />import java.util.List;<br /><br />import org.apache.commons.lang.StringUtils;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.context.annotation.Primary;<br />import org.springframework.stereotype.Component;<br /><br />import com.blogspot.toomuchcoding.person.domain.Person;<br /><br />@Component<br />@Primary<br />class PersonProcessingServiceContainer implements PersonProcessingService {<br /><br /> private static final Logger LOGGER = LoggerFactory.getLogger(PersonProcessingServiceContainer.class);<br /> <br /> @Autowired<br /> private List&lt;PersonProcessingService&gt; personProcessingServices = new ArrayList&lt;PersonProcessingService&gt;();<br /> <br /> @Override<br /> public boolean isApplicableFor(Person person) {<br />  return person != null;<br /> }<br /><br /> @Override<br /> public String process(Person person) {<br />  List&lt;String&gt; output = new ArrayList&lt;String&gt;();<br />  for(PersonProcessingService personProcessingService : personProcessingServices){<br />   if(personProcessingService.isApplicableFor(person)){<br />    output.add(personProcessingService.process(person));<br />   }<br />  }<br />  String result = StringUtils.join(output, ",");<br />  LOGGER.info(result);<br />  return result;<br /> }<br /><br /> public List&lt;PersonProcessingService&gt; getPersonProcessingServices() {<br />  return personProcessingServices;<br /> }<br />}<br /><br /><br /></pre>As you can see we have a container that is annotated with @Primary which means that if an implementation of the PersonProcessingService will have to be injected then Spring will pick the PersonProcessingServiceContainer to be injected. The cool thing is that we have an autowired list of PersonProcessingServices which means that all other implementations of that interface will get autowired there (the container will not autowire itself to the list!).<br /><br />Now let's check out the <a href="https://code.google.com/p/spock/">Spock tests</a> that prove that I'm not telling any lies. If you aren't using Spock already in your project then you should move it straight away :)<br /><br /><b>PersonProcessingServiceContainerIntegrationSpec.groovy</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.person.service<br />import com.blogspot.toomuchcoding.configuration.SpringConfiguration<br />import com.blogspot.toomuchcoding.person.domain.Person<br />import org.springframework.beans.factory.annotation.Autowired<br />import org.springframework.test.context.ContextConfiguration<br />import spock.lang.Specification<br />import spock.lang.Unroll<br /><br />import static org.hamcrest.CoreMatchers.notNullValue<br /><br />@ContextConfiguration(classes = [SpringConfiguration])<br />class PersonProcessingServiceContainerIntegrationSpec extends Specification {<br /><br />    @Autowired<br />    PersonProcessingService personProcessingService<br />    <br />    def "should autowire container even though there are many implementations of service"(){       <br />        expect: <br />            personProcessingService instanceof PersonProcessingServiceContainer<br />    }<br />    <br />    def "the autowired container should not have itself in the list of autowired services"(){       <br />        expect: <br />            personProcessingService instanceof PersonProcessingServiceContainer<br />        and:<br />            !(personProcessingService as PersonProcessingServiceContainer).personProcessingServices.findResult {<br />                it instanceof PersonProcessingServiceContainer<br />            }<br />    }<br />    <br />    def "should not be applicable for processing if a person doesn't exist"(){<br />        given:<br />            Person person = null<br />        expect:<br />            !personProcessingService.isApplicableFor(person)<br />    }<br />    <br />    def "should return an empty result for a person not applicable for anything"(){<br />        given:<br />            Person person = new Person("", 17, false)<br />        when:<br />            def result = personProcessingService.process(person)<br />        then:<br />            result notNullValue()<br />            result.isEmpty()<br />    }<br /><br />    @Unroll("For name [#name], age [#age] and being stupid [#stupid] the result should contain keywords #keywords")<br />    def "should perform different processing depending on input"(){<br />        given:<br />            Person person = new Person(name, age, stupid)<br />        when:<br />            def result = personProcessingService.process(person)        <br />        then:<br />            keywords.every {<br />                result.contains(it)    <br />            }<br />        where:<br />            name  | age | stupid || keywords<br />            "jan" | 20  | true   || ['NAME', 'AGE', 'STUPID']<br />            ""    | 20  | true   || ['AGE', 'STUPID']<br />            ""    | 20  | false  || ['AGE']<br />            null  | 17  | true   || ['STUPID']<br />            "jan" | 17  | true   || ['NAME']<br />    }<br />}<br /><br /></pre></div><div>The tests are pretty straight forward:<br /><ol><li>We prove that the autowired field is in fact our container - the PersonProcessingServiceContainer.</li><li>Then we show that we can't find an object in the collection of autowired implementations of the PersonProcessingService, that is of PersonProcessingServiceContainer type</li><li>In the next two tests we prove that the logic behind our processors is working</li><li>Last but not least is the Spock's finest - the where clause that allows us create beautiful paramterized tests.</li></ol><h2>Per module feature</h2><div>Imagine the situation in which you have an implementation of the interface that is defined in your core module.</div><div><br /><pre class="brush:java">@Component<br />class CoreModuleClass implements SomeInterface {<br />...<br />}<br /><br /></pre></div><div>What if you decide in your other module that has the dependence to the core module that you don't want to use this CoreModuleClass and want to have some custom logic wherever the SomeInterface is autowired? Well - use @Primary!<br /><pre class="brush:java">@Component<br />@Primary<br />class CountryModuleClass implements SomeInterface {<br />...<br />}<br /></pre><br />In that way you are sure that wherever the SomeInterface has to be autowired it will be your CountryModuleClass that will be injected in the field.<br /><h2>Conclusion</h2></div></div>In this post you could see how to<br /><br /><ul><li>use the @Primary annotation to create a composite like container of interface implementations</li><li>use the @Primary annotation to provide a per module implementation of the interface that will take precedence over other @Components in terms of autowiring</li><li>write cool Spock tests :)</li></ul><h2>The code</h2>You can find the code presented here on&nbsp;<a href="https://github.com/marcingrzejszczak/too-much-coding/tree/master/Spring/Primary">Too Much Coding's Github repository</a>&nbsp;or on&nbsp;<a href="https://bitbucket.org/gregorin1987/too-much-coding/src/6c9b91a33f7d40032ff7c650d17bf60bd8c34625/Spring/Primary/?at=default">Too Much Coding's Bitbucket repository</a>.</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Injecting Test Doubles in Spring Using Mockito and BeanPostProcessors]]></title>
    <link href="http://toomuchcoding.com/blog/2013/08/09/injecting-test-doubles-in-spring-using/"/>
    <updated>2013-08-09T05:39:00-07:00</updated>
    <id>http://toomuchcoding.com/blog/2013/08/09/injecting-test-doubles-in-spring-using</id>
    <content type="html"><![CDATA[<div class='post'>
<br />I'm pretty sure that if you have ever used Spring and are familliar with unit testing, you have encountered a problem related to injecting mocks / spies (Test Doubles) in the Spring's application context which you wouldn't want to modify. This article presents an approach how to solve this issue using Spring's components.<br />
<!--more-->
<br /><a name='more'></a><h2>Project structure</h2>Let's start with the project structure:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-24owAXPWDec/UgS1olJ038I/AAAAAAAABlA/O90115z1yIk/s1600/Project+structure.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://1.bp.blogspot.com/-24owAXPWDec/UgS1olJ038I/AAAAAAAABlA/O90115z1yIk/s320/Project+structure.jpg" width="207" /></a></div><br />As usual to present a problem I'm trying to show a very simple project structure. The approach that I'm about to show could show more benefits if I made the problem more extensive as we had in our project:<br /><br /><ul><li>we had dozens of interfaces and implementations autowired to lists</li><li>we wanted to perform some functional tests basing on the existing Spring application context&nbsp;</li><li>we wanted to verify that for certain input conditions some specific implementation would have their methods executed&nbsp;</li><li>we wanted to stub database access.</li></ul><br />In this example we have a <span style="font-family: Courier New, Courier, monospace;">PlayerService</span> that gets a <span style="font-family: Courier New, Courier, monospace;">Player </span>using a <span style="font-family: Courier New, Courier, monospace;">PlayerWebService</span>. We have an applicationContext that simply defines packages for autowiring:<br /><br /><b>applicationContext.xml</b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;<br /><br />    &lt;context:component-scan base-package="com.blogspot.toomuchcoding"/&gt;<br /><br />&lt;/beans&gt;<br /><br /></pre>Then we have our very simple model:<br /><br /><b>Player.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.model;<br /><br />import java.math.BigDecimal;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 08.08.13<br /> * Time: 14:38<br /> */<br />public final class Player {<br />    private final String playerName;<br />    private final BigDecimal playerValue;<br /><br />    public Player(final String playerName, final BigDecimal playerValue) {<br />        this.playerName = playerName;<br />        this.playerValue = playerValue;<br />    }<br /><br />    public String getPlayerName() {<br />        return playerName;<br />    }<br /><br />    public BigDecimal getPlayerValue() {<br />        return playerValue;<br />    }<br />}<br /><br /></pre><br />the implementation of the <span style="font-family: Courier New, Courier, monospace;">PlayerService </span>that uses <span style="font-family: Courier New, Courier, monospace;">PlayerWebService </span>to retrieve data regarding the <span style="font-family: Courier New, Courier, monospace;">Player</span>:<br /><br /><b>PlayerServiceImpl.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.service;<br /><br />import com.blogspot.toomuchcoding.model.Player;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.stereotype.Service;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 08.06.13<br /> * Time: 19:02<br /> */<br />@Service<br />public class PlayerServiceImpl implements PlayerService {<br />    private static final Logger LOGGER = LoggerFactory.getLogger(PlayerServiceImpl.class);<br /><br />    @Autowired<br />    private PlayerWebService playerWebService;<br /><br />    @Override<br />    public Player getPlayerByName(String playerName) {<br />        LOGGER.debug(String.format("Logging the player web service name [%s]", playerWebService.getWebServiceName()));<br />        return playerWebService.getPlayerByName(playerName);<br />    }<br /><br />    public PlayerWebService getPlayerWebService() {<br />        return playerWebService;<br />    }<br /><br />    public void setPlayerWebService(PlayerWebService playerWebService) {<br />        this.playerWebService = playerWebService;<br />    }<br />}<br /><br /></pre><br />the implementation of the PlayerWebService that is a provider of data (in this scenario we are simulating awaiting for response):<br /><br /><b>PlayerWebServiceImpl.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.service;<br /><br />import com.blogspot.toomuchcoding.model.Player;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.stereotype.Service;<br /><br />import java.math.BigDecimal;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 08.08.13<br /> * Time: 14:48<br /> */<br />@Service<br />public class PlayerWebServiceImpl implements PlayerWebService {<br />    private static final Logger LOGGER = LoggerFactory.getLogger(PlayerWebServiceImpl.class);<br />    public static final String WEB_SERVICE_NAME = "SuperPlayerWebService";<br />    public static final String SAMPLE_PLAYER_VALUE = "1000";<br /><br />    @Override<br />    public String getWebServiceName() {<br />        return WEB_SERVICE_NAME;<br />    }<br /><br />    @Override<br />    public Player getPlayerByName(String name) {<br />        try {<br />            LOGGER.debug("Simulating awaiting time for a response from a web service");<br />            Thread.sleep(5000);<br />        } catch (InterruptedException e) {<br />            LOGGER.error(String.format("[%s] occurred while trying to make the thread sleep", e));<br />        }<br />        return new Player(name, new BigDecimal(SAMPLE_PLAYER_VALUE));<br />    }<br />}<br /><br /></pre>Perhaps the project structure and the methods are not one of the most brilliant you have ever seen but I wanted to keep it simple to present the problem ;)<br /><br /><h2>The problem</h2>So what actually is the problem? Let us assume that we want our autowired <span style="font-family: Courier New, Courier, monospace;">PlayerWebServiceImpl</span> to be a Spy that we can verify. What is more you don't want to actually change anything in the <span style="font-family: Courier New, Courier, monospace;">applicationContext.xml</span> - you want to use the current version of the Spring context.<br /><br />With mocks it's easier since you can define in your XML file (using Mockito factory method) your bean as a mock to override the original implementation just like this:<br /><br /><pre class="brush:xml">    &lt;bean id="playerWebServiceImpl" class="org.mockito.Mockito" factory-method="mock"&gt;<br />        &lt;constructor-arg value="com.blogspot.toomuchcoding.service.PlayerWebServiceImpl"/&gt;<br />    &lt;/bean&gt;<br /></pre><br />What about the Spy? It's more problematic since in order to create a Spy you need an already existing object of the given type. In our example we have some autowiring going on so we would have to first create a spring bean of the <span style="font-family: Courier New, Courier, monospace;">PlayerWebService </span>type (Spring would have to wire all its dependencies) and then wrap it around with<span style="font-family: Courier New, Courier, monospace;"> Mockito.spy(...)</span> and only then would it have to be wired somewhere else... It's getting very complicatied doesn't it?<br /><h2>The solution</h2>You can see that the problem is not that trivial to be solved. An easy way to fix it however is to use native Spring mechanisms - BeanPostProcessors. You can check my article about how to create a <a href="http://toomuchcoding.blogspot.com/2012/10/spring-beanpostprocessor-for-specified.html">Spring BeanPostProcessor for a specified type</a>&nbsp;- we'll be using it in this example.<br /><br />Let's start with checking the test class:<br /><br /><b>PlayerServiceImplTest.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.service;<br /><br />import com.blogspot.toomuchcoding.model.Player;<br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br /><br />import java.math.BigDecimal;<br /><br />import static org.hamcrest.CoreMatchers.is;<br />import static org.junit.Assert.assertThat;<br />import static org.mockito.BDDMockito.doReturn;<br />import static org.mockito.Mockito.verify;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 08.06.13<br /> * Time: 19:26<br /> */<br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration("classpath:testApplicationContext.xml")<br />public class PlayerServiceImplTest {<br /><br />    public static final String PLAYER_NAME = "Lewandowski";<br />    public static final BigDecimal PLAYER_VALUE = new BigDecimal("35000000");<br /><br />    @Autowired<br />    PlayerWebService playerWebServiceSpy;<br /><br />    @Autowired<br />    PlayerService objectUnderTest;<br /><br />    @Test<br />    public void shouldReturnAPlayerFromPlayerWebService(){<br />        //given<br />        Player referencePlayer = new Player(PLAYER_NAME, PLAYER_VALUE);<br />        doReturn(referencePlayer).when(playerWebServiceSpy).getPlayerByName(PLAYER_NAME);<br /><br />        //when<br />        Player player = objectUnderTest.getPlayerByName(PLAYER_NAME);<br /><br />        //then<br />        assertThat(player, is(referencePlayer));<br />        verify(playerWebServiceSpy).getWebServiceName();<br />        assertThat(playerWebServiceSpy.getWebServiceName(), is(PlayerWebServiceImpl.WEB_SERVICE_NAME));<br />    }<br /><br /><br />}<br /><br /></pre>In this test we want to mock retrieval of <span style="font-family: Courier New, Courier, monospace;">Player </span>from the <span style="font-family: Courier New, Courier, monospace;">PlayerWebService </span>(let's assume that normally it would try to send a request to the outside world - and we wouldn't want that to happen in our scenario) and test that our <span style="font-family: Courier New, Courier, monospace;">PlayerService </span>returns the <span style="font-family: Courier New, Courier, monospace;">Player </span>that we provided in the method stub and what is more we want to perform verification on the Spy that the method <span style="font-family: Courier New, Courier, monospace;">getWebServiceName()</span> has been executed and that it has a very precisely defined return value. In other words we wanted to stub the method <span style="font-family: Courier New, Courier, monospace;">getPlayerByName(...)</span> and wanted to perform verification of the spy by checking the&nbsp;<span style="font-family: Courier New, Courier, monospace;">getWebServiceName()</span><span style="font-family: inherit;">method.</span><br /><br />Let's check the test context:<br /><br /><b>testApplicationContext.xml</b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;<br /><br />    &lt;import resource="applicationContext.xml"/&gt;<br />    &lt;bean class="com.blogspot.postprocessor.PlayerWebServicePostProcessor" /&gt;<br />&lt;/beans&gt;<br /></pre><br />The test context is very small since it's importing the current <span style="font-family: Courier New, Courier, monospace;">applicationContext.xml</span> and creating a Bean that is the key feature in this example - the <span style="font-family: Courier New, Courier, monospace;">BeanPostProcessor</span>:<br /><br /><b>PlayerWebServicePostProcessor.java</b><br /><br /><pre class="brush:java">package com.blogspot.postprocessor;<br /><br /><br />import com.blogspot.toomuchcoding.processor.AbstractBeanPostProcessor;<br />import com.blogspot.toomuchcoding.service.PlayerWebService;<br /><br />import static org.mockito.Mockito.spy;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 07.05.13<br /> * Time: 11:30<br /> */<br />public class PlayerWebServicePostProcessor extends AbstractBeanPostProcessor&lt;PlayerWebService&gt; {<br />    public PlayerWebServicePostProcessor() {<br />        super(PlayerWebService.class);<br />    }<br /><br />    @Override<br />    public PlayerWebService doBefore(PlayerWebService bean) {<br />        return spy(bean);<br />    }<br /><br />    @Override<br />    public PlayerWebService doAfter(PlayerWebService bean) {<br />        return bean;<br />    }<br />}<br /><br /></pre>The class is extending the <span style="font-family: Courier New, Courier, monospace;">AbstractBeanPostProcessor </span>that implements the <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html">BeanPostProcessor </a>interface. The logic behind this class is to register the Class for which one wants to perform some actions either before initialization (<a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html#postProcessBeforeInitialization(java.lang.Object, java.lang.String)">postProcessBeforeInitialization</a>) or after initialization of the bean (<a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html#postProcessAfterInitialization(java.lang.Object, java.lang.String)">postProcessAfterInitialization</a>). The AbstractBeanPostProcessor is well explained in my post&nbsp;<a href="http://toomuchcoding.blogspot.com/2012/10/spring-beanpostprocessor-for-specified.html">Spring BeanPostProcessor for a specified type</a>&nbsp;but there is one slight change - in my old post we were allowed by the abstraction to perform some actions on the bean without the possibility of returning a wrapper or a proxy on the bean.<br /><br />As you can see in the case of <span style="font-family: Courier New, Courier, monospace;">PlayerWebServicePostProcessor</span>&nbsp;before initialization we are creating a Spy using <span style="font-family: Courier New, Courier, monospace;">Mockito.spy(...)</span> method. In this way we create a factory hook on the intialization of beans of given type - it's as simple as that. This method will be executed for all the classes that implement the <span style="font-family: Courier New, Courier, monospace;">PlayerWebService&nbsp;</span>interface.<br /><h2>Other possibilities</h2><div>While checking out current solutions to this problem I have encountered the <a href="https://bitbucket.org/kubek2k/springockito/wiki/Home">Springockito library</a>&nbsp;by Jakub Janczak.</div><div><br /></div><div>I haven't been using this so I don't know what are (if there are any ;) ) production issues related to this library but it seems really nice and intuitive - great job Jakub! Still, you become dependent on the external library whereas in this example I've shown how to deal with the issue using Spring.</div><h2>Summary</h2><div>In this post I've shown how to</div><div><ul><li>create mocks for existing beans using XML Spring configuration</li><li>create a BeanPostProcessor implementation that performs logic for a given class of beans</li><li>return Spy (you could also return a Mock) for the given class of bean</li></ul></div><div>Now let's move through the Prons and Cons of my approach:</div><div><b><br /></b></div><div><b>Advantages</b></div><div><ul><li>you use Spring native mechanism to create Test Doubles for your beans</li><li>you are not required to add any additional external dependencies</li><li>if you use the <span style="font-family: Courier New, Courier, monospace;">AbstractBeanPostProcessor</span> you have very little changes to implement</li></ul></div><div><b>Disadvantages</b></div><div><ul><li>you have to be familliar with internal Spring architecture (that it uses BeanPostProcessors) - but is it a disadvantage? ;) - in fact if you use the&nbsp;<span style="font-family: Courier New, Courier, monospace;">AbstractBeanPostProcessor</span>&nbsp;&nbsp;you don't have to be familliar with it - you just have to provide the class type and actions to happen before and after initialization.</li><li>it's less intuitive than annotations like in&nbsp;the&nbsp;<a href="https://bitbucket.org/kubek2k/springockito/wiki/Home">Springockito library</a></li></ul></div><h2>Sources</h2>The sources are available at <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/0e7f9ad4eb4c1d2500562c3634253e26fc1e3a0e/Unit%20Testing/Mockito%20-%20Injecting%20Test%20Doubles%20in%20Spring?at=default">TooMuchCoding BitBucket repository</a> and <a href="https://github.com/marcingrzejszczak/too-much-coding/tree/master/Unit%20Testing/Mockito%20-%20Injecting%20Test%20Doubles%20in%20Spring">TooMuchCoding Github repository</a>.<br /><br /></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Drools Decision Tables With Camel and Spring]]></title>
    <link href="http://toomuchcoding.com/blog/2013/02/03/drools-decision-tables-with-camel-and/"/>
    <updated>2013-02-03T13:28:00-08:00</updated>
    <id>http://toomuchcoding.com/blog/2013/02/03/drools-decision-tables-with-camel-and</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />Hi!<br /><br /><div style="text-align: justify;">As I've shown it in my previous post <a href="http://toomuchcoding.blogspot.com/2013/01/drools-integration-with-spring-vs.html">JBoss Drools are a very useful rules engine</a>. The only problem is that creating the rules in the Rule language might be pretty complicated for a non-technical person. That's why one can provide an easy way for creating business rules - decision tables created in a spreadsheet!</div><div style="text-align: justify;"><br />
<!--more-->
</div><div style="text-align: justify;">In the following example I will show you a really complicated business rule example converted to a decision table in a spreadsheet. As a backend we will have Drools, Camel and Spring.</div><br /><br /><a name='more'></a><br /><br /><div style="text-align: justify;">To begin with let us take a look at our imaginary business problem. Let us assume that we are running a business that focuses on selling products (either Medical or Electronic). We are shipping our products to several countries (PL, USA, GER, SWE, UK, ESP) and depending on the country there are different law regulations concerning the buyer's age. In some countries you can buy products when you are younger than in others. What is more depending on the country from which the buyer and the product comes from and on the quantity of products, the buyer might get a discount. As you can see there is a substantial number of conditions needed to be fullfield in this scenario (imagine the number of ifs needed to program this :P ).</div><br /><div style="text-align: justify;">Another problem would be the business side (as usual). Anybody who has been working on a project knows how fast the requirements are changing. If one entered all the rules in the code he would have to redeploy the software each time the requirements changed. That's why it is a good practice to divide the business logic from the code itself. Anyway, let's go back to our example.</div><br />To begin with let us take a look at the spreadsheets (before that it is worth taking a look at the <a href="http://docs.jboss.org/drools/release/5.2.0.Final/drools-expert-docs/html/ch06.html">JBoss website with precise description of how the decision table should look like</a>):<br /><br /><br /><div style="text-align: justify;">The point of entry of our program is the first spreadsheet that checks if the given user should be granted with the possibility of buying a product (it will be better if you download the spreadsheets and play with them from Too Much Coding's repository at Bitbucket: <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/eeda79f74a4af30091490ab3507879254540e118/Drools/Decision%20table/src/main/resources/rules/user_table.xls?at=default">user_table.xls</a> and <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/eeda79f74a4af30091490ab3507879254540e118/Drools/Decision%20table/src/main/resources/rules/product_table.xls?at=default">product_table.xls</a>, or Github<a href="https://github.com/marcingrzejszczak/too-much-coding/blob/master/Drools/Decision%20table/src/main/resources/rules/user_table.xls?raw=true"> user_table.xls </a>and <a href="https://github.com/marcingrzejszczak/too-much-coding/blob/master/Drools/Decision%20table/src/main/resources/rules/product_table.xls?raw=true">product_table.xls</a>):</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><b>user_table.xls (tables worksheet)</b></div><div style="text-align: justify;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-J5-tXPECwJI/UQ7TmutXq5I/AAAAAAAAAzU/3c9KrRFaZ5w/s1600/user_table.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="120" src="http://1.bp.blogspot.com/-J5-tXPECwJI/UQ7TmutXq5I/AAAAAAAAAzU/3c9KrRFaZ5w/s320/user_table.png" width="320" /></a></div><div><br /></div><div>Once the user has been approved he might get a discount:</div><br /><br /><b>product_table.xls (tables worksheet)</b><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-v-fAUhcn4HI/UQ69XrrT06I/AAAAAAAAAy0/8fU1nropIhU/s1600/product_table.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="129" src="http://2.bp.blogspot.com/-v-fAUhcn4HI/UQ69XrrT06I/AAAAAAAAAy0/8fU1nropIhU/s320/product_table.png" width="320" /></a></div><br /><b>product_table.xls (lists worksheet)</b><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-_MkDqjqjuDU/UQ69mEuCy5I/AAAAAAAAAy8/u09czbpift0/s1600/user_table_lists.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="81" src="http://4.bp.blogspot.com/-_MkDqjqjuDU/UQ69mEuCy5I/AAAAAAAAAy8/u09czbpift0/s320/user_table_lists.png" width="320" /></a></div><br /><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: justify;">As you can see in the images the business problem is quite complex. Each row represents a rule, and each column represents a condition. <a href="http://toomuchcoding.blogspot.com/2013/01/drools-integration-with-spring-vs.html">Do you remember the rules syntax from my recent post?</a> So you would understand the hidden part of the spreadsheet that is right above the first visible row:</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/--f9FvvQaAhM/UQ6-gcczcQI/AAAAAAAAAzM/GxGmoV6s3OE/s1600/product_table_header.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="71" src="http://2.bp.blogspot.com/--f9FvvQaAhM/UQ6-gcczcQI/AAAAAAAAAzM/GxGmoV6s3OE/s320/product_table_header.png" width="320" /></a></div><div class="separator" style="clear: both; text-align: left;"><br /></div><br /><div style="text-align: justify;">The rows from 2 to 6 represent some fixed configuration values such as rule set, imports (<a href="http://toomuchcoding.blogspot.com/2013/01/drools-integration-with-spring-vs.html"> you've already seen that in my recent post</a>) and functions. Next in row number 7 you can find the name of the RuleTable. Then in row number 8 you have in our scenario either a CONDITION or an ACTION - so in other words either the LHS or rhe RHS respectively. Row number 9 is both representation of types presented in the condition and the binding to a variable. In row number 10 we have the exact LHS condition. Row number 11 shows the label of columns. From row number 12 we have the rules one by one. You can find the spreadsheets in the sources.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Now let's take a look at the code. Let's start with taking a look at the schemas defining the Product and the User.<br /><br /></div><div style="text-align: justify;"><b>Person.xsd</b><br /><br /></div><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;<br />    &lt;xsd:include schemaLocation="user.xsd"/&gt;<br /><br />    &lt;xsd:element name="Product"&gt;<br />        &lt;xsd:complexType&gt;<br />            &lt;xsd:sequence&gt;<br />                &lt;xsd:element name="Name" type="xsd:string"/&gt;<br />                &lt;xsd:element name="Type" type="ProductType"/&gt;<br />                &lt;xsd:element name="Price" type="xsd:double"/&gt;<br />                &lt;xsd:element name="CountryOfOrigin" type="CountryType"/&gt;<br />                &lt;xsd:element name="AdditionalInfo" type="xsd:string"/&gt;<br />                &lt;xsd:element name="Quantity" type="xsd:int"/&gt;<br />            &lt;/xsd:sequence&gt;<br />        &lt;/xsd:complexType&gt;<br />    &lt;/xsd:element&gt;<br /><br />    &lt;xsd:simpleType name="ProductType"&gt;<br />        &lt;xsd:restriction base="xsd:string"&gt;<br />            &lt;xsd:enumeration value="MEDICAL"/&gt;<br />            &lt;xsd:enumeration value="ELECTRONIC"/&gt;<br />        &lt;/xsd:restriction&gt;<br />    &lt;/xsd:simpleType&gt;<br /><br />&lt;/xsd:schema&gt;<br /></pre><br /><div style="text-align: justify;"><b>User.xsd</b><br /><br /></div><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;<br />    &lt;xsd:include schemaLocation="product.xsd"/&gt;<br /><br />    &lt;xsd:element name="User"&gt;<br />        &lt;xsd:complexType&gt;<br />            &lt;xsd:sequence&gt;<br />                &lt;xsd:element name="UserName" type="xsd:string"/&gt;<br />                &lt;xsd:element name="UserAge" type="xsd:int"/&gt;<br />                &lt;xsd:element name="UserCountry" type="CountryType"/&gt;<br />                &lt;xsd:element name="Decision" type="DecisionType"/&gt;<br />                &lt;xsd:element name="DecisionDescription" type="xsd:string"/&gt;<br />            &lt;/xsd:sequence&gt;<br />        &lt;/xsd:complexType&gt;<br />    &lt;/xsd:element&gt;<br /><br />    &lt;xsd:simpleType name="CountryType"&gt;<br />        &lt;xsd:restriction base="xsd:string"&gt;<br />            &lt;xsd:enumeration value="PL"/&gt;<br />            &lt;xsd:enumeration value="USA"/&gt;<br />            &lt;xsd:enumeration value="GER"/&gt;<br />            &lt;xsd:enumeration value="SWE"/&gt;<br />            &lt;xsd:enumeration value="UK"/&gt;<br />            &lt;xsd:enumeration value="ESP"/&gt;<br />        &lt;/xsd:restriction&gt;<br />    &lt;/xsd:simpleType&gt;<br /><br />    &lt;xsd:simpleType name="DecisionType"&gt;<br />        &lt;xsd:restriction base="xsd:string"&gt;<br />            &lt;xsd:enumeration value="ACCEPTED"/&gt;<br />            &lt;xsd:enumeration value="REJECTED"/&gt;<br />        &lt;/xsd:restriction&gt;<br />    &lt;/xsd:simpleType&gt;<br /><br />&lt;/xsd:schema&gt;<br /></pre><br />Due to the fact that we are using maven we may use a plugin that will convert the XSD into Java classes.<br /><br />part of the <b>pom.xml  </b><br /><br /><pre class="brush:xml"> &lt;build&gt;<br />        &lt;pluginManagement&gt;<br />            &lt;plugins&gt;<br />                &lt;plugin&gt;<br />                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br />                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br />                    &lt;version&gt;2.5.1&lt;/version&gt;<br />                &lt;/plugin&gt;<br />            &lt;/plugins&gt;<br />        &lt;/pluginManagement&gt;<br />        &lt;plugins&gt;<br />            &lt;plugin&gt;<br />                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br />                &lt;artifactId&gt;jaxb2-maven-plugin&lt;/artifactId&gt;<br />                &lt;version&gt;1.5&lt;/version&gt;<br />                &lt;executions&gt;<br />                    &lt;execution&gt;<br />                        &lt;id&gt;xjc&lt;/id&gt;<br />                        &lt;goals&gt;<br />                            &lt;goal&gt;xjc&lt;/goal&gt;<br />                        &lt;/goals&gt;<br />                    &lt;/execution&gt;<br />                &lt;/executions&gt;<br />                &lt;configuration&gt;<br />                    &lt;packageName&gt;pl.grzejszczak.marcin.drools.decisiontable.model&lt;/packageName&gt;<br />                    &lt;schemaDirectory&gt;${project.basedir}/src/main/resources/xsd&lt;/schemaDirectory&gt;<br />                &lt;/configuration&gt;<br />            &lt;/plugin&gt;<br />        &lt;/plugins&gt;<br />    &lt;/build&gt;<br /></pre><br />Thanks to this plugin we have our generated by JAXB classes in the <b>pl.grzejszczak.marcin.decisiontable.model</b> package.<br /><br />Now off to the drools-context.xml file where we've defined all the necessary beans as far as Drools are concerned:<br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:drools="http://drools.org/schema/drools-spring"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />  http://drools.org/schema/drools-spring http://drools.org/schema/drools-spring.xsd"&gt;<br /><br />    &lt;!-- Grid Node identifier that is registered in the CamelContext --&gt;<br />    &lt;drools:grid-node id="node1"/&gt;<br /><br />    &lt;drools:kbase id="productsKBase" node="node1"&gt;<br />        &lt;drools:resources&gt;<br />            &lt;drools:resource type="DTABLE" source="classpath:rules/product_table.xls"/&gt;<br />        &lt;/drools:resources&gt;<br />    &lt;/drools:kbase&gt;<br /><br />    &lt;drools:ksession id="productsKSession" name="productsKSession" type="stateless" kbase="productsKBase" node="node1"/&gt;<br /><br />    &lt;drools:kbase id="usersKBase" node="node1"&gt;<br />        &lt;drools:resources&gt;<br />            &lt;drools:resource type="DTABLE" source="classpath:rules/user_table.xls"/&gt;<br />        &lt;/drools:resources&gt;<br />    &lt;/drools:kbase&gt;<br /><br />    &lt;drools:ksession id="usersKSession" name="usersKSession" type="stateless" kbase="usersKBase" node="node1"/&gt;<br /><br />&lt;/beans&gt;</pre><br /><div style="text-align: justify;">As you can see in comparison to <a href="http://toomuchcoding.blogspot.com/2013/01/drools-integration-with-spring-vs.html">the application context from the recent post </a>there are some differences. First instead of passing the DRL file as the resource inside the knowledge base we are providing the Decision table (<span style="font-family: Courier New, Courier, monospace;">DTABLE</span>). I've decided to pass in two seperate files but you can provide one file with several worksheets and access those worksheets (through the <span style="font-family: Courier New, Courier, monospace;">decisiontable-conf</span> element). Also there is an additional element called <span style="font-family: Courier New, Courier, monospace;">node</span>. We have to choose an implementation of the Node interface (Execution, Grid...) for the Camel route to work properly as you will see in a couple of seconds in the Spring application context file.&nbsp;</div><br /><b>applicationContext.xml</b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:camel="http://camel.apache.org/schema/spring"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xsi:schemaLocation="http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd<br />                           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />                           http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring-2.8.0.xsd"&gt;<br /><br />    &lt;import resource="classpath:drools-context.xml"/&gt;<br />    &lt;!-- Show Spring where to search for the beans (in which packages) --&gt;<br />    &lt;context:component-scan base-package="pl.grzejszczak.marcin.drools.decisiontable" /&gt;<br /><br />    &lt;camel:camelContext id="camelContext"&gt;<br />        &lt;camel:route id="acceptanceRoute"&gt;<br />            &lt;camel:from uri="direct:acceptanceRoute"/&gt;<br />            &lt;camel:to uri="drools:node1/usersKSession"/&gt;<br />        &lt;/camel:route&gt;<br />        &lt;camel:route id="discountRoute"&gt;<br />            &lt;camel:from uri="direct:discountRoute"/&gt;<br />            &lt;camel:to uri="drools:node1/productsKSession"/&gt;<br />        &lt;/camel:route&gt;<br />    &lt;/camel:camelContext&gt;<br /><br />&lt;/beans&gt;<br /><br /></pre><div style="text-align: justify;">As you can see in order to access the Drools Camel Component we have to provide the <b>node </b>through which we will access the proper<b> knowledge session</b>. We have defined two routes - the first one ends at the Drools component that accesses the users knowledge session and the other the products knowledge session.&nbsp;</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">We have a ProductService interface implementation called ProductServiceImpl that given an input User and Product objects pass them through the Camel's Producer Template to two Camel routes each ending at the Drools components. The concept behind this product service is that we are first processing the User if he can even buy the software and then we are checking what kind of a discount he would receive. From the service's point of view in fact we are just sending the object out and waiting for the response. Finally having reveived the response we are passing the User and the Product to the Financial Service implementation that will bill the user for the products that he has bought or reject his offer if needed.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><b>ProductServiceImpl.java</b></div><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.decisiontable.service;<br /><br />import org.apache.camel.CamelContext;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.decisiontable.model.Product;<br />import pl.grzejszczak.marcin.drools.decisiontable.model.User;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("productServiceImpl")<br />public class ProductServiceImpl implements ProductService {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ProductServiceImpl.class);<br /><br />    @Autowired<br />    CamelContext camelContext;<br /><br />    @Autowired<br />    FinancialService financialService;<br /><br />    @Override<br />    public void runProductLogic(User user, Product product) {<br />        LOGGER.debug("Running product logic - first acceptance Route, then discount Route");<br />        camelContext.createProducerTemplate().sendBody("direct:acceptanceRoute", newArrayList(user, product));<br />        camelContext.createProducerTemplate().sendBody("direct:discountRoute", newArrayList(user, product));<br />        financialService.processOrder(user, product);<br />    }<br /><br />}<br /></pre><pre class="brush:java"></pre><div style="text-align: justify;"><br /></div><span style="text-align: justify;">Another crucial thing to remember about is that the Camel Drools Component requires the Command object as the input. As you can see, in the body we are sending a list of objects (and these are not Command objects). I did it on purpose since in my opinion it is better not to bind our code to a concrete solution. What if we find out that there is a better solution than Drools? Will we change all the code that we have created or just change the Camel route to point at our new solution? That's why Camel has the TypeConverters. We have our own here&nbsp;as well. First of all let's take a look at the implementation.</span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;"><b>ProductTypeConverter.java</b></span><br /><span style="text-align: justify;"><br /></span><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.decisiontable.converter;<br /><br />import org.apache.camel.Converter;<br />import org.drools.command.Command;<br />import org.drools.command.CommandFactory;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import pl.grzejszczak.marcin.drools.decisiontable.model.Product;<br /><br />import java.util.List;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 30.01.13<br /> * Time: 21:42<br /> */<br />@Converter<br />public class ProductTypeConverter {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ProductTypeConverter.class);<br /><br />    @Converter<br />    public static Command toCommandFromList(List inputList) {<br />        LOGGER.debug("Executing ProductTypeConverter's toCommandFromList method");<br />        return CommandFactory.newInsertElements(inputList);<br />    }<br /><br />    @Converter<br />    public static Command toCommand(Product product) {<br />        LOGGER.debug("Executing ProductTypeConverter's toCommand method");<br />        return CommandFactory.newInsert(product);<br />    }<br />}<br /><br /></pre><span style="text-align: justify;">There is a good tutorial on TypeConverters on the <a href="http://camel.apache.org/type-converter.html">Camel website</a> - if you needed some more indepth info about it. Anyway, we are annotating our class and the functions used to convert different types into one another. What is important here is that we are showing Camel how to convert a list and a single product to Commands. Due to type erasure this will work regardless of the provided type that is why even though we are giving a list of Product &nbsp;and User, the toCommandFromList function will get executed.&nbsp;</span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;">In addition to this in order for the type converter to work we have to provide the fully quallified name of our class (FQN) in the&nbsp;<b>/META-INF/services/org/apache/camel/TypeConverter</b> file.</span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;"><b>TypeConverter</b></span><br /><span style="text-align: justify;"><br /></span><br /><pre class="brush:xml">pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter</pre><br /><span style="text-align: justify;">In order to properly test our functionality one should write quite a few tests that would verify the rules. A pretty good way would be to have input files stored in the test resources folders that are passed to the rule engine and then the result would be compared against the verified output (unfortunately it is rather impossible to make the business side develop such a reference set of outputs). Anyway let's take a look at the unit test that verifies only a few of the rules and the logs that are produced from running those rules:</span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;"><b>ProductServiceImplTest.java</b></span><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.decisiontable.service.drools;<br /><br />import org.apache.commons.lang.builder.ReflectionToStringBuilder;<br />import org.apache.commons.lang.builder.ToStringStyle;<br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br />import pl.grzejszczak.marcin.drools.decisiontable.model.*;<br />import pl.grzejszczak.marcin.drools.decisiontable.service.ProductService;<br /><br />import static org.junit.Assert.assertEquals;<br />import static org.junit.Assert.assertTrue;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.02.13<br /> * Time: 16:06<br /> */<br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration("classpath:applicationContext.xml")<br />public class ProductServiceImplTest {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ProductServiceImplTest.class);<br /><br />    @Autowired<br />    ProductService objectUnderTest;<br /><br />    @Test<br />    public void testRunProductLogicUserPlUnderageElectronicCountryPL() throws Exception {<br />        int initialPrice = 1000;<br />        int userAge = 6;<br />        int quantity = 10;<br /><br />        User user = createUser("Smith", CountryType.PL, userAge);<br />        Product product = createProduct("Electronic", initialPrice, CountryType.PL, ProductType.ELECTRONIC, quantity);<br /><br />        printInputs(user, product);<br /><br />        objectUnderTest.runProductLogic(user, product);<br /><br />        printInputs(user, product);<br /><br />        assertTrue(product.getPrice() == initialPrice);<br />        assertEquals(DecisionType.REJECTED, user.getDecision());<br />    }<br /><br />    @Test<br />    public void testRunProductLogicUserPlHighAgeElectronicCountryPLLowQuantity() throws Exception {<br />        int initialPrice = 1000;<br />        int userAge = 19;<br />        int quantity = 1;<br /><br />        User user = createUser("Smith", CountryType.PL, userAge);<br />        Product product = createProduct("Electronic", initialPrice, CountryType.PL, ProductType.ELECTRONIC, quantity);<br /><br />        printInputs(user, product);<br /><br />        objectUnderTest.runProductLogic(user, product);<br /><br />        printInputs(user, product);<br /><br />        assertTrue(product.getPrice() == initialPrice);<br />        assertEquals(DecisionType.ACCEPTED, user.getDecision());<br />    }<br /><br />    @Test<br />    public void testRunProductLogicUserPlHighAgeElectronicCountryPLHighQuantity() throws Exception {<br />        int initialPrice = 1000;<br />        int userAge = 19;<br />        int quantity = 8;<br /><br />        User user = createUser("Smith", CountryType.PL, userAge);<br />        Product product = createProduct("Electronic", initialPrice, CountryType.PL, ProductType.ELECTRONIC, quantity);<br /><br />        printInputs(user, product);<br /><br />        objectUnderTest.runProductLogic(user, product);<br /><br />        printInputs(user, product);<br />        double expectedDiscount = 0.1;<br /><br />        assertTrue(product.getPrice() == initialPrice * (1 - expectedDiscount));<br />        assertEquals(DecisionType.ACCEPTED, user.getDecision());<br />    }<br /><br />    @Test<br />    public void testRunProductLogicUserUsaLowAgeElectronicCountryPLHighQuantity() throws Exception {<br />        int initialPrice = 1000;<br />        int userAge = 19;<br />        int quantity = 8;<br /><br />        User user = createUser("Smith", CountryType.USA, userAge);<br />        Product product = createProduct("Electronic", initialPrice, CountryType.PL, ProductType.ELECTRONIC, quantity);<br /><br />        printInputs(user, product);<br /><br />        objectUnderTest.runProductLogic(user, product);<br /><br />        printInputs(user, product);<br /><br />        assertTrue(product.getPrice() == initialPrice);<br />        assertEquals(DecisionType.REJECTED, user.getDecision());<br />    }<br /><br />    @Test<br />    public void testRunProductLogicUserUsaHighAgeMedicalCountrySWELowQuantity() throws Exception {<br />        int initialPrice = 1000;<br />        int userAge = 22;<br />        int quantity = 4;<br /><br />        User user = createUser("Smith", CountryType.USA, userAge);<br />        Product product = createProduct("Some name", initialPrice, CountryType.SWE, ProductType.MEDICAL, quantity);<br /><br />        printInputs(user, product);<br /><br />        objectUnderTest.runProductLogic(user, product);<br /><br />        printInputs(user, product);<br /><br />        assertTrue(product.getPrice() == initialPrice);<br />        assertEquals(DecisionType.ACCEPTED, user.getDecision());<br />    }<br /><br />    @Test<br />    public void testRunProductLogicUserUsaHighAgeMedicalCountrySWEHighQuantity() throws Exception {<br />        int initialPrice = 1000;<br />        int userAge = 22;<br />        int quantity = 8;<br /><br />        User user = createUser("Smith", CountryType.USA, userAge);<br />        Product product = createProduct("Some name", initialPrice, CountryType.SWE, ProductType.MEDICAL, quantity);<br /><br />        printInputs(user, product);<br /><br />        objectUnderTest.runProductLogic(user, product);<br /><br />        printInputs(user, product);<br />        double expectedDiscount = 0.25;<br /><br />        assertTrue(product.getPrice() == initialPrice * (1 - expectedDiscount));<br />        assertEquals(DecisionType.ACCEPTED, user.getDecision());<br />    }<br /><br />    private void printInputs(User user, Product product) {<br />        LOGGER.debug(ReflectionToStringBuilder.reflectionToString(user, ToStringStyle.MULTI_LINE_STYLE));<br />        LOGGER.debug(ReflectionToStringBuilder.reflectionToString(product, ToStringStyle.MULTI_LINE_STYLE));<br />    }<br /><br />    private User createUser(String name, CountryType countryType, int userAge){<br />        User user = new User();<br />        user.setUserName(name);<br />        user.setUserCountry(countryType);<br />        user.setUserAge(userAge);<br />        return user;<br />    }<br /><br />    private Product createProduct(String name, double price, CountryType countryOfOrigin, ProductType productType, int quantity){<br />        Product product = new Product();<br />        product.setPrice(price);<br />        product.setCountryOfOrigin(countryOfOrigin);<br />        product.setName(name);<br />        product.setType(productType);<br />        product.setQuantity(quantity);<br />        return product;<br />    }<br /><br />}<br /><br /></pre><span style="text-align: justify;">Of course the log.debugs in the tests are totally redundant but I wanted you to quickly see that the rules are operational :) Sorry for the length of the logs but I wrote a few tests to show different combinations of rules (in fact it's better too have too many logs than the other way round :) )</span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;"><br /></span><br /><pre class="brush:xml">pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@1d48043[<br />  userName=Smith<br />  userAge=6<br />  userCountry=PL<br />  decision=&lt;null&gt;<br />  decisionDescription=&lt;null&gt;<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@1e8f2a0[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=1000.0<br />  countryOfOrigin=PL<br />  additionalInfo=&lt;null&gt;<br />  quantity=10<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductServiceImpl:31 Running product logic - first acceptance Route, then discount Route<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Sorry, according to your age (&lt; 18) and country (PL) you can't buy this product<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.FinancialServiceImpl:29 Sorry, user has been rejected...<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@1d48043[<br />  userName=Smith<br />  userAge=6<br />  userCountry=PL<br />  decision=REJECTED<br />  decisionDescription=Sorry, according to your age (&lt; 18) and country (PL) you can't buy this product<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@1e8f2a0[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=1000.0<br />  countryOfOrigin=PL<br />  additionalInfo=&lt;null&gt;<br />  quantity=10<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@b28f30[<br />  userName=Smith<br />  userAge=19<br />  userCountry=PL<br />  decision=&lt;null&gt;<br />  decisionDescription=&lt;null&gt;<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@d6a0e0[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=1000.0<br />  countryOfOrigin=PL<br />  additionalInfo=&lt;null&gt;<br />  quantity=1<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductServiceImpl:31 Running product logic - first acceptance Route, then discount Route<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Congratulations, you have successfully bought the product<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Sorry, no discount will be granted.<br />pl.grzejszczak.marcin.drools.decisiontable.service.FinancialServiceImpl:25 User has been approved - processing the order...<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@b28f30[<br />  userName=Smith<br />  userAge=19<br />  userCountry=PL<br />  decision=ACCEPTED<br />  decisionDescription=Congratulations, you have successfully bought the product<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@d6a0e0[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=1000.0<br />  countryOfOrigin=PL<br />  additionalInfo=Sorry, no discount will be granted.<br />  quantity=1<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@14510ac[<br />  userName=Smith<br />  userAge=19<br />  userCountry=PL<br />  decision=&lt;null&gt;<br />  decisionDescription=&lt;null&gt;<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@1499616[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=1000.0<br />  countryOfOrigin=PL<br />  additionalInfo=&lt;null&gt;<br />  quantity=8<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductServiceImpl:31 Running product logic - first acceptance Route, then discount Route<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Congratulations, you have successfully bought the product<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Congratulations - you've been granted a 10% discount!<br />pl.grzejszczak.marcin.drools.decisiontable.service.FinancialServiceImpl:25 User has been approved - processing the order...<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@14510ac[<br />  userName=Smith<br />  userAge=19<br />  userCountry=PL<br />  decision=ACCEPTED<br />  decisionDescription=Congratulations, you have successfully bought the product<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@1499616[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=900.0<br />  countryOfOrigin=PL<br />  additionalInfo=Congratulations - you've been granted a 10% discount!<br />  quantity=8<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@17667bd[<br />  userName=Smith<br />  userAge=19<br />  userCountry=USA<br />  decision=&lt;null&gt;<br />  decisionDescription=&lt;null&gt;<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@ad9f5d[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=1000.0<br />  countryOfOrigin=PL<br />  additionalInfo=&lt;null&gt;<br />  quantity=8<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductServiceImpl:31 Running product logic - first acceptance Route, then discount Route<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Sorry, according to your age (&lt; 18) and country (USA) you can't buy this product<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.FinancialServiceImpl:29 Sorry, user has been rejected...<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@17667bd[<br />  userName=Smith<br />  userAge=19<br />  userCountry=USA<br />  decision=REJECTED<br />  decisionDescription=Sorry, according to your age (&lt; 18) and country (USA) you can't buy this product<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@ad9f5d[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=1000.0<br />  countryOfOrigin=PL<br />  additionalInfo=&lt;null&gt;<br />  quantity=8<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@9ff588[<br />  userName=Smith<br />  userAge=22<br />  userCountry=USA<br />  decision=&lt;null&gt;<br />  decisionDescription=&lt;null&gt;<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@1b0d2d0[<br />  name=Some name<br />  type=MEDICAL<br />  price=1000.0<br />  countryOfOrigin=SWE<br />  additionalInfo=&lt;null&gt;<br />  quantity=4<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductServiceImpl:31 Running product logic - first acceptance Route, then discount Route<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Congratulations, you have successfully bought the product<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.FinancialServiceImpl:25 User has been approved - processing the order...<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@9ff588[<br />  userName=Smith<br />  userAge=22<br />  userCountry=USA<br />  decision=ACCEPTED<br />  decisionDescription=Congratulations, you have successfully bought the product<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@1b0d2d0[<br />  name=Some name<br />  type=MEDICAL<br />  price=1000.0<br />  countryOfOrigin=SWE<br />  additionalInfo=&lt;null&gt;<br />  quantity=4<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@1b27882[<br />  userName=Smith<br />  userAge=22<br />  userCountry=USA<br />  decision=&lt;null&gt;<br />  decisionDescription=&lt;null&gt;<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@5b84b[<br />  name=Some name<br />  type=MEDICAL<br />  price=1000.0<br />  countryOfOrigin=SWE<br />  additionalInfo=&lt;null&gt;<br />  quantity=8<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductServiceImpl:31 Running product logic - first acceptance Route, then discount Route<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Congratulations, you have successfully bought the product<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Congratulations, you are granted a discount<br />pl.grzejszczak.marcin.drools.decisiontable.service.FinancialServiceImpl:25 User has been approved - processing the order...<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@1b27882[<br />  userName=Smith<br />  userAge=22<br />  userCountry=USA<br />  decision=ACCEPTED<br />  decisionDescription=Congratulations, you have successfully bought the product<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@5b84b[<br />  name=Some name<br />  type=MEDICAL<br />  price=750.0<br />  countryOfOrigin=SWE<br />  additionalInfo=Congratulations, you are granted a discount<br />  quantity=8<br />]<br /><br /></pre><span style="text-align: justify;">In this post I've presented how you can push some of your developing work to your BA by giving him a tool which he can be able to work woth - the Decision Tables in a spreadsheet. What is more now you will now how to integrate Drools with Camel. Hopefully you will see how you can simplify (thus minimize the cost of implementing and supporting) the implementation of business rules bearing in mind how prone to changes they are. I hope that this example will even better illustrate how difficult it would be to implement all the business rules in Java than in the <a href="http://toomuchcoding.blogspot.com/2013/01/drools-integration-with-spring-vs.html">previous post about Drools.</a></span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;">If you have any experience with Drools in terms of decision tables, integration with Spring and Camel please feel free to leave a comment - let's have a discussion on that :)</span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;">All the code is available at Too Much Coding repository at <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/eeda79f74a4af30091490ab3507879254540e118/Drools/Decision%20table?at=default">Bitbucket </a>and <a href="https://github.com/marcingrzejszczak/too-much-coding/tree/master/Drools/Decision%20table">GitHub</a>.</span><span style="text-align: justify;"><br /></span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;">Cheers!</span></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Drools Integration With Spring vs Manual Rules Creation]]></title>
    <link href="http://toomuchcoding.com/blog/2013/01/15/drools-integration-with-spring-vs/"/>
    <updated>2013-01-15T08:04:00-08:00</updated>
    <id>http://toomuchcoding.com/blog/2013/01/15/drools-integration-with-spring-vs</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />Hi!<br /><br />&nbsp;Often in your work you can come across with issues related to business logic. Let us assume that you have dozens of rules (for the time being in our project we have more than 50 and I used to work on a project where we had hundreds of those rules) that you have to implement, divide into some classes, subclasses, abstractions and of course unit test. This can be difficult and timeconsuming to both write and support. There are many ways of dealing with this problem and I will show you one of them - JBoss Drools.<br />
<!--more-->
<br />Drools is a library specifically created for such purposes like implementing rules. As presented in Wikipedia:<br /><blockquote class="tr_bq">"Drools is a rule engine implementaion based on Charles Forgy's Rete Algorithm tailored for the Java language."&nbsp;</blockquote>It contains a rule engine that can process rules wirtten using the Drools language (you can also provide rules in Excel spreadsheets! - perfect for Business side to support and maintain).<br /><br />In the following example we will take a look at the way one can integrate JBoss Drools with Spring and an example of solving a similar problem without Drools.<br /><br /><br /><a name='more'></a><br /><br />Let us assume that we hava a POJO - a product that can represent either a Medical or Electronic product.&nbsp; <br /><br /><b>Product.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.model;<br /><br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />public class Product {<br />    private final TypeEnum typeEnum;<br />    private String productName;<br /><br />    public Product(TypeEnum typeEnum) {<br />        this.typeEnum = typeEnum;<br />        productName = typeEnum.getSomeOutputString();<br />    }<br /><br />    public TypeEnum getTypeEnum() {<br />        return typeEnum;<br />    }<br /><br />    public String getProductName() {<br />        return productName;<br />    }<br /><br />    public void setProductName(String productName) {<br />        this.productName = productName;<br />    }<br />}<br /><br /></pre>What defines the type of a product is the TypeEnum. It also has an outputString - let's assume that it defines a brand of a product (or whatever you want ;) )<br /><br /><b>TypeEnum.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.enums;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />public enum TypeEnum {<br />    MEDICAL("medical", "aaabbbccc"), ELECTRONIC("electronic", "cccbbbaaa");<br /><br /><br />    private final String type;<br />    private final String someOutputString;<br /><br />    private TypeEnum(String type, String someOutputString) {<br />        this.type = type;<br />        this.someOutputString = someOutputString;<br />    }<br /><br />    public String getType() {<br />        return type;<br />    }<br /><br />    public String getSomeOutputString() {<br />        return someOutputString;<br />    }<br />}<br /></pre><br />Let's say that the logic behind our rools is such that depending on the type of the enum we want to have some processing done (in our case we will have the same type of processing - converting each 'a' to 'b' in the output string).<br /><br /><b>NoRulesProductServiceImpl.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.nondrools;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br />import pl.grzejszczak.marcin.drools.springintegration.service.ProductService;<br /><br />import java.util.List;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("NoRulesProductServiceImpl")<br />public class NoRulesProductServiceImpl implements ProductService {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(NoRulesProductServiceImpl.class);<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingService")<br />    private Processor&lt;List&lt;Product&gt;&gt; productProcessingService;<br /><br />    @Override<br />    public void runProductLogic() {<br />        LOGGER.debug("Running product logic without Drools");<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        LOGGER.debug("Running rules for products...");<br />        productProcessingService.process(newArrayList(medicalProduct, electronicProduct));<br />        LOGGER.debug("...finished running products.");<br />    }<br />}<br /></pre><br />The ProductProcessingService is itterating over the given products, finds a producer for them and processes them.<br /><br /><b>ProductProcessingService.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.nondrools;<br /><br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br /><br />import java.util.List;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("ProductProcessingService")<br />public class ProductProcessingService implements Processor&lt;List&lt;Product&gt;&gt; {<br /><br />    @Autowired<br />    @Qualifier("NoRulesProcessingFactory")<br />    private ProcessingFactory&lt;Processor, Product&gt; processingFactory;<br /><br />    @Override<br />    public void process(List&lt;Product&gt; input) {<br />        for(Product product : input){<br />            Processor&lt;Product&gt; processor = processingFactory.createProcessingObject(product);<br />            processor.process(product);<br />        }<br />    }<br />}<br /></pre><br />The ProcessingFactory is an interface that basing on the given input (Product) produces an ouput (Processor) that afterwards does further processing. In our case we have a factory that instead of using a bunch of ifs (imagine that we have more than just two types of products) is using a map that matches a type of product with an implementation of a processor. As you can see we change a sequence of ifs into a single get.<br /><br /><b>NoRulesProcessingFactory.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.factory.nondrools;<br /><br />import com.google.common.collect.ImmutableMap;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.nondrools.ElectronicProductProcessingService;<br />import pl.grzejszczak.marcin.drools.springintegration.service.nondrools.MedicalProductProcessingService;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br /><br />import java.util.Map;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("NoRulesProcessingFactory")<br />public class NoRulesProcessingFactory  implements ProcessingFactory&lt;Processor, Product&gt; {<br /><br />    private static final Map&lt;TypeEnum, Processor&gt; PROCESSOR_MAP = new ImmutableMap.Builder&lt;TypeEnum, Processor&gt;().<br />            put(TypeEnum.MEDICAL, new MedicalProductProcessingService()).<br />            put(TypeEnum.ELECTRONIC, new ElectronicProductProcessingService()).<br />            build();<br /><br />    /**<br />     * By using the map we don't have any ifs<br />     * @param inputObject<br />     * @return<br />     */<br />    @Override<br />    public Processor createProcessingObject(Product inputObject) {<br />        return PROCESSOR_MAP.get(inputObject.getTypeEnum());<br />    }<br />}<br /></pre><br />I will present here only one ProcessingService since the other one is exactly the same (I just wanted to show the concept).<br /><br /><b>ElectronicProductProcessingService.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.nondrools;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br />import pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil;<br /><br />import static com.google.common.base.Preconditions.checkArgument;<br />import static java.lang.String.format;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />public class ElectronicProductProcessingService implements Processor&lt;Product&gt; {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ElectronicProductProcessingService.class);<br /><br />    @Override<br />    public void process(Product input) {<br />        checkArgument(TypeEnum.ELECTRONIC.equals(input.getTypeEnum()), "This processing service works only for electronic devices");<br />        checkArgument(!SomeUtil.replaceAWithB(input.getProductName()).equals(input.getProductName()), "The input has already been processed");<br />        LOGGER.debug("Running processing for Electronic Product");<br />        input.setProductName(SomeUtil.replaceAWithB(input.getProductName()));<br />        LOGGER.debug(format("ELECTRONIC rule applied without Drools, product name is now equal to [%s]", input.getProductName()));<br />    }<br />}<br /></pre><br />As you can see there are quite a few things that need to be tested and supported here. Imagine what would happen if we had 100 of types with more sophisticated rules than merely replacing one letter with the other.  So how can we do it with Drools? Let's start with taking a look at the pom.xml.<br /><br /><b>pom.xml  </b><br /><br /><pre class="brush:xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br /> xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br /> &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br /> &lt;groupId&gt;pl.grzejszczak.marcin&lt;/groupId&gt;<br /> &lt;artifactId&gt;drools-spring-integration&lt;/artifactId&gt;<br /> &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br /><br /> &lt;properties&gt;<br />  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;<br />  &lt;maven.compiler.source&gt;1.6&lt;/maven.compiler.source&gt;<br />  &lt;maven.compiler.target&gt;1.6&lt;/maven.compiler.target&gt;<br /><br />  &lt;spring.version&gt;3.1.1.RELEASE&lt;/spring.version&gt;<br /> &lt;/properties&gt;<br /> &lt;repositories&gt;<br />  &lt;repository&gt;<br />   &lt;id&gt;spring-release&lt;/id&gt;<br />   &lt;url&gt;http://maven.springframework.org/release&lt;/url&gt;<br />  &lt;/repository&gt;<br /> &lt;/repositories&gt;<br /><br /> &lt;dependencies&gt;<br />  &lt;!-- Spring --&gt;<br />  &lt;dependency&gt;<br />   &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />   &lt;artifactId&gt;spring-core&lt;/artifactId&gt;<br />   &lt;version&gt;${spring.version}&lt;/version&gt;<br />  &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br />            &lt;version&gt;${spring.version}&lt;/version&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;<br />            &lt;artifactId&gt;guava&lt;/artifactId&gt;<br />            &lt;version&gt;13.0.1&lt;/version&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;<br />            &lt;version&gt;${spring.version}&lt;/version&gt;<br />        &lt;/dependency&gt;<br />  &lt;dependency&gt;<br />            &lt;groupId&gt;org.drools&lt;/groupId&gt;<br />            &lt;artifactId&gt;drools-spring&lt;/artifactId&gt;<br />            &lt;version&gt;5.4.0.Final&lt;/version&gt;<br />        &lt;/dependency&gt;<br />  &lt;dependency&gt;<br />            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br />            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;<br />            &lt;version&gt;1.6.6&lt;/version&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;junit&lt;/groupId&gt;<br />            &lt;artifactId&gt;junit&lt;/artifactId&gt;<br />            &lt;version&gt;4.10&lt;/version&gt;<br />            &lt;scope&gt;test&lt;/scope&gt;<br />        &lt;/dependency&gt;<br /><br />    &lt;/dependencies&gt;<br />&lt;/project&gt;<br /><br /></pre>Let's take a look at the applicationContext.xml and the drools-context.xml. As for the first one what we do in fact is just showing where to scan for classes in terms of Spring and where to import the drools context from.<br /><br /><b>applicationContext.xml  </b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xsi:schemaLocation="http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd<br />                           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;<br /><br />    &lt;import resource="classpath:drools-context.xml"/&gt;<br />    &lt;!-- Show Spring where to search for the beans (in which packages) --&gt;<br />    &lt;context:component-scan base-package="pl.grzejszczak.marcin.drools.springintegration" /&gt;<br /><br />&lt;/beans&gt;<br /></pre><br />The context for drools. Take a look at the aliases for productsKSession. By providing alias we are joining two potential knowledge sessions into a single one. A single knowledge session is defined for a single knowledge base. For the knowledge base we are providing the list (in our case just a single resource) of drl files (we could have provided an excel spreadsheet).<br /><br /><b>drools-context.xml  </b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:drools="http://drools.org/schema/drools-spring"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />  http://drools.org/schema/drools-spring http://drools.org/schema/drools-spring.xsd"&gt;<br /><br />    &lt;!-- KNOWLEDGE BASE FOR A GIVEN TYPE --&gt;<br />    &lt;drools:kbase id="productsKBase"&gt;<br />        &lt;drools:resources&gt;<br />            &lt;drools:resource type="DRL"<br />                             source="classpath:rules/products.drl"/&gt;<br />        &lt;/drools:resources&gt;<br />    &lt;/drools:kbase&gt;<br /><br />    &lt;drools:ksession id="productsKSession" name="productsKSession" type="stateless" kbase="productsKBase"/&gt;<br />    &lt;alias name="productsKSession" alias="electronicKSession"/&gt;<br />    &lt;alias name="productsKSession" alias="medicalKSession"/&gt;<br /><br />&lt;/beans&gt;<br /></pre><br />Let's check the drl file.<br /><br />We define two rules - "MEDICAL rule" and "ELECTRONIC rule". For each case we are checking:<br /><br /><ul><li>whether the input object is of Product type&nbsp;</li><li>whether it has typeEnum equal to either Medical or Electronic&nbsp;</li><li>whether it hasn't already had it's productName changed&nbsp;</li></ul><br />Then we are addressing the product by means of a variable $product. We are modifying the product using the <span style="font-family: Courier New, Courier, monospace;">modify </span>keyword (which means that all the rules are rechecked - try removing the condition 'productName != replaceAWithB($product.typeEnum.someOutputString' and you will have an endless loop) by setting a new productName. Take a look at all the imports and imports of functions. You can execute a static function (pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil.replaceAWithB or org.drools.core.util.StringUtils.isEmpty) by importing it in the drl file.<br />At the end we are logging that a rule has been applied.<br /><br /><b>products.drl  </b><br /><br /><pre class="brush:xml">package pl.grzejszczak.marcin<br /><br />import org.slf4j.LoggerFactory<br />import pl.grzejszczak.marcin.drools.springintegration.DroolsSpring<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum<br /><br />import function pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil.replaceAWithB<br />import function org.drools.core.util.StringUtils.isEmpty<br /><br /><br />rule "MEDICAL rule"<br /> dialect "mvel"<br />when<br />     $product : Product( typeEnum == TypeEnum.MEDICAL, productName != replaceAWithB($product.typeEnum.someOutputString) )<br />then<br />     modify ($product) {productName = replaceAWithB($product.typeEnum.someOutputString)}<br />     LoggerFactory.getLogger(DroolsSpring.class).debug(String.format("MEDICAL rule applied, product name is now equal to [%s]", $product.productName))<br />end<br /><br />rule "ELECTRONIC rule"<br /> dialect "mvel"<br />when<br />     $product : Product( typeEnum == TypeEnum.ELECTRONIC, productName != replaceAWithB($product.typeEnum.someOutputString) )<br />then<br />     modify ($product) {productName = replaceAWithB($product.typeEnum.someOutputString)}<br />     LoggerFactory.getLogger(DroolsSpring.class).debug(String.format("ELECTRONIC rule applied, product name is now equal to [%s]", $product.productName))<br />end<br /></pre><br />We use a factory that is choosing a proper StatelessKnowledgeSession - since we only want to modify an input object. In order to run Drools rules we are running the execute method with a list of input objects.&nbsp; <br /><br /><b>ProductServiceImpl.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.drools;<br /><br />import org.drools.runtime.StatelessKnowledgeSession;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.ProductService;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("ProductServiceImpl")<br />public class ProductServiceImpl implements ProductService {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ProductServiceImpl.class);<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingFactory")<br />    ProcessingFactory&lt;StatelessKnowledgeSession, Product&gt; processingFactory;<br /><br />    @Override<br />    public void runProductLogic() {<br />        LOGGER.debug("Running product logic");<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        StatelessKnowledgeSession statelessKnowledgeSession = processingFactory.createProcessingObject(medicalProduct);<br />        LOGGER.debug("Running rules for products...");<br />        statelessKnowledgeSession.execute(newArrayList(medicalProduct, electronicProduct));<br />        LOGGER.debug("...finished running products.");<br />    }<br />}<br /><br /></pre>Now let's have a look on how the factory is implemented. We are using aliases in the applicationContext.xml<br /><br /><b>ProductProcessingFactory.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.factory.drools;<br /><br />import org.drools.runtime.StatelessKnowledgeSession;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.context.ApplicationContext;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("ProductProcessingFactory")<br />public class ProductProcessingFactory implements ProcessingFactory&lt;StatelessKnowledgeSession, Product&gt; {<br /><br />    @Autowired<br />    private ApplicationContext applicationContext;<br /><br />    @Override<br />    public StatelessKnowledgeSession createProcessingObject(Product inputObject) {<br />        return (StatelessKnowledgeSession)applicationContext.getBean(inputObject.getTypeEnum().getType() + "KSession");<br />    }<br />}<br /></pre>Now how can we test if it works? I have two unit tests that prove it (they are not running in perfect isolation but they functionality of both approaches). Starting with the test for the manual rules creation test. <br /><br /><b>NoRulesProductServiceImplTest.java </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service;<br /><br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil;<br /><br />import java.util.List;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br />import static java.lang.String.format;<br />import static org.junit.Assert.assertEquals;<br />import static org.junit.Assert.assertNotSame;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = {"classpath:applicationContext.xml"})<br />public class NoRulesProductServiceImplTest {<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingService")<br />    private Processor&lt;List&lt;Product&gt;&gt; productProcessingService;<br /><br /><br />    /**<br />     * Test is not run in perfect isolation - the purpose is to show the outcome of processing without Drools<br />     *<br />     * @throws Exception<br />     */<br />    @Test<br />    public void testRunProductLogic() throws Exception {<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        String initialMedicalProductName = medicalProduct.getProductName();<br />        String initialElectronicProduct = electronicProduct.getProductName();<br />        System.out.println(format("Initial productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Initial productName for Electronic [%s]", electronicProduct.getProductName()));<br /><br />        productProcessingService.process(newArrayList(medicalProduct, electronicProduct));<br /><br />        String finalMedicalProduct = medicalProduct.getProductName();<br />        String finalElectronicProduct = electronicProduct.getProductName();<br />        assertNotSame(finalMedicalProduct, initialMedicalProductName);<br />        assertNotSame(finalElectronicProduct, initialElectronicProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialMedicalProductName), finalMedicalProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialElectronicProduct), finalElectronicProduct);<br /><br />        System.out.println(format("Final productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Final productName for Electronic [%s]", electronicProduct.getProductName()));<br />    }<br />}<br /></pre><br />And the unit test for the Drools approach.<br /><br /><b>ProductServiceImplTest.java </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service;<br /><br />import org.drools.runtime.StatelessKnowledgeSession;<br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br />import static java.lang.String.format;<br />import static org.junit.Assert.assertEquals;<br />import static org.junit.Assert.assertNotSame;<br />import static org.junit.Assert.assertTrue;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = {"classpath:applicationContext.xml"})<br />public class ProductServiceImplTest {<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingFactory")<br />    ProcessingFactory&lt;StatelessKnowledgeSession, Product&gt; processingFactory;<br /><br />    /**<br />     * Test is not run in perfect isolation - the purpose is to show the outcome of processing with Drools<br />     * @throws Exception<br />     */<br />    @Test<br />    public void testRunProductLogic() throws Exception {<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        String initialMedicalProductName = medicalProduct.getProductName();<br />        String initialElectronicProduct = electronicProduct.getProductName();<br />        System.out.println(format("Initial productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Initial productName for Electronic [%s]", electronicProduct.getProductName()));<br /><br />        StatelessKnowledgeSession statelessKnowledgeSessionForMedical = processingFactory.createProcessingObject(medicalProduct);<br />        StatelessKnowledgeSession statelessKnowledgeSessionForElectronic = processingFactory.createProcessingObject(electronicProduct);<br />        assertTrue(statelessKnowledgeSessionForMedical == statelessKnowledgeSessionForElectronic);<br />        System.out.println("References for stateless sessions are the same, executing rules...");<br /><br />        statelessKnowledgeSessionForMedical.execute(newArrayList(medicalProduct, electronicProduct));<br /><br />        String finalMedicalProduct = medicalProduct.getProductName();<br />        String finalElectronicProduct = electronicProduct.getProductName();<br />        assertNotSame(finalMedicalProduct, initialMedicalProductName);<br />        assertNotSame(finalElectronicProduct, initialElectronicProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialMedicalProductName), finalMedicalProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialElectronicProduct), finalElectronicProduct);<br /><br />        System.out.println(format("Final productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Final productName for Electronic [%s]", electronicProduct.getProductName()));<br />    }<br />}<br /></pre>Now let's take a look at the logs - take a look that 'Executing some logic' took place 6 times for Drools since when you modify an object the rules are revalidated and rerun:  <br /><br /><pre class="brush:xml">org.springframework.context.support.ClassPathXmlApplicationContext:495 Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@743399: startup date [Tue Jan 15 16:32:30 CET 2013]; root of context hierarchy<br />org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [applicationContext.xml]<br />org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [drools-context.xml]<br />[main] org.springframework.beans.factory.support.DefaultListableBeanFactory:557 Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@3b1d04: defining beans [productsKBase,productsKSession,ProductProcessingFactory,NoRulesProcessingFactory,ProductServiceImpl,NoRulesProductServiceImpl,ProductProcessingService,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy<br />pl.grzejszczak.marcin.drools.springintegration.service.drools.ProductServiceImpl:32 Running product logic<br />pl.grzejszczak.marcin.drools.springintegration.service.drools.ProductServiceImpl:36 Running rules for products...<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.DroolsSpring:? ELECTRONIC rule applied, product name is now equal to [cccbbbbbb]<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.DroolsSpring:? MEDICAL rule applied, product name is now equal to [bbbbbbccc]<br />pl.grzejszczak.marcin.drools.springintegration.service.drools.ProductServiceImpl:38 ...finished running products.<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.NoRulesProductServiceImpl:33 Running product logic without Drools<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.NoRulesProductServiceImpl:36 Running rules for products...<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.MedicalProductProcessingService:26 Running processing for Medical Product<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.MedicalProductProcessingService:28 MEDICAL rule applied without Drools, product name is now equal to [bbbbbbccc]<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.ElectronicProductProcessingService:26 Running processing for Electronic Product<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.ElectronicProductProcessingService:28 ELECTRONIC rule applied without Drools, product name is now equal to [cccbbbbbb]<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.NoRulesProductServiceImpl:38 ...finished running products.<br /></pre><br />Viola! That's how you can write some rules with Drools that can save plenty of time and effort as far as business logic is concerned. You can find the sources here at my <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/3d8a2ef67b5b/Drools/Spring%20integration?at=default">BitBucket repository</a>.</div>

]]></content>
  </entry>
  
</feed>
