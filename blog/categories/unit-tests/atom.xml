<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Unit Tests | TOO MUCH CODING]]></title>
  <link href="https://toomuchcoding.com/blog/categories/unit-tests/atom.xml" rel="self"/>
  <link href="https://toomuchcoding.com/"/>
  <updated>2019-05-15T14:03:07+02:00</updated>
  <id>https://toomuchcoding.com/</id>
  <author>
    <name><![CDATA[Marcin Grzejszczak]]></name>
    <email><![CDATA[blog@toomuchcoding.com]]></email>
  </author>
  <generator uri="https://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mockito Instant - My Book Has Finally Been Published!]]></title>
    <link href="https://toomuchcoding.com/blog/2013/08/28/mockito-instant-my-book-has-finally/"/>
    <updated>2013-08-28T01:20:00-07:00</updated>
    <id>https://toomuchcoding.com/blog/2013/08/28/mockito-instant-my-book-has-finally</id>
    <content type="html"><![CDATA[<div class='post'>
I am very pleased to announce that my book about Mockito entitled "Mockito Instant" has finally been published! You can buy it at&nbsp;<a href="https://www.packtpub.com/how-to-create-stubs-mocks-spies-using-mockito/book">Packt Publishing online shop</a>.</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mockito - Extra Interfaces With Annotations and Static Methods]]></title>
    <link href="https://toomuchcoding.com/blog/2013/06/12/mockito-extra-interfaces-with/"/>
    <updated>2013-06-12T04:12:00-07:00</updated>
    <id>https://toomuchcoding.com/blog/2013/06/12/mockito-extra-interfaces-with</id>
    <content type="html"><![CDATA[<div class='post'>
<br />In the code I have quite recently came across a really bad piece of code that based on class casting in terms of performing some actions on objects. Of course the code needed to be refactored but sometimes you can't do it / or don't want to do it (and it should be understandable) if first you don't have unit tests of that functionality. In the following post I will show how to test such code, how to refactor it and in fact what I think about such code ;) <div><br /></div><div><a name='more'></a><br />
<!--more-->
</div><div>Let's take a look at the project structure:</div><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-RpIw1Ccnof8/UbhBR8EHqbI/AAAAAAAABZU/cPRqLAPNCHU/s1600/Mockito+Extra+Interfaces.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="https://3.bp.blogspot.com/-RpIw1Ccnof8/UbhBR8EHqbI/AAAAAAAABZU/cPRqLAPNCHU/s320/Mockito+Extra+Interfaces.jpg" width="152" /></a></div><span id="goog_1682433447"></span><span id="goog_1682433448"></span><br /></div><div>As presented in the post regarding <a href="https://toomuchcoding.blogspot.com/2013/06/mockito-returndeepstubs-for-jaxb.html">Mocktio RETURNS_DEEP_STUBS Answer for JAXB</a>&nbsp;yet again we have the JAXB generated classes by the JAXB compiler in the <b>com.blogspot.toomuchcoding.model</b> package. Let's ommit the discussion over the <b>pom.xml</b> file since it's exactly the same as in the previous post.<br /><br />In the&nbsp;<b>com.blogspot.toomuchcoding.adapter</b>&nbsp;package we have adapters over the JAXB PlayerDetails class that provides access to the Player interface. There is the<br /><br /><b>CommonPlayerAdapter.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.adapter;<br /><br />import com.blogspot.toomuchcoding.model.Player;<br />import com.blogspot.toomuchcoding.model.PlayerDetails;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 09.06.13<br /> * Time: 15:42<br /> */<br />public class CommonPlayerAdapter implements Player {<br />    private final PlayerDetails playerDetails;<br /><br />    public CommonPlayerAdapter(PlayerDetails playerDetails){<br />        this.playerDetails = playerDetails;<br />    }<br /><br />    @Override<br />    public void run() {<br />        System.out.printf("Run %s. Run!%n", playerDetails.getName());<br />    }<br /><br />    public PlayerDetails getPlayerDetails() {<br />        return playerDetails;<br />    }<br />}<br /><br /></pre><br /><b>DefencePlayerAdapter.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.adapter;<br /><br />import com.blogspot.toomuchcoding.model.DJ;<br />import com.blogspot.toomuchcoding.model.DefensivePlayer;<br />import com.blogspot.toomuchcoding.model.JavaDeveloper;<br />import com.blogspot.toomuchcoding.model.PlayerDetails;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 09.06.13<br /> * Time: 15:42<br /> */<br />public class DefencePlayerAdapter extends CommonPlayerAdapter implements DefensivePlayer, DJ, JavaDeveloper {<br /><br />    public DefencePlayerAdapter(PlayerDetails playerDetails){<br />        super(playerDetails);<br />    }<br /><br />    @Override<br />    public void defend(){<br />        System.out.printf("Defence! %s. Defence!%n", getPlayerDetails().getName());<br />    }<br /><br />    @Override<br />    public void playSomeMusic() {<br />        System.out.println("Oops I did it again...!");<br />    }<br /><br />    @Override<br />    public void doSomeSeriousCoding() {<br />        System.out.println("System.out.println(\"Hello world\");");<br />    }<br />}<br /><br /></pre><b>OffensivePlayerAdapter.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.adapter;<br /><br />import com.blogspot.toomuchcoding.model.OffensivePlayer;<br />import com.blogspot.toomuchcoding.model.PlayerDetails;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 09.06.13<br /> * Time: 15:42<br /> */<br />public class OffensivePlayerAdapter extends CommonPlayerAdapter implements OffensivePlayer {<br /><br />    public OffensivePlayerAdapter(PlayerDetails playerDetails){<br />        super(playerDetails);<br />    }<br /><br />    @Override<br />    public void shoot(){<br />        System.out.printf("%s Shooooot!.%n", getPlayerDetails().getName());<br />    }<br />}<br /><br /></pre>Ok, now let's go to the more interesting part. Let us assume that we have a very simple factory of players:<br /><br /><b>PlayerFactoryImpl.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.factory;<br /><br />import com.blogspot.toomuchcoding.adapter.CommonPlayerAdapter;<br />import com.blogspot.toomuchcoding.adapter.DefencePlayerAdapter;<br />import com.blogspot.toomuchcoding.adapter.OffensivePlayerAdapter;<br />import com.blogspot.toomuchcoding.model.Player;<br />import com.blogspot.toomuchcoding.model.PlayerDetails;<br />import com.blogspot.toomuchcoding.model.PositionType;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 09.06.13<br /> * Time: 15:53<br /> */<br /><br />public class PlayerFactoryImpl implements PlayerFactory {<br /><br />    @Override<br />    public Player createPlayer(PositionType positionType) {<br />        PlayerDetails player = createCommonPlayer(positionType);<br />        switch (positionType){<br />            case ATT:<br />                return new OffensivePlayerAdapter(player);<br />            case MID:<br />                return new OffensivePlayerAdapter(player);<br />            case DEF:<br />                return new DefencePlayerAdapter(player);<br />            case GK:<br />                return new DefencePlayerAdapter(player);<br />            default:<br />                return new CommonPlayerAdapter(player);<br />        }<br />    }<br /><br />    private PlayerDetails createCommonPlayer(PositionType positionType){<br />        PlayerDetails playerDetails = new PlayerDetails();<br />        playerDetails.setPosition(positionType);<br />        return playerDetails;<br />    }<br />}<br /><br /></pre>Ok so we have the factory that builds Players. Let's take a look at the Service that uses the factory:<br /><br /><b>PlayerServiceImpl.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.service;<br /><br />import com.blogspot.toomuchcoding.factory.PlayerFactory;<br />import com.blogspot.toomuchcoding.model.*;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 08.06.13<br /> * Time: 19:02<br /> */<br />public class PlayerServiceImpl implements PlayerService {<br /><br />    private PlayerFactory playerFactory;<br /><br />    @Override<br />    public Player playAGameWithAPlayerOfPosition(PositionType positionType) {<br />        Player player = playerFactory.createPlayer(positionType);<br />        player.run();<br />        performAdditionalActions(player);<br />        return player;<br />    }<br /><br />    private void performAdditionalActions(Player player) {<br />        if(player instanceof OffensivePlayer){<br />            OffensivePlayer offensivePlayer = (OffensivePlayer) player;<br />            performAdditionalActionsForTheOffensivePlayer(offensivePlayer);<br />        }else if(player instanceof DefensivePlayer){<br />            DefensivePlayer defensivePlayer = (DefensivePlayer) player;<br />            performAdditionalActionsForTheDefensivePlayer(defensivePlayer);<br />        }<br />    }<br /><br />    private void performAdditionalActionsForTheOffensivePlayer(OffensivePlayer offensivePlayer){<br />        offensivePlayer.shoot();<br />    }<br /><br />    private void performAdditionalActionsForTheDefensivePlayer(DefensivePlayer defensivePlayer){<br />        defensivePlayer.defend();<br />        try{<br />            DJ dj = (DJ)defensivePlayer;<br />            dj.playSomeMusic();<br />            JavaDeveloper javaDeveloper = (JavaDeveloper)defensivePlayer;<br />            javaDeveloper.doSomeSeriousCoding();<br />        }catch(ClassCastException exception){<br />            System.err.println("Sorry, I can't do more than just play football...");<br />        }<br />    }<br /><br />    public PlayerFactory getPlayerFactory() {<br />        return playerFactory;<br />    }<br /><br />    public void setPlayerFactory(PlayerFactory playerFactory) {<br />        this.playerFactory = playerFactory;<br />    }<br />}<br /><br /></pre>Let's admit it... this code is bad. Internally when you look at it (regardless of the fact whether it used <b>instance of</b> operator or not) you feel that it is evil :) As you can see in the code we have some class casts going on... How on earth can we test it? In the majority of testing frameworks you can't do such class casts on mocks since they are built with the CGLIB library and there can be some ClassCastExceptions thrown. You could still not return mocks and real implementations (assuming that those will not perform any ugly stuff in the construction process) and it could actually work but still - this is bad code :P<br /><br />Mockito comes to the rescue (although you shouldn't overuse this feature - in fact if you need to use it please consider refactoring it) with its <b><a href="https://mockito.googlecode.com/svn/branches/1.8.5/javadoc/org/mockito/MockSettings.html#extraInterfaces(java.lang.Class...)">extraInterfaces</a></b> feature:<br /><br /><h3>extraInterfaces</h3><blockquote><a href="https://mockito.googlecode.com/svn/branches/1.8.5/javadoc/org/mockito/MockSettings.html" title="interface in org.mockito">MockSettings</a> <b>extraInterfaces</b>(java.lang.Class&lt;?&gt;...&nbsp;interfaces)<br />Specifies extra interfaces the mock should implement. Might be useful for legacy code or some corner cases. For background, see issue 51&nbsp;<a href="https://code.google.com/p/mockito/issues/detail?id=51">here</a>This mysterious feature should be used very occasionally. The object under test should know exactly its collaborators &amp; dependencies. If you happen to use it often than please make sure you are really producing simple, clean &amp; readable code.<br />Examples:<br />Foo foo = mock(Foo.class, withSettings().extraInterfaces(Bar.class, Baz.class));<br />//now, the mock implements extra interfaces, so following casting is possible:<br />Bar bar = (Bar) foo;<br />Baz baz = (Baz) foo;<br /><b>Parameters:</b><code>interfaces</code>&nbsp;- extra interfaces the should implement.<br /><b>Returns:</b>settings instance so that you can fluently specify other settings</blockquote><dl><dd></dd><dd><dl></dl></dd><dd><dl><div><br /></div></dl></dd></dl>Now let's take a look at the test:<br /><br /><b>PlayerServiceImplTest.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.service;<br /><br />import com.blogspot.toomuchcoding.factory.PlayerFactory;<br />import com.blogspot.toomuchcoding.model.*;<br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.mockito.InjectMocks;<br />import org.mockito.Mock;<br />import org.mockito.invocation.InvocationOnMock;<br />import org.mockito.runners.MockitoJUnitRunner;<br />import org.mockito.stubbing.Answer;<br /><br />import static org.hamcrest.CoreMatchers.is;<br />import static org.junit.Assert.assertThat;<br />import static org.mockito.BDDMockito.*;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 08.06.13<br /> * Time: 19:26<br /> */<br />@RunWith(MockitoJUnitRunner.class)<br />public class PlayerServiceImplTest {<br /><br />    @Mock<br />    PlayerFactory playerFactory;<br /><br />    @InjectMocks<br />    PlayerServiceImpl objectUnderTest;<br /><br />    @Mock(extraInterfaces = {DJ.class, JavaDeveloper.class})<br />    DefensivePlayer defensivePlayerWithDjAndJavaDevSkills;<br /><br />    @Mock<br />    DefensivePlayer defensivePlayer;<br /><br />    @Mock<br />    OffensivePlayer offensivePlayer;<br /><br />    @Mock<br />    Player commonPlayer;<br /><br />    @Test<br />    public void shouldReturnOffensivePlayerThatRan() throws Exception {<br />        //given<br />        given(playerFactory.createPlayer(PositionType.ATT)).willReturn(offensivePlayer);<br /><br />        //when<br />        Player createdPlayer = objectUnderTest.playAGameWithAPlayerOfPosition(PositionType.ATT);<br /><br />        //then<br />        assertThat(createdPlayer == offensivePlayer, is(true));<br />        verify(offensivePlayer).run();<br />    }<br /><br />    @Test<br />    public void shouldReturnDefensivePlayerButHeWontBeADjNorAJavaDev() throws Exception {<br />        //given<br />        given(playerFactory.createPlayer(PositionType.GK)).willReturn(defensivePlayer);<br /><br />        //when<br />        Player createdPlayer = objectUnderTest.playAGameWithAPlayerOfPosition(PositionType.GK);<br /><br />        //then<br />        assertThat(createdPlayer == defensivePlayer, is(true));<br />        verify(defensivePlayer).run();<br />        verify(defensivePlayer).defend();<br />        verifyNoMoreInteractions(defensivePlayer);<br />    }<br /><br />    @Test<br />    public void shouldReturnDefensivePlayerBeingADjAndAJavaDev() throws Exception {<br />        //given<br />        given(playerFactory.createPlayer(PositionType.GK)).willReturn(defensivePlayerWithDjAndJavaDevSkills);<br />        doAnswer(new Answer&lt;Object&gt;() {<br />            @Override<br />            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {<br />                System.out.println("Hit me baby one more time!");<br />                return null;<br />            }<br />        }).when(((DJ) defensivePlayerWithDjAndJavaDevSkills)).playSomeMusic();<br />        doAnswer(new Answer&lt;Object&gt;() {<br />            @Override<br />            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {<br />                System.out.println("public static void main(String... args){\n}");<br />                return null;<br />            }<br />        }).when(((JavaDeveloper) defensivePlayerWithDjAndJavaDevSkills)).doSomeSeriousCoding();<br /><br />        //when<br />        Player createdPlayer = objectUnderTest.playAGameWithAPlayerOfPosition(PositionType.GK);<br /><br />        //then<br />        assertThat(createdPlayer == defensivePlayerWithDjAndJavaDevSkills, is(true));<br />        verify(defensivePlayerWithDjAndJavaDevSkills).run();<br />        verify(defensivePlayerWithDjAndJavaDevSkills).defend();<br />        verify((DJ) defensivePlayerWithDjAndJavaDevSkills).playSomeMusic();<br />        verify((JavaDeveloper) defensivePlayerWithDjAndJavaDevSkills).doSomeSeriousCoding();<br />    }<br /><br />    @Test<br />    public void shouldReturnDefensivePlayerBeingADjAndAJavaDevByUsingWithSettings() throws Exception {<br />        //given<br />        DefensivePlayer defensivePlayerWithDjAndJavaDevSkills = mock(DefensivePlayer.class, withSettings().extraInterfaces(DJ.class, JavaDeveloper.class));<br />        given(playerFactory.createPlayer(PositionType.GK)).willReturn(defensivePlayerWithDjAndJavaDevSkills);<br />        doAnswer(new Answer&lt;Object&gt;() {<br />            @Override<br />            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {<br />                System.out.println("Hit me baby one more time!");<br />                return null;<br />            }<br />        }).when(((DJ) defensivePlayerWithDjAndJavaDevSkills)).playSomeMusic();<br />        doAnswer(new Answer&lt;Object&gt;() {<br />            @Override<br />            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {<br />                System.out.println("public static void main(String... args){\n}");<br />                return null;<br />            }<br />        }).when(((JavaDeveloper) defensivePlayerWithDjAndJavaDevSkills)).doSomeSeriousCoding();<br /><br />        //when<br />        Player createdPlayer = objectUnderTest.playAGameWithAPlayerOfPosition(PositionType.GK);<br /><br />        //then<br />        assertThat(createdPlayer == defensivePlayerWithDjAndJavaDevSkills, is(true));<br />        verify(defensivePlayerWithDjAndJavaDevSkills).run();<br />        verify(defensivePlayerWithDjAndJavaDevSkills).defend();<br />        verify((DJ) defensivePlayerWithDjAndJavaDevSkills).playSomeMusic();<br />        verify((JavaDeveloper) defensivePlayerWithDjAndJavaDevSkills).doSomeSeriousCoding();<br />    }<br /><br />    @Test<br />    public void shouldReturnCommonPlayer() throws Exception {<br />        //given<br />        given(playerFactory.createPlayer(null)).willReturn(commonPlayer);<br /><br />        //when<br />        Player createdPlayer = objectUnderTest.playAGameWithAPlayerOfPosition(null);<br /><br />        //then<br />        assertThat(createdPlayer, is(commonPlayer));<br />    }<br />}<br /><br /></pre>There are quite a few tests here so let's take a look at the most interesting ones. &nbsp;But before we do it let's<br /><br />We start with providing the <b>@RunWith(MockitoJUnitRunner.class)</b>&nbsp;annotation which alows us to use the Mockito annotations such as&nbsp;<b>@Mock</b> and <b>@InjectMocks</b>.<br /><br />Speaking of which&nbsp;<b>@Mock</b> annotation creates a Mock whereas&nbsp;<b>@InjectMocks</b> inject all the mocks either by constructor or by setters (that's awesome isn't it? :) ).<br /><br />For the defensive player we are using the extra element of the annotation <b>extraInterfaces </b>that provides additional interfaces for the given Mock. You can also write (what you can find in the <b>shouldReturnDefensivePlayerBeingADjAndAJavaDevByUsingWithSettings</b> test) :<br /><br /><pre class="brush:java">DefensivePlayer defensivePlayerWithDjAndJavaDevSkills = mock(DefensivePlayer.class, withSettings().extraInterfaces(DJ.class, JavaDeveloper.class));<br /><br /></pre>Let's take a closer look at the test that we wrote for the functionality related to the DefensivePlayer and the casting part of the tested function:<br /><br /><pre class="brush:java">@Test<br />    public void shouldReturnDefensivePlayerBeingADjAndAJavaDev() throws Exception {<br />        //given<br />        given(playerFactory.createPlayer(PositionType.GK)).willReturn(defensivePlayerWithDjAndJavaDevSkills);<br />        doAnswer(new Answer&lt;Object&gt;() {<br />            @Override<br />            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {<br />                System.out.println("Hit me baby one more time!");<br />                return null;<br />            }<br />        }).when(((DJ) defensivePlayerWithDjAndJavaDevSkills)).playSomeMusic();<br />        doAnswer(new Answer&lt;Object&gt;() {<br />            @Override<br />            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {<br />                System.out.println("public static void main(String... args){\n}");<br />                return null;<br />            }<br />        }).when(((JavaDeveloper) defensivePlayerWithDjAndJavaDevSkills)).doSomeSeriousCoding();<br /><br />        //when<br />        Player createdPlayer = objectUnderTest.playAGameWithAPlayerOfPosition(PositionType.GK);<br /><br />        //then<br />        assertThat(createdPlayer == defensivePlayerWithDjAndJavaDevSkills, is(true));<br />        verify(defensivePlayerWithDjAndJavaDevSkills).run();<br />        verify(defensivePlayerWithDjAndJavaDevSkills).defend();<br />        verify((DJ) defensivePlayerWithDjAndJavaDevSkills).playSomeMusic();<br />        verify((JavaDeveloper) defensivePlayerWithDjAndJavaDevSkills).doSomeSeriousCoding();<br />    }<br /></pre><br />We are using the <b>BDDMockito</b> static methods like <b>given(...).willReturn(...).willAnswer(...)</b> etc. Then we are stubbing void methods with our custom Anwsers. In the next line you can see that in order to stub methods of another interface you have to cast the mock to the given interface. The same is related to the verification phase where i norder to check if a method was executed you have to cast the mock to the given interface.<br /><br />You could improve the test by returning a real implementation from the factory or if it's a "heavy" operation to create one you could return a mock of such an implementation. What I wanted to show here is how to use the extra interfaces in Mockito (perhaps my usecase is not the best one ;) ). Anyway the implementation presented in the test is bad so we should think of the way to refactor it...<br /><br />One of the ideas could be, assuming that the additional logic done in the Service is a part of the creation of the object, to move the code to the factory as such:<br /><br /><b>PlayFactoryImplWithFieldSettingLogic.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.factory;<br /><br />import com.blogspot.toomuchcoding.adapter.CommonPlayerAdapter;<br />import com.blogspot.toomuchcoding.adapter.DefencePlayerAdapter;<br />import com.blogspot.toomuchcoding.adapter.OffensivePlayerAdapter;<br />import com.blogspot.toomuchcoding.model.*;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 09.06.13<br /> * Time: 15:53<br /> */<br /><br />public class PlayerFactoryImplWithFieldSettingLogic implements PlayerFactory {<br /><br />    @Override<br />    public Player createPlayer(PositionType positionType) {<br />        PlayerDetails player = createCommonPlayer(positionType);<br />        switch (positionType){<br />            case ATT:<br />                return createOffensivePlayer(player);<br />            case MID:<br />                return createOffensivePlayer(player);<br />            case DEF:<br />                return createDefensivePlayer(player);<br />            case GK:<br />                return createDefensivePlayer(player);<br />            default:<br />                return new CommonPlayerAdapter(player);<br />        }<br />    }<br /><br />    private Player createDefensivePlayer(PlayerDetails player) {<br />        DefencePlayerAdapter defencePlayerAdapter = new DefencePlayerAdapter(player);<br />        defencePlayerAdapter.defend();<br />        defencePlayerAdapter.playSomeMusic();<br />        defencePlayerAdapter.doSomeSeriousCoding();<br />        return defencePlayerAdapter;<br />    }<br /><br />    private OffensivePlayer createOffensivePlayer(PlayerDetails player) {<br />        OffensivePlayer offensivePlayer = new OffensivePlayerAdapter(player);<br />        offensivePlayer.shoot();<br />        return offensivePlayer;<br />    }<br /><br />    private PlayerDetails createCommonPlayer(PositionType positionType){<br />        PlayerDetails playerDetails = new PlayerDetails();<br />        playerDetails.setPosition(positionType);<br />        return playerDetails;<br />    }<br />}<br /><br /></pre>In this way there is no casting the code is really clean. And now the PlayerService looks like this:<br /><br /><b>PlayerServiceImplWIthoutUnnecessaryLogic.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.service;<br /><br />import com.blogspot.toomuchcoding.factory.PlayerFactory;<br />import com.blogspot.toomuchcoding.model.*;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 08.06.13<br /> * Time: 19:02<br /> */<br />public class PlayerServiceImplWithoutUnnecessaryLogic implements PlayerService {<br /><br />    private PlayerFactory playerFactory;<br /><br />    /**<br />     * What's the point in having this method then?<br />     * @param positionType<br />     * @return<br />     */<br />    @Override<br />    public Player playAGameWithAPlayerOfPosition(PositionType positionType) {<br />        return playerFactory.createPlayer(positionType);<br />    }<br /><br />    public PlayerFactory getPlayerFactory() {<br />        return playerFactory;<br />    }<br /><br />    public void setPlayerFactory(PlayerFactory playerFactory) {<br />        this.playerFactory = playerFactory;<br />    }<br />}<br /><br /></pre>And the question arises whether there is even any need to have such a method in your code base...<br /><br />Summing it all up I hope that I managed to show how to:<br /><br /><ul><li>Use MockitoJUnitRunner to inject mocks in a clean way</li><li>Use annotations or static methods to add extra interfaces that can be used by your mock</li><li>Use BDDMockito to perform method stubbing</li><li>Stub void methods with custom answer</li><li>Stub and verify methods of the extra interfaces</li><li>Refactor code that is using class casts</li></ul><br />The sources are available at the <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/cab9f99626730e606c7ed354e81d141819351221/Unit%20Testing/Mockito%20-%20With%20Interfaces?at=default">TooMuchCoding Bitbucket</a> repository and <a href="https://github.com/marcingrzejszczak/too-much-coding/tree/master/Unit%20Testing/Mockito%20-%20With%20Interfaces">TooMuchCoding Github</a> repository.<br /><br /><br /><br /><br /></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Drools Integration With Spring vs Manual Rules Creation]]></title>
    <link href="https://toomuchcoding.com/blog/2013/01/15/drools-integration-with-spring-vs/"/>
    <updated>2013-01-15T08:04:00-08:00</updated>
    <id>https://toomuchcoding.com/blog/2013/01/15/drools-integration-with-spring-vs</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />Hi!<br /><br />&nbsp;Often in your work you can come across with issues related to business logic. Let us assume that you have dozens of rules (for the time being in our project we have more than 50 and I used to work on a project where we had hundreds of those rules) that you have to implement, divide into some classes, subclasses, abstractions and of course unit test. This can be difficult and timeconsuming to both write and support. There are many ways of dealing with this problem and I will show you one of them - JBoss Drools.<br />
<!--more-->
<br />Drools is a library specifically created for such purposes like implementing rules. As presented in Wikipedia:<br /><blockquote class="tr_bq">"Drools is a rule engine implementaion based on Charles Forgy's Rete Algorithm tailored for the Java language."&nbsp;</blockquote>It contains a rule engine that can process rules wirtten using the Drools language (you can also provide rules in Excel spreadsheets! - perfect for Business side to support and maintain).<br /><br />In the following example we will take a look at the way one can integrate JBoss Drools with Spring and an example of solving a similar problem without Drools.<br /><br /><br /><a name='more'></a><br /><br />Let us assume that we hava a POJO - a product that can represent either a Medical or Electronic product.&nbsp; <br /><br /><b>Product.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.model;<br /><br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />public class Product {<br />    private final TypeEnum typeEnum;<br />    private String productName;<br /><br />    public Product(TypeEnum typeEnum) {<br />        this.typeEnum = typeEnum;<br />        productName = typeEnum.getSomeOutputString();<br />    }<br /><br />    public TypeEnum getTypeEnum() {<br />        return typeEnum;<br />    }<br /><br />    public String getProductName() {<br />        return productName;<br />    }<br /><br />    public void setProductName(String productName) {<br />        this.productName = productName;<br />    }<br />}<br /><br /></pre>What defines the type of a product is the TypeEnum. It also has an outputString - let's assume that it defines a brand of a product (or whatever you want ;) )<br /><br /><b>TypeEnum.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.enums;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />public enum TypeEnum {<br />    MEDICAL("medical", "aaabbbccc"), ELECTRONIC("electronic", "cccbbbaaa");<br /><br /><br />    private final String type;<br />    private final String someOutputString;<br /><br />    private TypeEnum(String type, String someOutputString) {<br />        this.type = type;<br />        this.someOutputString = someOutputString;<br />    }<br /><br />    public String getType() {<br />        return type;<br />    }<br /><br />    public String getSomeOutputString() {<br />        return someOutputString;<br />    }<br />}<br /></pre><br />Let's say that the logic behind our rools is such that depending on the type of the enum we want to have some processing done (in our case we will have the same type of processing - converting each 'a' to 'b' in the output string).<br /><br /><b>NoRulesProductServiceImpl.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.nondrools;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br />import pl.grzejszczak.marcin.drools.springintegration.service.ProductService;<br /><br />import java.util.List;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("NoRulesProductServiceImpl")<br />public class NoRulesProductServiceImpl implements ProductService {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(NoRulesProductServiceImpl.class);<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingService")<br />    private Processor&lt;List&lt;Product&gt;&gt; productProcessingService;<br /><br />    @Override<br />    public void runProductLogic() {<br />        LOGGER.debug("Running product logic without Drools");<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        LOGGER.debug("Running rules for products...");<br />        productProcessingService.process(newArrayList(medicalProduct, electronicProduct));<br />        LOGGER.debug("...finished running products.");<br />    }<br />}<br /></pre><br />The ProductProcessingService is itterating over the given products, finds a producer for them and processes them.<br /><br /><b>ProductProcessingService.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.nondrools;<br /><br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br /><br />import java.util.List;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("ProductProcessingService")<br />public class ProductProcessingService implements Processor&lt;List&lt;Product&gt;&gt; {<br /><br />    @Autowired<br />    @Qualifier("NoRulesProcessingFactory")<br />    private ProcessingFactory&lt;Processor, Product&gt; processingFactory;<br /><br />    @Override<br />    public void process(List&lt;Product&gt; input) {<br />        for(Product product : input){<br />            Processor&lt;Product&gt; processor = processingFactory.createProcessingObject(product);<br />            processor.process(product);<br />        }<br />    }<br />}<br /></pre><br />The ProcessingFactory is an interface that basing on the given input (Product) produces an ouput (Processor) that afterwards does further processing. In our case we have a factory that instead of using a bunch of ifs (imagine that we have more than just two types of products) is using a map that matches a type of product with an implementation of a processor. As you can see we change a sequence of ifs into a single get.<br /><br /><b>NoRulesProcessingFactory.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.factory.nondrools;<br /><br />import com.google.common.collect.ImmutableMap;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.nondrools.ElectronicProductProcessingService;<br />import pl.grzejszczak.marcin.drools.springintegration.service.nondrools.MedicalProductProcessingService;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br /><br />import java.util.Map;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("NoRulesProcessingFactory")<br />public class NoRulesProcessingFactory  implements ProcessingFactory&lt;Processor, Product&gt; {<br /><br />    private static final Map&lt;TypeEnum, Processor&gt; PROCESSOR_MAP = new ImmutableMap.Builder&lt;TypeEnum, Processor&gt;().<br />            put(TypeEnum.MEDICAL, new MedicalProductProcessingService()).<br />            put(TypeEnum.ELECTRONIC, new ElectronicProductProcessingService()).<br />            build();<br /><br />    /**<br />     * By using the map we don't have any ifs<br />     * @param inputObject<br />     * @return<br />     */<br />    @Override<br />    public Processor createProcessingObject(Product inputObject) {<br />        return PROCESSOR_MAP.get(inputObject.getTypeEnum());<br />    }<br />}<br /></pre><br />I will present here only one ProcessingService since the other one is exactly the same (I just wanted to show the concept).<br /><br /><b>ElectronicProductProcessingService.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.nondrools;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br />import pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil;<br /><br />import static com.google.common.base.Preconditions.checkArgument;<br />import static java.lang.String.format;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />public class ElectronicProductProcessingService implements Processor&lt;Product&gt; {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ElectronicProductProcessingService.class);<br /><br />    @Override<br />    public void process(Product input) {<br />        checkArgument(TypeEnum.ELECTRONIC.equals(input.getTypeEnum()), "This processing service works only for electronic devices");<br />        checkArgument(!SomeUtil.replaceAWithB(input.getProductName()).equals(input.getProductName()), "The input has already been processed");<br />        LOGGER.debug("Running processing for Electronic Product");<br />        input.setProductName(SomeUtil.replaceAWithB(input.getProductName()));<br />        LOGGER.debug(format("ELECTRONIC rule applied without Drools, product name is now equal to [%s]", input.getProductName()));<br />    }<br />}<br /></pre><br />As you can see there are quite a few things that need to be tested and supported here. Imagine what would happen if we had 100 of types with more sophisticated rules than merely replacing one letter with the other.  So how can we do it with Drools? Let's start with taking a look at the pom.xml.<br /><br /><b>pom.xml  </b><br /><br /><pre class="brush:xml">&lt;project xmlns="https://maven.apache.org/POM/4.0.0" xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"<br /> xsi:schemaLocation="https://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br /> &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br /> &lt;groupId&gt;pl.grzejszczak.marcin&lt;/groupId&gt;<br /> &lt;artifactId&gt;drools-spring-integration&lt;/artifactId&gt;<br /> &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br /><br /> &lt;properties&gt;<br />  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;<br />  &lt;maven.compiler.source&gt;1.6&lt;/maven.compiler.source&gt;<br />  &lt;maven.compiler.target&gt;1.6&lt;/maven.compiler.target&gt;<br /><br />  &lt;spring.version&gt;3.1.1.RELEASE&lt;/spring.version&gt;<br /> &lt;/properties&gt;<br /> &lt;repositories&gt;<br />  &lt;repository&gt;<br />   &lt;id&gt;spring-release&lt;/id&gt;<br />   &lt;url&gt;https://maven.springframework.org/release&lt;/url&gt;<br />  &lt;/repository&gt;<br /> &lt;/repositories&gt;<br /><br /> &lt;dependencies&gt;<br />  &lt;!-- Spring --&gt;<br />  &lt;dependency&gt;<br />   &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />   &lt;artifactId&gt;spring-core&lt;/artifactId&gt;<br />   &lt;version&gt;${spring.version}&lt;/version&gt;<br />  &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br />            &lt;version&gt;${spring.version}&lt;/version&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;<br />            &lt;artifactId&gt;guava&lt;/artifactId&gt;<br />            &lt;version&gt;13.0.1&lt;/version&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;<br />            &lt;version&gt;${spring.version}&lt;/version&gt;<br />        &lt;/dependency&gt;<br />  &lt;dependency&gt;<br />            &lt;groupId&gt;org.drools&lt;/groupId&gt;<br />            &lt;artifactId&gt;drools-spring&lt;/artifactId&gt;<br />            &lt;version&gt;5.4.0.Final&lt;/version&gt;<br />        &lt;/dependency&gt;<br />  &lt;dependency&gt;<br />            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br />            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;<br />            &lt;version&gt;1.6.6&lt;/version&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;junit&lt;/groupId&gt;<br />            &lt;artifactId&gt;junit&lt;/artifactId&gt;<br />            &lt;version&gt;4.10&lt;/version&gt;<br />            &lt;scope&gt;test&lt;/scope&gt;<br />        &lt;/dependency&gt;<br /><br />    &lt;/dependencies&gt;<br />&lt;/project&gt;<br /><br /></pre>Let's take a look at the applicationContext.xml and the drools-context.xml. As for the first one what we do in fact is just showing where to scan for classes in terms of Spring and where to import the drools context from.<br /><br /><b>applicationContext.xml  </b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="https://www.springframework.org/schema/beans"<br />       xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:context="https://www.springframework.org/schema/context"<br />       xsi:schemaLocation="https://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context-3.0.xsd<br />                           https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;<br /><br />    &lt;import resource="classpath:drools-context.xml"/&gt;<br />    &lt;!-- Show Spring where to search for the beans (in which packages) --&gt;<br />    &lt;context:component-scan base-package="pl.grzejszczak.marcin.drools.springintegration" /&gt;<br /><br />&lt;/beans&gt;<br /></pre><br />The context for drools. Take a look at the aliases for productsKSession. By providing alias we are joining two potential knowledge sessions into a single one. A single knowledge session is defined for a single knowledge base. For the knowledge base we are providing the list (in our case just a single resource) of drl files (we could have provided an excel spreadsheet).<br /><br /><b>drools-context.xml  </b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="https://www.springframework.org/schema/beans"<br />       xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:drools="https://drools.org/schema/drools-spring"<br />       xsi:schemaLocation="https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />  https://drools.org/schema/drools-spring https://drools.org/schema/drools-spring.xsd"&gt;<br /><br />    &lt;!-- KNOWLEDGE BASE FOR A GIVEN TYPE --&gt;<br />    &lt;drools:kbase id="productsKBase"&gt;<br />        &lt;drools:resources&gt;<br />            &lt;drools:resource type="DRL"<br />                             source="classpath:rules/products.drl"/&gt;<br />        &lt;/drools:resources&gt;<br />    &lt;/drools:kbase&gt;<br /><br />    &lt;drools:ksession id="productsKSession" name="productsKSession" type="stateless" kbase="productsKBase"/&gt;<br />    &lt;alias name="productsKSession" alias="electronicKSession"/&gt;<br />    &lt;alias name="productsKSession" alias="medicalKSession"/&gt;<br /><br />&lt;/beans&gt;<br /></pre><br />Let's check the drl file.<br /><br />We define two rules - "MEDICAL rule" and "ELECTRONIC rule". For each case we are checking:<br /><br /><ul><li>whether the input object is of Product type&nbsp;</li><li>whether it has typeEnum equal to either Medical or Electronic&nbsp;</li><li>whether it hasn't already had it's productName changed&nbsp;</li></ul><br />Then we are addressing the product by means of a variable $product. We are modifying the product using the <span style="font-family: Courier New, Courier, monospace;">modify </span>keyword (which means that all the rules are rechecked - try removing the condition 'productName != replaceAWithB($product.typeEnum.someOutputString' and you will have an endless loop) by setting a new productName. Take a look at all the imports and imports of functions. You can execute a static function (pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil.replaceAWithB or org.drools.core.util.StringUtils.isEmpty) by importing it in the drl file.<br />At the end we are logging that a rule has been applied.<br /><br /><b>products.drl  </b><br /><br /><pre class="brush:xml">package pl.grzejszczak.marcin<br /><br />import org.slf4j.LoggerFactory<br />import pl.grzejszczak.marcin.drools.springintegration.DroolsSpring<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum<br /><br />import function pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil.replaceAWithB<br />import function org.drools.core.util.StringUtils.isEmpty<br /><br /><br />rule "MEDICAL rule"<br /> dialect "mvel"<br />when<br />     $product : Product( typeEnum == TypeEnum.MEDICAL, productName != replaceAWithB($product.typeEnum.someOutputString) )<br />then<br />     modify ($product) {productName = replaceAWithB($product.typeEnum.someOutputString)}<br />     LoggerFactory.getLogger(DroolsSpring.class).debug(String.format("MEDICAL rule applied, product name is now equal to [%s]", $product.productName))<br />end<br /><br />rule "ELECTRONIC rule"<br /> dialect "mvel"<br />when<br />     $product : Product( typeEnum == TypeEnum.ELECTRONIC, productName != replaceAWithB($product.typeEnum.someOutputString) )<br />then<br />     modify ($product) {productName = replaceAWithB($product.typeEnum.someOutputString)}<br />     LoggerFactory.getLogger(DroolsSpring.class).debug(String.format("ELECTRONIC rule applied, product name is now equal to [%s]", $product.productName))<br />end<br /></pre><br />We use a factory that is choosing a proper StatelessKnowledgeSession - since we only want to modify an input object. In order to run Drools rules we are running the execute method with a list of input objects.&nbsp; <br /><br /><b>ProductServiceImpl.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.drools;<br /><br />import org.drools.runtime.StatelessKnowledgeSession;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.ProductService;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("ProductServiceImpl")<br />public class ProductServiceImpl implements ProductService {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ProductServiceImpl.class);<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingFactory")<br />    ProcessingFactory&lt;StatelessKnowledgeSession, Product&gt; processingFactory;<br /><br />    @Override<br />    public void runProductLogic() {<br />        LOGGER.debug("Running product logic");<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        StatelessKnowledgeSession statelessKnowledgeSession = processingFactory.createProcessingObject(medicalProduct);<br />        LOGGER.debug("Running rules for products...");<br />        statelessKnowledgeSession.execute(newArrayList(medicalProduct, electronicProduct));<br />        LOGGER.debug("...finished running products.");<br />    }<br />}<br /><br /></pre>Now let's have a look on how the factory is implemented. We are using aliases in the applicationContext.xml<br /><br /><b>ProductProcessingFactory.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.factory.drools;<br /><br />import org.drools.runtime.StatelessKnowledgeSession;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.context.ApplicationContext;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("ProductProcessingFactory")<br />public class ProductProcessingFactory implements ProcessingFactory&lt;StatelessKnowledgeSession, Product&gt; {<br /><br />    @Autowired<br />    private ApplicationContext applicationContext;<br /><br />    @Override<br />    public StatelessKnowledgeSession createProcessingObject(Product inputObject) {<br />        return (StatelessKnowledgeSession)applicationContext.getBean(inputObject.getTypeEnum().getType() + "KSession");<br />    }<br />}<br /></pre>Now how can we test if it works? I have two unit tests that prove it (they are not running in perfect isolation but they functionality of both approaches). Starting with the test for the manual rules creation test. <br /><br /><b>NoRulesProductServiceImplTest.java </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service;<br /><br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil;<br /><br />import java.util.List;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br />import static java.lang.String.format;<br />import static org.junit.Assert.assertEquals;<br />import static org.junit.Assert.assertNotSame;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = {"classpath:applicationContext.xml"})<br />public class NoRulesProductServiceImplTest {<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingService")<br />    private Processor&lt;List&lt;Product&gt;&gt; productProcessingService;<br /><br /><br />    /**<br />     * Test is not run in perfect isolation - the purpose is to show the outcome of processing without Drools<br />     *<br />     * @throws Exception<br />     */<br />    @Test<br />    public void testRunProductLogic() throws Exception {<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        String initialMedicalProductName = medicalProduct.getProductName();<br />        String initialElectronicProduct = electronicProduct.getProductName();<br />        System.out.println(format("Initial productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Initial productName for Electronic [%s]", electronicProduct.getProductName()));<br /><br />        productProcessingService.process(newArrayList(medicalProduct, electronicProduct));<br /><br />        String finalMedicalProduct = medicalProduct.getProductName();<br />        String finalElectronicProduct = electronicProduct.getProductName();<br />        assertNotSame(finalMedicalProduct, initialMedicalProductName);<br />        assertNotSame(finalElectronicProduct, initialElectronicProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialMedicalProductName), finalMedicalProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialElectronicProduct), finalElectronicProduct);<br /><br />        System.out.println(format("Final productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Final productName for Electronic [%s]", electronicProduct.getProductName()));<br />    }<br />}<br /></pre><br />And the unit test for the Drools approach.<br /><br /><b>ProductServiceImplTest.java </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service;<br /><br />import org.drools.runtime.StatelessKnowledgeSession;<br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br />import static java.lang.String.format;<br />import static org.junit.Assert.assertEquals;<br />import static org.junit.Assert.assertNotSame;<br />import static org.junit.Assert.assertTrue;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = {"classpath:applicationContext.xml"})<br />public class ProductServiceImplTest {<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingFactory")<br />    ProcessingFactory&lt;StatelessKnowledgeSession, Product&gt; processingFactory;<br /><br />    /**<br />     * Test is not run in perfect isolation - the purpose is to show the outcome of processing with Drools<br />     * @throws Exception<br />     */<br />    @Test<br />    public void testRunProductLogic() throws Exception {<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        String initialMedicalProductName = medicalProduct.getProductName();<br />        String initialElectronicProduct = electronicProduct.getProductName();<br />        System.out.println(format("Initial productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Initial productName for Electronic [%s]", electronicProduct.getProductName()));<br /><br />        StatelessKnowledgeSession statelessKnowledgeSessionForMedical = processingFactory.createProcessingObject(medicalProduct);<br />        StatelessKnowledgeSession statelessKnowledgeSessionForElectronic = processingFactory.createProcessingObject(electronicProduct);<br />        assertTrue(statelessKnowledgeSessionForMedical == statelessKnowledgeSessionForElectronic);<br />        System.out.println("References for stateless sessions are the same, executing rules...");<br /><br />        statelessKnowledgeSessionForMedical.execute(newArrayList(medicalProduct, electronicProduct));<br /><br />        String finalMedicalProduct = medicalProduct.getProductName();<br />        String finalElectronicProduct = electronicProduct.getProductName();<br />        assertNotSame(finalMedicalProduct, initialMedicalProductName);<br />        assertNotSame(finalElectronicProduct, initialElectronicProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialMedicalProductName), finalMedicalProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialElectronicProduct), finalElectronicProduct);<br /><br />        System.out.println(format("Final productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Final productName for Electronic [%s]", electronicProduct.getProductName()));<br />    }<br />}<br /></pre>Now let's take a look at the logs - take a look that 'Executing some logic' took place 6 times for Drools since when you modify an object the rules are revalidated and rerun:  <br /><br /><pre class="brush:xml">org.springframework.context.support.ClassPathXmlApplicationContext:495 Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@743399: startup date [Tue Jan 15 16:32:30 CET 2013]; root of context hierarchy<br />org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [applicationContext.xml]<br />org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [drools-context.xml]<br />[main] org.springframework.beans.factory.support.DefaultListableBeanFactory:557 Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@3b1d04: defining beans [productsKBase,productsKSession,ProductProcessingFactory,NoRulesProcessingFactory,ProductServiceImpl,NoRulesProductServiceImpl,ProductProcessingService,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy<br />pl.grzejszczak.marcin.drools.springintegration.service.drools.ProductServiceImpl:32 Running product logic<br />pl.grzejszczak.marcin.drools.springintegration.service.drools.ProductServiceImpl:36 Running rules for products...<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.DroolsSpring:? ELECTRONIC rule applied, product name is now equal to [cccbbbbbb]<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.DroolsSpring:? MEDICAL rule applied, product name is now equal to [bbbbbbccc]<br />pl.grzejszczak.marcin.drools.springintegration.service.drools.ProductServiceImpl:38 ...finished running products.<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.NoRulesProductServiceImpl:33 Running product logic without Drools<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.NoRulesProductServiceImpl:36 Running rules for products...<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.MedicalProductProcessingService:26 Running processing for Medical Product<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.MedicalProductProcessingService:28 MEDICAL rule applied without Drools, product name is now equal to [bbbbbbccc]<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.ElectronicProductProcessingService:26 Running processing for Electronic Product<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.ElectronicProductProcessingService:28 ELECTRONIC rule applied without Drools, product name is now equal to [cccbbbbbb]<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.NoRulesProductServiceImpl:38 ...finished running products.<br /></pre><br />Viola! That's how you can write some rules with Drools that can save plenty of time and effort as far as business logic is concerned. You can find the sources here at my <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/3d8a2ef67b5b/Drools/Spring%20integration?at=default">BitBucket repository</a>.</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP in Security - Controlling Creation of UI Components via Aspects]]></title>
    <link href="https://toomuchcoding.com/blog/2012/10/27/spring-aop-in-security-controlling/"/>
    <updated>2012-10-27T18:06:00-07:00</updated>
    <id>https://toomuchcoding.com/blog/2012/10/27/spring-aop-in-security-controlling</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />The following post will show how in one of the projects that I took part in we used Spring's AOP to introduce some security related functionalities. The concept was such that in order for the user to see some UI components he needed to have a certain level of security privillages. If that requirement was not met then the UIComponent was not presented. Let's take a look at the project structure:<br />
<!--more-->
<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-SpxeeCEcyaE/UIx6drCJ6sI/AAAAAAAAAHw/ASHo5_3RQQ0/s1600/Aspects+project.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="https://3.bp.blogspot.com/-SpxeeCEcyaE/UIx6drCJ6sI/AAAAAAAAAHw/ASHo5_3RQQ0/s320/Aspects+project.png" width="254" /></a></div><br />Then there were also the <b><span style="font-family: inherit;">aopApplicationContext.xml :</span></b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="https://www.springframework.org/schema/beans"<br /> xmlns:context="https://www.springframework.org/schema/context"<br /> xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"<br /> xmlns:aop="https://www.springframework.org/schema/aop"<br /> xsi:schemaLocation="https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />        https://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context-3.0.xsd<br />        https://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx-3.0.xsd<br />        https://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util-3.1.xsd<br />        https://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;<br /><br /> &lt;aop:aspectj-autoproxy /&gt;<br /> &lt;context:annotation-config /&gt;<br /> &lt;context:component-scan base-package="pl.grzejszczak.marcin.aop"&gt;<br />  &lt;context:exclude-filter type="annotation" expression="org.aspectj.lang.annotation.Aspect"/&gt;<br /> &lt;/context:component-scan&gt;<br /> &lt;bean class="pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor" factory-method="aspectOf"/&gt; <br /><br />&lt;/beans&gt;<br /><br /></pre>Now let's take a look at the most interesting lines of the Spring's application context.<br /><br />First we have all the required schemas - I don't think that this needs to be explained in more depth.<br/> Then we have:<br /><pre class="brush:xml">&lt;aop:aspectj-autoproxy/&gt;</pre><br /><br />which enables the <b>@AspectJ</b> support.<br /><br />Next there is the<br /><br /><pre class="brush:xml">&lt;context:annotation-config /&gt;<br />&lt;context:component-scan base-package="pl.grzejszczak.marcin.aop"&gt;<br />    &lt;context:exclude-filter type="annotation" expression="org.aspectj.lang.annotation.Aspect"/&gt;<br />&lt;/context:component-scan&gt;</pre><br />first we are turning on Spring configuration via annotations. Then deliberatly we exclude aspects from being initialized as beans by Spring itself. Why? Because...<br /><br /><pre class="brush:xml">&lt;bean class="pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor" factory-method="aspectOf"/&gt;</pre><br />we want to create the aspect by ourselves and provide the <span style="font-family: 'Courier New', Courier, monospace;">factory-method="aspectOf"</span> . By doing so our aspect will be included in the autowiring process of our beans - thus all the fields annotated with the <span style="font-family: 'Courier New', Courier, monospace;">@Autowired</span> annotation will get the beans injected.<br /><br />Now let's move on to the code:<br /><br /><b>UserServiceImpl.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.service;<br /><br />import org.springframework.stereotype.Service;<br /><br />import pl.grzejszczak.marcin.aop.type.Role;<br />import pl.grzejszczak.marcin.aop.user.UserHolder;<br /><br />@Service<br />public class UserServiceImpl implements UserService {<br /> private UserHolder userHolder;<br /><br /> @Override<br /> public UserHolder getCurrentUser() {<br />  return userHolder;<br /> }<br /><br /> @Override<br /> public void setCurrentUser(UserHolder userHolder) {<br />  this.userHolder = userHolder;<br /> }<br /><br /> @Override<br /> public Role getUserRole() {<br />  if (userHolder == null) {<br />   return null;<br />  }<br />  return userHolder.getUserRole();<br /> }<br />}<br /></pre><br />The class UserServiceImpl is immitating a service that would get the current user information from the db or from the current application context.<br /><br /><b>UserHolder.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.user;<br /><br />import pl.grzejszczak.marcin.aop.type.Role;<br /><br />public class UserHolder {<br /> private Role userRole;<br /><br /> public UserHolder(Role userRole) {<br />  this.userRole = userRole;<br /> }<br /><br /> public Role getUserRole() {<br />  return userRole;<br /> }<br /><br /> public void setUserRole(Role userRole) {<br />  this.userRole = userRole;<br /> }<br />}<br /></pre><br /><br />This is a simple holder class that holds information about current user Role.<br /><br /><b>Role.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.type;<br /><br /><br />public enum Role {<br /> ADMIN("ADM"), WRITER("WRT"), GUEST("GST");<br /><br /> private String name;<br /><br /> private Role(String name) {<br />  this.name = name;<br /> }<br /><br /> public static Role getRoleByName(String name) {<br /><br />  for (Role role : Role.values()) {<br /><br />   if (role.name.equals(name)) {<br />    return role;<br />   }<br />  }<br /><br />  throw new IllegalArgumentException("No such role exists [" + name + "]");<br /> }<br /><br /> public String getName() {<br />  return this.name;<br /> }<br /><br /> @Override<br /> public String toString() {<br />  return name;<br /> }<br />}<br /></pre><br />Role is an enum that defines a role for a person being an <i>Admin</i>, <i>Writer</i> or a <i>Guest</i>.<br /><br /><b>UIComponent.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.ui;<br /><br />public abstract class UIComponent {<br /> protected String componentName;<br /><br /> protected String getComponentName() {<br />  return componentName;<br /> }<br /><br />}<br /></pre><br />An abstraction over concrete implementations of some UI components.<br /><br /><b>SomeComponentForAdminAndGuest.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.ui;<br /><br />import pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation;<br />import pl.grzejszczak.marcin.aop.type.Role;<br /><br />@SecurityAnnotation(allowedRole = { Role.ADMIN, Role.GUEST })<br />public class SomeComponentForAdminAndGuest extends UIComponent {<br /><br /> public SomeComponentForAdminAndGuest() {<br />  this.componentName = "SomeComponentForAdmin";<br /> }<br /><br /> public static UIComponent getComponent() {<br />  return new SomeComponentForAdminAndGuest();<br /> }<br />}<br /></pre><br />This component is an example of a UI component extention that can be seen only by users who have roles of <i>Admin</i> or <i>Guest</i>.<br /><br /><b>SecurityAnnotation.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.annotation;<br /><br />import java.lang.annotation.Retention;<br />import java.lang.annotation.RetentionPolicy;<br /><br />import pl.grzejszczak.marcin.aop.type.Role;<br /><br />@Retention(RetentionPolicy.RUNTIME)<br />public @interface SecurityAnnotation {<br /> Role[] allowedRole();<br />}<br /></pre><br /><br />Annotation that defines a roles that can have this component created.<br /><br /><b>UIFactoryImpl.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.ui;<br /><br />import org.apache.commons.lang.NullArgumentException;<br />import org.springframework.stereotype.Component;<br /><br />@Component<br />public class UIFactoryImpl implements UIFactory {<br /><br /> @Override<br /> public UIComponent createComponent(Class&lt;? extends UIComponent&gt; componentClass) throws Exception {<br />  if (componentClass == null) {<br />   throw new NullArgumentException("Provide class for the component");<br />  }<br />  return (UIComponent) Class.forName(componentClass.getName()).newInstance();<br /> }<br />}<br /></pre><br /><br />A factory class that given the class of an object that extends UIComponent returns a new instance of the given UIComponent.<br /><br /><b>SecurityInterceptor.java</b><br /><br /><pre class="brush:java"><br /><br />package pl.grzejszczak.marcin.aop.interceptor;<br /><br />import java.lang.annotation.Annotation;<br />import java.lang.reflect.AnnotatedElement;<br />import java.util.Arrays;<br />import java.util.List;<br /><br />import org.aspectj.lang.ProceedingJoinPoint;<br />import org.aspectj.lang.annotation.Around;<br />import org.aspectj.lang.annotation.Aspect;<br />import org.aspectj.lang.annotation.Pointcut;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br /><br />import pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation;<br />import pl.grzejszczak.marcin.aop.service.UserService;<br />import pl.grzejszczak.marcin.aop.type.Role;<br />import pl.grzejszczak.marcin.aop.ui.UIComponent;<br /><br />@Aspect<br />public class SecurityInterceptor {<br /> private static final Logger LOGGER = LoggerFactory.getLogger(SecurityInterceptor.class);<br /><br /> public SecurityInterceptor() {<br />  LOGGER.debug(&quot;Security Interceptor created&quot;);<br /> }<br /><br /> @Autowired<br /> private UserService userService;<br /><br /> @Pointcut(&quot;execution(pl.grzejszczak.marcin.aop.ui.UIComponent pl.grzejszczak.marcin.aop.ui.UIFactory.createComponent(..))&quot;)<br /> private void getComponent(ProceedingJoinPoint thisJoinPoint) {<br /> }<br /><br /> @Around(&quot;getComponent(thisJoinPoint)&quot;)<br /> public UIComponent checkSecurity(ProceedingJoinPoint thisJoinPoint) throws Throwable {<br />  LOGGER.info(&quot;Intercepting creation of a component&quot;);<br /><br />  Object[] arguments = thisJoinPoint.getArgs();<br />  if (arguments.length == 0) {<br />   return null;<br />  }<br /><br />  Annotation annotation = checkTheAnnotation(arguments);<br />  boolean securityAnnotationPresent = (annotation != null);<br /><br />  if (securityAnnotationPresent) {<br />   boolean userHasRole = verifyRole(annotation);<br />   if (!userHasRole) {<br />    LOGGER.info(&quot;Current user doesn't have permission to have this component created&quot;);<br />    return null;<br />   }<br />  }<br />  LOGGER.info(&quot;Current user has required permissions for creating a component&quot;);<br />  return (UIComponent) thisJoinPoint.proceed();<br /> }<br /><br /> /**<br />  * Basing on the method's argument check if the class is annotataed with<br />  * {@link SecurityAnnotation}<br />  * <br />  * @param arguments<br />  * @return<br />  */<br /> private Annotation checkTheAnnotation(Object[] arguments) {<br />  Object concreteClass = arguments[0];<br />  LOGGER.info(&quot;Argument's class - [{}]&quot;, new Object[] { arguments });<br />  AnnotatedElement annotatedElement = (AnnotatedElement) concreteClass;<br />  Annotation annotation = annotatedElement.getAnnotation(SecurityAnnotation.class);<br />  LOGGER.info(&quot;Annotation present - [{}]&quot;, new Object[] { annotation });<br />  return annotation;<br /> }<br /><br /> /**<br />  * The function verifies if the current user has sufficient privilages to<br />  * have the component built<br />  * <br />  * @param annotation<br />  * @return<br />  */<br /> private boolean verifyRole(Annotation annotation) {<br />  LOGGER.info(&quot;Security annotation is present so checking if the user can use it&quot;);<br />  SecurityAnnotation annotationRule = (SecurityAnnotation) annotation;<br />  List&lt;Role&gt; requiredRolesList = Arrays.asList(annotationRule.allowedRole());<br />  Role userRole = userService.getUserRole();<br />  return requiredRolesList.contains(userRole);<br /> }<br />}<br /></pre><br /><br />This is the <b>aspect</b> defined at the <b>pointcut</b> of <b>executing</b> a function <span style="font-family: 'Courier New', Courier, monospace;">createComponent</span> of the <span style="font-family: 'Courier New', Courier, monospace;">UIFactory</span> interface. Inside the <b>Around</b> <b>advice</b> there is the logic that first checks what kind of an argument has been passed to the method <span style="font-family: 'Courier New', Courier, monospace;">createComponent</span> (for example&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">SomeComponentForAdminAndGuest.class</span>). Next it is checking if this class is annotated with <span style="font-family: 'Courier New', Courier, monospace;">SecurityAnnotation</span> and if that is the case it checks what kind of <span style="font-family: 'Courier New', Courier, monospace;">Roles</span> are required to have the component created. Afterwards it checks if the current user (from <span style="font-family: 'Courier New', Courier, monospace;">UserService</span> to <span style="font-family: 'Courier New', Courier, monospace;">UserHolder's</span> <span style="font-family: 'Courier New', Courier, monospace;">Roles</span>) has the required role to present the component. If that is the case <span style="font-family: 'Courier New', Courier, monospace;">thisJoinPoint.proceed()</span> is called which in effect returns the object of the class that extends <span style="font-family: 'Courier New', Courier, monospace;">UIComponent</span>.<br /><br />Now let's test it - here comes the&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">SpringJUnit4ClassRunner</span><br /><br /><b>AopTest.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop;<br /><br />import org.junit.Assert;<br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br /><br />import pl.grzejszczak.marcin.aop.service.UserService;<br />import pl.grzejszczak.marcin.aop.type.Role;<br />import pl.grzejszczak.marcin.aop.ui.SomeComponentForAdmin;<br />import pl.grzejszczak.marcin.aop.ui.SomeComponentForAdminAndGuest;<br />import pl.grzejszczak.marcin.aop.ui.SomeComponentForGuest;<br />import pl.grzejszczak.marcin.aop.ui.SomeComponentForWriter;<br />import pl.grzejszczak.marcin.aop.ui.UIFactory;<br />import pl.grzejszczak.marcin.aop.user.UserHolder;<br /><br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = { "classpath:aopApplicationContext.xml" })<br />public class AopTest {<br /><br /> @Autowired<br /> private UIFactory uiFactory;<br /><br /> @Autowired<br /> private UserService userService;<br /><br /> @Test<br /> public void adminTest() throws Exception {<br />  userService.setCurrentUser(new UserHolder(Role.ADMIN));<br />  Assert.assertNotNull(uiFactory.createComponent(SomeComponentForAdmin.class));<br />  Assert.assertNotNull(uiFactory.createComponent(SomeComponentForAdminAndGuest.class));<br />  Assert.assertNull(uiFactory.createComponent(SomeComponentForGuest.class));<br />  Assert.assertNull(uiFactory.createComponent(SomeComponentForWriter.class));<br /> }<br />}<br /></pre><br /><br />And the logs:<br /><br /><pre class="brush:xml"><br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:26 Security Interceptor created<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:38 Intercepting creation of a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:48 Argument's class - [[class pl.grzejszczak.marcin.aop.ui.SomeComponentForAdmin]]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:54 Annotation present - [@pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation(allowedRole=[ADM])]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:57 Security annotation is present so checking if the user can use it<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:70 Current user has required permissions for creating a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:38 Intercepting creation of a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:48 Argument's class - [[class pl.grzejszczak.marcin.aop.ui.SomeComponentForAdminAndGuest]]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:54 Annotation present - [@pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation(allowedRole=[ADM, GST])]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:57 Security annotation is present so checking if the user can use it<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:70 Current user has required permissions for creating a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:38 Intercepting creation of a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:48 Argument's class - [[class pl.grzejszczak.marcin.aop.ui.SomeComponentForGuest]]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:54 Annotation present - [@pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation(allowedRole=[GST])]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:57 Security annotation is present so checking if the user can use it<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:66 Current user doesn't have permission to have this component created<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:38 Intercepting creation of a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:48 Argument's class - [[class pl.grzejszczak.marcin.aop.ui.SomeComponentForWriter]]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:54 Annotation present - [@pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation(allowedRole=[WRT])]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:57 Security annotation is present so checking if the user can use it<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:66 Current user doesn't have permission to have this component created<br /></pre><br />The unit test shows that for given Admin role only first two components get created whereas for the two others nulls are returned (due to the fact that user doesn't have proper rights).<br /><br />That is how in our project we used Spring's AOP to create a simple framework that would check if the user can have the given component created or not. Thanks to this after having programmed the aspects one doesn't have to remember about writing any security related code since it will be done for him.<br /><br />If you have any suggestions related to this post please feel free to comment it :)</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mockito InvocationOnMock - Checking an Argument]]></title>
    <link href="https://toomuchcoding.com/blog/2012/10/24/mockito-invocationonmock-checking/"/>
    <updated>2012-10-24T14:22:00-07:00</updated>
    <id>https://toomuchcoding.com/blog/2012/10/24/mockito-invocationonmock-checking</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />Hi!<br /><br />In one of my projects we had a very interesting situation in terms of testing. We couldn't mock an invocation of a static method due to the fact that PowerMock was not allowed to be used so there were plenty of objects and dependencies being initialized. What is more we were using a custom made dependency injection system that had a possibility of injecting a mock.<br />
<!--more-->
<br />The problem was such that during a test we wanted to assert whether one of the objects was in a very precise state. This object was created using the new operator so we couldn't mock it (again no PowerMock allowed). Fortunately this object got passed to a method of an object that we could mock...<br /><br />As presented below <span style="font-family: 'Courier New', Courier, monospace;">timeConsumingExternalService</span> is an object that we could mock via the custom dependency injection system whereas the <span style="font-family: 'Courier New', Courier, monospace;">SomePojo</span> class is an object whose state we would like to verify. <br /><br /><pre class="brush:java">timeConsumingExternalService.processSomeObject(new SomePojo("name", "surname", 1, 1.0));<br /></pre><br />So what we did was that in our mock to which the object got passed we created a new <span style="font-family: 'Courier New', Courier, monospace;">Answer&nbsp;</span>(the same <span style="font-family: 'Courier New', Courier, monospace;">Answer</span> that I spoke of <a href="https://toomuchcoding.blogspot.com/2012/10/simulation-of-time-consuming-actions-in.html">here</a>). Due to which we could access the <span style="font-family: 'Courier New', Courier, monospace;">InvocationOnMock</span> and the arguments passed to the method as such. <br /><br /><pre class="brush:java">Mockito.doAnswer(new Answer&lt;Object&gt;() {<br />   public Object answer(InvocationOnMock invocation) throws Throwable {<br />    Object[] object = invocation.getArguments();<br /><br />      if (object.length &gt; 0) {<br />          SomePojo somePojo = (SomePojo) object[0];<br /><br />          Assert.assertEquals("name", somePojo.getName());<br />          LOGGER.debug("Names are equal");<br />          Assert.assertEquals("surname", somePojo.getSurname());<br />          LOGGER.debug("Surnames are equal");<br />          Assert.assertTrue(1 == somePojo.getIntValue());<br />          LOGGER.debug("Ints are equal");<br />          Assert.assertTrue(1.0 == somePojo.getDoubleValue());<br />          LOGGER.debug("Doubles are equal");<br /><br />          LOGGER.debug("Object being an argument of the function [" + String.valueOf(somePojo) + "]");<br />  }<br />    return null;<br />   }<br />  }).when(timeConsumingExternalServiceMock).processSomeObject(Mockito.any(SomePojo.class));<br /></pre><br />Of course the logs regarding the equalities are unnecessary since if they wouldn't be equal we would have an assertion exception - I left them for the purpose of this post.<br /><br />And in the logs we can find: <br /><br /><pre class="brush:xml">pl.grzejszczak.marcin.ServiceIntegrationTest:48 Names are equal<br />pl.grzejszczak.marcin.ServiceIntegrationTest:50 Surnames are equal<br />pl.grzejszczak.marcin.ServiceIntegrationTest:52 Ints are equal<br />pl.grzejszczak.marcin.ServiceIntegrationTest:54 Doubles are equal<br />pl.grzejszczak.marcin.ServiceIntegrationTest:56 Object being an argument of the function [SomePojo [name=name, surname=surname, intValue=1, doubleValue=1.0]]<br /></pre><br />So in this way something that seems impossible to be verified can get verified :)<br /><br /><b><u>Update! </u></b><br /><br />Thanks to Holger's suggestion I took a look at the <span style="font-family: 'Courier New', Courier, monospace;">ArgumentCaptor</span> object and that is true that it is an elegant solution to retrieve information about the arguments executed on a method. Where <span style="font-family: 'Courier New', Courier, monospace;">InvocationOnMock</span> can give you much more information and possibilities (for instance regarding the method being executed or just execute the real method) for this particular case a much more elegant, easier and faster way of dealing with the issue would be:<br /><br /><br /><pre class="brush:java">  //service that executes the external service<br />  executorService.execute(someTask);<br /><br />  final ArgumentCaptor&lt;SomePojo&gt; argumentCaptor = ArgumentCaptor.forClass(SomePojo.class);<br />  Mockito.verify(timeConsumingExternalServiceMock).processSomeObject(argumentCaptor.capture());<br />  SomePojo somePojo = argumentCaptor.getValue();<br />  Assert.assertEquals("name", somePojo.getName());<br />  LOGGER.debug("Names are equal");<br />  Assert.assertEquals("surname", somePojo.getSurname());<br />  LOGGER.debug("Surnames are equal");<br />  Assert.assertTrue(1 == somePojo.getIntValue());<br />  LOGGER.debug("Ints are equal");<br />  Assert.assertTrue(1.0 == somePojo.getDoubleValue());<br />  LOGGER.debug("Doubles are equal");<br /></pre><br />The logs: <br /><pre class="brush:xml">pl.grzejszczak.marcin.junit.SomeTask:26 Before processing an object<br />pl.grzejszczak.marcin.junit.SomeTask:28 After processing an object<br />pl.grzejszczak.marcin.ServiceIntegrationTest:75 Names are equal<br />pl.grzejszczak.marcin.ServiceIntegrationTest:77 Surnames are equal<br />pl.grzejszczak.marcin.ServiceIntegrationTest:79 Ints are equal<br />pl.grzejszczak.marcin.ServiceIntegrationTest:81 Doubles are equal<br /></pre><br />Thanks again Holger!</div>

]]></content>
  </entry>
  
</feed>
