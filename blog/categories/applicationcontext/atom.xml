<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Applicationcontext | TOO MUCH CODING]]></title>
  <link href="http://toomuchcoding.com/blog/categories/applicationcontext/atom.xml" rel="self"/>
  <link href="http://toomuchcoding.com/"/>
  <updated>2018-05-24T01:01:17+02:00</updated>
  <id>http://toomuchcoding.com/</id>
  <author>
    <name><![CDATA[Marcin Grzejszczak]]></name>
    <email><![CDATA[blog@toomuchcoding.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Drools Integration With Spring vs Manual Rules Creation]]></title>
    <link href="http://toomuchcoding.com/blog/2013/01/15/drools-integration-with-spring-vs/"/>
    <updated>2013-01-15T08:04:00-08:00</updated>
    <id>http://toomuchcoding.com/blog/2013/01/15/drools-integration-with-spring-vs</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />Hi!<br /><br />&nbsp;Often in your work you can come across with issues related to business logic. Let us assume that you have dozens of rules (for the time being in our project we have more than 50 and I used to work on a project where we had hundreds of those rules) that you have to implement, divide into some classes, subclasses, abstractions and of course unit test. This can be difficult and timeconsuming to both write and support. There are many ways of dealing with this problem and I will show you one of them - JBoss Drools.<br />
<!--more-->
<br />Drools is a library specifically created for such purposes like implementing rules. As presented in Wikipedia:<br /><blockquote class="tr_bq">"Drools is a rule engine implementaion based on Charles Forgy's Rete Algorithm tailored for the Java language."&nbsp;</blockquote>It contains a rule engine that can process rules wirtten using the Drools language (you can also provide rules in Excel spreadsheets! - perfect for Business side to support and maintain).<br /><br />In the following example we will take a look at the way one can integrate JBoss Drools with Spring and an example of solving a similar problem without Drools.<br /><br /><br /><a name='more'></a><br /><br />Let us assume that we hava a POJO - a product that can represent either a Medical or Electronic product.&nbsp; <br /><br /><b>Product.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.model;<br /><br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />public class Product {<br />    private final TypeEnum typeEnum;<br />    private String productName;<br /><br />    public Product(TypeEnum typeEnum) {<br />        this.typeEnum = typeEnum;<br />        productName = typeEnum.getSomeOutputString();<br />    }<br /><br />    public TypeEnum getTypeEnum() {<br />        return typeEnum;<br />    }<br /><br />    public String getProductName() {<br />        return productName;<br />    }<br /><br />    public void setProductName(String productName) {<br />        this.productName = productName;<br />    }<br />}<br /><br /></pre>What defines the type of a product is the TypeEnum. It also has an outputString - let's assume that it defines a brand of a product (or whatever you want ;) )<br /><br /><b>TypeEnum.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.enums;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />public enum TypeEnum {<br />    MEDICAL("medical", "aaabbbccc"), ELECTRONIC("electronic", "cccbbbaaa");<br /><br /><br />    private final String type;<br />    private final String someOutputString;<br /><br />    private TypeEnum(String type, String someOutputString) {<br />        this.type = type;<br />        this.someOutputString = someOutputString;<br />    }<br /><br />    public String getType() {<br />        return type;<br />    }<br /><br />    public String getSomeOutputString() {<br />        return someOutputString;<br />    }<br />}<br /></pre><br />Let's say that the logic behind our rools is such that depending on the type of the enum we want to have some processing done (in our case we will have the same type of processing - converting each 'a' to 'b' in the output string).<br /><br /><b>NoRulesProductServiceImpl.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.nondrools;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br />import pl.grzejszczak.marcin.drools.springintegration.service.ProductService;<br /><br />import java.util.List;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("NoRulesProductServiceImpl")<br />public class NoRulesProductServiceImpl implements ProductService {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(NoRulesProductServiceImpl.class);<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingService")<br />    private Processor&lt;List&lt;Product&gt;&gt; productProcessingService;<br /><br />    @Override<br />    public void runProductLogic() {<br />        LOGGER.debug("Running product logic without Drools");<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        LOGGER.debug("Running rules for products...");<br />        productProcessingService.process(newArrayList(medicalProduct, electronicProduct));<br />        LOGGER.debug("...finished running products.");<br />    }<br />}<br /></pre><br />The ProductProcessingService is itterating over the given products, finds a producer for them and processes them.<br /><br /><b>ProductProcessingService.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.nondrools;<br /><br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br /><br />import java.util.List;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("ProductProcessingService")<br />public class ProductProcessingService implements Processor&lt;List&lt;Product&gt;&gt; {<br /><br />    @Autowired<br />    @Qualifier("NoRulesProcessingFactory")<br />    private ProcessingFactory&lt;Processor, Product&gt; processingFactory;<br /><br />    @Override<br />    public void process(List&lt;Product&gt; input) {<br />        for(Product product : input){<br />            Processor&lt;Product&gt; processor = processingFactory.createProcessingObject(product);<br />            processor.process(product);<br />        }<br />    }<br />}<br /></pre><br />The ProcessingFactory is an interface that basing on the given input (Product) produces an ouput (Processor) that afterwards does further processing. In our case we have a factory that instead of using a bunch of ifs (imagine that we have more than just two types of products) is using a map that matches a type of product with an implementation of a processor. As you can see we change a sequence of ifs into a single get.<br /><br /><b>NoRulesProcessingFactory.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.factory.nondrools;<br /><br />import com.google.common.collect.ImmutableMap;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.nondrools.ElectronicProductProcessingService;<br />import pl.grzejszczak.marcin.drools.springintegration.service.nondrools.MedicalProductProcessingService;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br /><br />import java.util.Map;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("NoRulesProcessingFactory")<br />public class NoRulesProcessingFactory  implements ProcessingFactory&lt;Processor, Product&gt; {<br /><br />    private static final Map&lt;TypeEnum, Processor&gt; PROCESSOR_MAP = new ImmutableMap.Builder&lt;TypeEnum, Processor&gt;().<br />            put(TypeEnum.MEDICAL, new MedicalProductProcessingService()).<br />            put(TypeEnum.ELECTRONIC, new ElectronicProductProcessingService()).<br />            build();<br /><br />    /**<br />     * By using the map we don't have any ifs<br />     * @param inputObject<br />     * @return<br />     */<br />    @Override<br />    public Processor createProcessingObject(Product inputObject) {<br />        return PROCESSOR_MAP.get(inputObject.getTypeEnum());<br />    }<br />}<br /></pre><br />I will present here only one ProcessingService since the other one is exactly the same (I just wanted to show the concept).<br /><br /><b>ElectronicProductProcessingService.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.nondrools;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br />import pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil;<br /><br />import static com.google.common.base.Preconditions.checkArgument;<br />import static java.lang.String.format;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />public class ElectronicProductProcessingService implements Processor&lt;Product&gt; {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ElectronicProductProcessingService.class);<br /><br />    @Override<br />    public void process(Product input) {<br />        checkArgument(TypeEnum.ELECTRONIC.equals(input.getTypeEnum()), "This processing service works only for electronic devices");<br />        checkArgument(!SomeUtil.replaceAWithB(input.getProductName()).equals(input.getProductName()), "The input has already been processed");<br />        LOGGER.debug("Running processing for Electronic Product");<br />        input.setProductName(SomeUtil.replaceAWithB(input.getProductName()));<br />        LOGGER.debug(format("ELECTRONIC rule applied without Drools, product name is now equal to [%s]", input.getProductName()));<br />    }<br />}<br /></pre><br />As you can see there are quite a few things that need to be tested and supported here. Imagine what would happen if we had 100 of types with more sophisticated rules than merely replacing one letter with the other.  So how can we do it with Drools? Let's start with taking a look at the pom.xml.<br /><br /><b>pom.xml  </b><br /><br /><pre class="brush:xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br /> xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br /> &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br /> &lt;groupId&gt;pl.grzejszczak.marcin&lt;/groupId&gt;<br /> &lt;artifactId&gt;drools-spring-integration&lt;/artifactId&gt;<br /> &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br /><br /> &lt;properties&gt;<br />  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;<br />  &lt;maven.compiler.source&gt;1.6&lt;/maven.compiler.source&gt;<br />  &lt;maven.compiler.target&gt;1.6&lt;/maven.compiler.target&gt;<br /><br />  &lt;spring.version&gt;3.1.1.RELEASE&lt;/spring.version&gt;<br /> &lt;/properties&gt;<br /> &lt;repositories&gt;<br />  &lt;repository&gt;<br />   &lt;id&gt;spring-release&lt;/id&gt;<br />   &lt;url&gt;http://maven.springframework.org/release&lt;/url&gt;<br />  &lt;/repository&gt;<br /> &lt;/repositories&gt;<br /><br /> &lt;dependencies&gt;<br />  &lt;!-- Spring --&gt;<br />  &lt;dependency&gt;<br />   &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />   &lt;artifactId&gt;spring-core&lt;/artifactId&gt;<br />   &lt;version&gt;${spring.version}&lt;/version&gt;<br />  &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br />            &lt;version&gt;${spring.version}&lt;/version&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;<br />            &lt;artifactId&gt;guava&lt;/artifactId&gt;<br />            &lt;version&gt;13.0.1&lt;/version&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;<br />            &lt;version&gt;${spring.version}&lt;/version&gt;<br />        &lt;/dependency&gt;<br />  &lt;dependency&gt;<br />            &lt;groupId&gt;org.drools&lt;/groupId&gt;<br />            &lt;artifactId&gt;drools-spring&lt;/artifactId&gt;<br />            &lt;version&gt;5.4.0.Final&lt;/version&gt;<br />        &lt;/dependency&gt;<br />  &lt;dependency&gt;<br />            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br />            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;<br />            &lt;version&gt;1.6.6&lt;/version&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;junit&lt;/groupId&gt;<br />            &lt;artifactId&gt;junit&lt;/artifactId&gt;<br />            &lt;version&gt;4.10&lt;/version&gt;<br />            &lt;scope&gt;test&lt;/scope&gt;<br />        &lt;/dependency&gt;<br /><br />    &lt;/dependencies&gt;<br />&lt;/project&gt;<br /><br /></pre>Let's take a look at the applicationContext.xml and the drools-context.xml. As for the first one what we do in fact is just showing where to scan for classes in terms of Spring and where to import the drools context from.<br /><br /><b>applicationContext.xml  </b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xsi:schemaLocation="http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd<br />                           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;<br /><br />    &lt;import resource="classpath:drools-context.xml"/&gt;<br />    &lt;!-- Show Spring where to search for the beans (in which packages) --&gt;<br />    &lt;context:component-scan base-package="pl.grzejszczak.marcin.drools.springintegration" /&gt;<br /><br />&lt;/beans&gt;<br /></pre><br />The context for drools. Take a look at the aliases for productsKSession. By providing alias we are joining two potential knowledge sessions into a single one. A single knowledge session is defined for a single knowledge base. For the knowledge base we are providing the list (in our case just a single resource) of drl files (we could have provided an excel spreadsheet).<br /><br /><b>drools-context.xml  </b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:drools="http://drools.org/schema/drools-spring"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />  http://drools.org/schema/drools-spring http://drools.org/schema/drools-spring.xsd"&gt;<br /><br />    &lt;!-- KNOWLEDGE BASE FOR A GIVEN TYPE --&gt;<br />    &lt;drools:kbase id="productsKBase"&gt;<br />        &lt;drools:resources&gt;<br />            &lt;drools:resource type="DRL"<br />                             source="classpath:rules/products.drl"/&gt;<br />        &lt;/drools:resources&gt;<br />    &lt;/drools:kbase&gt;<br /><br />    &lt;drools:ksession id="productsKSession" name="productsKSession" type="stateless" kbase="productsKBase"/&gt;<br />    &lt;alias name="productsKSession" alias="electronicKSession"/&gt;<br />    &lt;alias name="productsKSession" alias="medicalKSession"/&gt;<br /><br />&lt;/beans&gt;<br /></pre><br />Let's check the drl file.<br /><br />We define two rules - "MEDICAL rule" and "ELECTRONIC rule". For each case we are checking:<br /><br /><ul><li>whether the input object is of Product type&nbsp;</li><li>whether it has typeEnum equal to either Medical or Electronic&nbsp;</li><li>whether it hasn't already had it's productName changed&nbsp;</li></ul><br />Then we are addressing the product by means of a variable $product. We are modifying the product using the <span style="font-family: Courier New, Courier, monospace;">modify </span>keyword (which means that all the rules are rechecked - try removing the condition 'productName != replaceAWithB($product.typeEnum.someOutputString' and you will have an endless loop) by setting a new productName. Take a look at all the imports and imports of functions. You can execute a static function (pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil.replaceAWithB or org.drools.core.util.StringUtils.isEmpty) by importing it in the drl file.<br />At the end we are logging that a rule has been applied.<br /><br /><b>products.drl  </b><br /><br /><pre class="brush:xml">package pl.grzejszczak.marcin<br /><br />import org.slf4j.LoggerFactory<br />import pl.grzejszczak.marcin.drools.springintegration.DroolsSpring<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum<br /><br />import function pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil.replaceAWithB<br />import function org.drools.core.util.StringUtils.isEmpty<br /><br /><br />rule "MEDICAL rule"<br /> dialect "mvel"<br />when<br />     $product : Product( typeEnum == TypeEnum.MEDICAL, productName != replaceAWithB($product.typeEnum.someOutputString) )<br />then<br />     modify ($product) {productName = replaceAWithB($product.typeEnum.someOutputString)}<br />     LoggerFactory.getLogger(DroolsSpring.class).debug(String.format("MEDICAL rule applied, product name is now equal to [%s]", $product.productName))<br />end<br /><br />rule "ELECTRONIC rule"<br /> dialect "mvel"<br />when<br />     $product : Product( typeEnum == TypeEnum.ELECTRONIC, productName != replaceAWithB($product.typeEnum.someOutputString) )<br />then<br />     modify ($product) {productName = replaceAWithB($product.typeEnum.someOutputString)}<br />     LoggerFactory.getLogger(DroolsSpring.class).debug(String.format("ELECTRONIC rule applied, product name is now equal to [%s]", $product.productName))<br />end<br /></pre><br />We use a factory that is choosing a proper StatelessKnowledgeSession - since we only want to modify an input object. In order to run Drools rules we are running the execute method with a list of input objects.&nbsp; <br /><br /><b>ProductServiceImpl.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.drools;<br /><br />import org.drools.runtime.StatelessKnowledgeSession;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.ProductService;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("ProductServiceImpl")<br />public class ProductServiceImpl implements ProductService {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ProductServiceImpl.class);<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingFactory")<br />    ProcessingFactory&lt;StatelessKnowledgeSession, Product&gt; processingFactory;<br /><br />    @Override<br />    public void runProductLogic() {<br />        LOGGER.debug("Running product logic");<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        StatelessKnowledgeSession statelessKnowledgeSession = processingFactory.createProcessingObject(medicalProduct);<br />        LOGGER.debug("Running rules for products...");<br />        statelessKnowledgeSession.execute(newArrayList(medicalProduct, electronicProduct));<br />        LOGGER.debug("...finished running products.");<br />    }<br />}<br /><br /></pre>Now let's have a look on how the factory is implemented. We are using aliases in the applicationContext.xml<br /><br /><b>ProductProcessingFactory.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.factory.drools;<br /><br />import org.drools.runtime.StatelessKnowledgeSession;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.context.ApplicationContext;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("ProductProcessingFactory")<br />public class ProductProcessingFactory implements ProcessingFactory&lt;StatelessKnowledgeSession, Product&gt; {<br /><br />    @Autowired<br />    private ApplicationContext applicationContext;<br /><br />    @Override<br />    public StatelessKnowledgeSession createProcessingObject(Product inputObject) {<br />        return (StatelessKnowledgeSession)applicationContext.getBean(inputObject.getTypeEnum().getType() + "KSession");<br />    }<br />}<br /></pre>Now how can we test if it works? I have two unit tests that prove it (they are not running in perfect isolation but they functionality of both approaches). Starting with the test for the manual rules creation test. <br /><br /><b>NoRulesProductServiceImplTest.java </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service;<br /><br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil;<br /><br />import java.util.List;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br />import static java.lang.String.format;<br />import static org.junit.Assert.assertEquals;<br />import static org.junit.Assert.assertNotSame;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = {"classpath:applicationContext.xml"})<br />public class NoRulesProductServiceImplTest {<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingService")<br />    private Processor&lt;List&lt;Product&gt;&gt; productProcessingService;<br /><br /><br />    /**<br />     * Test is not run in perfect isolation - the purpose is to show the outcome of processing without Drools<br />     *<br />     * @throws Exception<br />     */<br />    @Test<br />    public void testRunProductLogic() throws Exception {<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        String initialMedicalProductName = medicalProduct.getProductName();<br />        String initialElectronicProduct = electronicProduct.getProductName();<br />        System.out.println(format("Initial productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Initial productName for Electronic [%s]", electronicProduct.getProductName()));<br /><br />        productProcessingService.process(newArrayList(medicalProduct, electronicProduct));<br /><br />        String finalMedicalProduct = medicalProduct.getProductName();<br />        String finalElectronicProduct = electronicProduct.getProductName();<br />        assertNotSame(finalMedicalProduct, initialMedicalProductName);<br />        assertNotSame(finalElectronicProduct, initialElectronicProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialMedicalProductName), finalMedicalProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialElectronicProduct), finalElectronicProduct);<br /><br />        System.out.println(format("Final productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Final productName for Electronic [%s]", electronicProduct.getProductName()));<br />    }<br />}<br /></pre><br />And the unit test for the Drools approach.<br /><br /><b>ProductServiceImplTest.java </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service;<br /><br />import org.drools.runtime.StatelessKnowledgeSession;<br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br />import static java.lang.String.format;<br />import static org.junit.Assert.assertEquals;<br />import static org.junit.Assert.assertNotSame;<br />import static org.junit.Assert.assertTrue;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = {"classpath:applicationContext.xml"})<br />public class ProductServiceImplTest {<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingFactory")<br />    ProcessingFactory&lt;StatelessKnowledgeSession, Product&gt; processingFactory;<br /><br />    /**<br />     * Test is not run in perfect isolation - the purpose is to show the outcome of processing with Drools<br />     * @throws Exception<br />     */<br />    @Test<br />    public void testRunProductLogic() throws Exception {<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        String initialMedicalProductName = medicalProduct.getProductName();<br />        String initialElectronicProduct = electronicProduct.getProductName();<br />        System.out.println(format("Initial productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Initial productName for Electronic [%s]", electronicProduct.getProductName()));<br /><br />        StatelessKnowledgeSession statelessKnowledgeSessionForMedical = processingFactory.createProcessingObject(medicalProduct);<br />        StatelessKnowledgeSession statelessKnowledgeSessionForElectronic = processingFactory.createProcessingObject(electronicProduct);<br />        assertTrue(statelessKnowledgeSessionForMedical == statelessKnowledgeSessionForElectronic);<br />        System.out.println("References for stateless sessions are the same, executing rules...");<br /><br />        statelessKnowledgeSessionForMedical.execute(newArrayList(medicalProduct, electronicProduct));<br /><br />        String finalMedicalProduct = medicalProduct.getProductName();<br />        String finalElectronicProduct = electronicProduct.getProductName();<br />        assertNotSame(finalMedicalProduct, initialMedicalProductName);<br />        assertNotSame(finalElectronicProduct, initialElectronicProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialMedicalProductName), finalMedicalProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialElectronicProduct), finalElectronicProduct);<br /><br />        System.out.println(format("Final productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Final productName for Electronic [%s]", electronicProduct.getProductName()));<br />    }<br />}<br /></pre>Now let's take a look at the logs - take a look that 'Executing some logic' took place 6 times for Drools since when you modify an object the rules are revalidated and rerun:  <br /><br /><pre class="brush:xml">org.springframework.context.support.ClassPathXmlApplicationContext:495 Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@743399: startup date [Tue Jan 15 16:32:30 CET 2013]; root of context hierarchy<br />org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [applicationContext.xml]<br />org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [drools-context.xml]<br />[main] org.springframework.beans.factory.support.DefaultListableBeanFactory:557 Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@3b1d04: defining beans [productsKBase,productsKSession,ProductProcessingFactory,NoRulesProcessingFactory,ProductServiceImpl,NoRulesProductServiceImpl,ProductProcessingService,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy<br />pl.grzejszczak.marcin.drools.springintegration.service.drools.ProductServiceImpl:32 Running product logic<br />pl.grzejszczak.marcin.drools.springintegration.service.drools.ProductServiceImpl:36 Running rules for products...<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.DroolsSpring:? ELECTRONIC rule applied, product name is now equal to [cccbbbbbb]<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.DroolsSpring:? MEDICAL rule applied, product name is now equal to [bbbbbbccc]<br />pl.grzejszczak.marcin.drools.springintegration.service.drools.ProductServiceImpl:38 ...finished running products.<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.NoRulesProductServiceImpl:33 Running product logic without Drools<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.NoRulesProductServiceImpl:36 Running rules for products...<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.MedicalProductProcessingService:26 Running processing for Medical Product<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.MedicalProductProcessingService:28 MEDICAL rule applied without Drools, product name is now equal to [bbbbbbccc]<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.ElectronicProductProcessingService:26 Running processing for Electronic Product<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.ElectronicProductProcessingService:28 ELECTRONIC rule applied without Drools, product name is now equal to [cccbbbbbb]<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.NoRulesProductServiceImpl:38 ...finished running products.<br /></pre><br />Viola! That's how you can write some rules with Drools that can save plenty of time and effort as far as business logic is concerned. You can find the sources here at my <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/3d8a2ef67b5b/Drools/Spring%20integration?at=default">BitBucket repository</a>.</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP in Security - Controlling Creation of UI Components via Aspects]]></title>
    <link href="http://toomuchcoding.com/blog/2012/10/27/spring-aop-in-security-controlling/"/>
    <updated>2012-10-27T18:06:00-07:00</updated>
    <id>http://toomuchcoding.com/blog/2012/10/27/spring-aop-in-security-controlling</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />The following post will show how in one of the projects that I took part in we used Spring's AOP to introduce some security related functionalities. The concept was such that in order for the user to see some UI components he needed to have a certain level of security privillages. If that requirement was not met then the UIComponent was not presented. Let's take a look at the project structure:<br />
<!--more-->
<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-SpxeeCEcyaE/UIx6drCJ6sI/AAAAAAAAAHw/ASHo5_3RQQ0/s1600/Aspects+project.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://3.bp.blogspot.com/-SpxeeCEcyaE/UIx6drCJ6sI/AAAAAAAAAHw/ASHo5_3RQQ0/s320/Aspects+project.png" width="254" /></a></div><br />Then there were also the <b><span style="font-family: inherit;">aopApplicationContext.xml :</span></b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br /> xmlns:context="http://www.springframework.org/schema/context"<br /> xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br /> xmlns:aop="http://www.springframework.org/schema/aop"<br /> xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd<br />        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd<br />        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.1.xsd<br />        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;<br /><br /> &lt;aop:aspectj-autoproxy /&gt;<br /> &lt;context:annotation-config /&gt;<br /> &lt;context:component-scan base-package="pl.grzejszczak.marcin.aop"&gt;<br />  &lt;context:exclude-filter type="annotation" expression="org.aspectj.lang.annotation.Aspect"/&gt;<br /> &lt;/context:component-scan&gt;<br /> &lt;bean class="pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor" factory-method="aspectOf"/&gt; <br /><br />&lt;/beans&gt;<br /><br /></pre>Now let's take a look at the most interesting lines of the Spring's application context.<br /><br />First we have all the required schemas - I don't think that this needs to be explained in more depth.<br/> Then we have:<br /><pre class="brush:xml">&lt;aop:aspectj-autoproxy/&gt;</pre><br /><br />which enables the <b>@AspectJ</b> support.<br /><br />Next there is the<br /><br /><pre class="brush:xml">&lt;context:annotation-config /&gt;<br />&lt;context:component-scan base-package="pl.grzejszczak.marcin.aop"&gt;<br />    &lt;context:exclude-filter type="annotation" expression="org.aspectj.lang.annotation.Aspect"/&gt;<br />&lt;/context:component-scan&gt;</pre><br />first we are turning on Spring configuration via annotations. Then deliberatly we exclude aspects from being initialized as beans by Spring itself. Why? Because...<br /><br /><pre class="brush:xml">&lt;bean class="pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor" factory-method="aspectOf"/&gt;</pre><br />we want to create the aspect by ourselves and provide the <span style="font-family: 'Courier New', Courier, monospace;">factory-method="aspectOf"</span> . By doing so our aspect will be included in the autowiring process of our beans - thus all the fields annotated with the <span style="font-family: 'Courier New', Courier, monospace;">@Autowired</span> annotation will get the beans injected.<br /><br />Now let's move on to the code:<br /><br /><b>UserServiceImpl.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.service;<br /><br />import org.springframework.stereotype.Service;<br /><br />import pl.grzejszczak.marcin.aop.type.Role;<br />import pl.grzejszczak.marcin.aop.user.UserHolder;<br /><br />@Service<br />public class UserServiceImpl implements UserService {<br /> private UserHolder userHolder;<br /><br /> @Override<br /> public UserHolder getCurrentUser() {<br />  return userHolder;<br /> }<br /><br /> @Override<br /> public void setCurrentUser(UserHolder userHolder) {<br />  this.userHolder = userHolder;<br /> }<br /><br /> @Override<br /> public Role getUserRole() {<br />  if (userHolder == null) {<br />   return null;<br />  }<br />  return userHolder.getUserRole();<br /> }<br />}<br /></pre><br />The class UserServiceImpl is immitating a service that would get the current user information from the db or from the current application context.<br /><br /><b>UserHolder.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.user;<br /><br />import pl.grzejszczak.marcin.aop.type.Role;<br /><br />public class UserHolder {<br /> private Role userRole;<br /><br /> public UserHolder(Role userRole) {<br />  this.userRole = userRole;<br /> }<br /><br /> public Role getUserRole() {<br />  return userRole;<br /> }<br /><br /> public void setUserRole(Role userRole) {<br />  this.userRole = userRole;<br /> }<br />}<br /></pre><br /><br />This is a simple holder class that holds information about current user Role.<br /><br /><b>Role.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.type;<br /><br /><br />public enum Role {<br /> ADMIN("ADM"), WRITER("WRT"), GUEST("GST");<br /><br /> private String name;<br /><br /> private Role(String name) {<br />  this.name = name;<br /> }<br /><br /> public static Role getRoleByName(String name) {<br /><br />  for (Role role : Role.values()) {<br /><br />   if (role.name.equals(name)) {<br />    return role;<br />   }<br />  }<br /><br />  throw new IllegalArgumentException("No such role exists [" + name + "]");<br /> }<br /><br /> public String getName() {<br />  return this.name;<br /> }<br /><br /> @Override<br /> public String toString() {<br />  return name;<br /> }<br />}<br /></pre><br />Role is an enum that defines a role for a person being an <i>Admin</i>, <i>Writer</i> or a <i>Guest</i>.<br /><br /><b>UIComponent.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.ui;<br /><br />public abstract class UIComponent {<br /> protected String componentName;<br /><br /> protected String getComponentName() {<br />  return componentName;<br /> }<br /><br />}<br /></pre><br />An abstraction over concrete implementations of some UI components.<br /><br /><b>SomeComponentForAdminAndGuest.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.ui;<br /><br />import pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation;<br />import pl.grzejszczak.marcin.aop.type.Role;<br /><br />@SecurityAnnotation(allowedRole = { Role.ADMIN, Role.GUEST })<br />public class SomeComponentForAdminAndGuest extends UIComponent {<br /><br /> public SomeComponentForAdminAndGuest() {<br />  this.componentName = "SomeComponentForAdmin";<br /> }<br /><br /> public static UIComponent getComponent() {<br />  return new SomeComponentForAdminAndGuest();<br /> }<br />}<br /></pre><br />This component is an example of a UI component extention that can be seen only by users who have roles of <i>Admin</i> or <i>Guest</i>.<br /><br /><b>SecurityAnnotation.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.annotation;<br /><br />import java.lang.annotation.Retention;<br />import java.lang.annotation.RetentionPolicy;<br /><br />import pl.grzejszczak.marcin.aop.type.Role;<br /><br />@Retention(RetentionPolicy.RUNTIME)<br />public @interface SecurityAnnotation {<br /> Role[] allowedRole();<br />}<br /></pre><br /><br />Annotation that defines a roles that can have this component created.<br /><br /><b>UIFactoryImpl.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.ui;<br /><br />import org.apache.commons.lang.NullArgumentException;<br />import org.springframework.stereotype.Component;<br /><br />@Component<br />public class UIFactoryImpl implements UIFactory {<br /><br /> @Override<br /> public UIComponent createComponent(Class&lt;? extends UIComponent&gt; componentClass) throws Exception {<br />  if (componentClass == null) {<br />   throw new NullArgumentException("Provide class for the component");<br />  }<br />  return (UIComponent) Class.forName(componentClass.getName()).newInstance();<br /> }<br />}<br /></pre><br /><br />A factory class that given the class of an object that extends UIComponent returns a new instance of the given UIComponent.<br /><br /><b>SecurityInterceptor.java</b><br /><br /><pre class="brush:java"><br /><br />package pl.grzejszczak.marcin.aop.interceptor;<br /><br />import java.lang.annotation.Annotation;<br />import java.lang.reflect.AnnotatedElement;<br />import java.util.Arrays;<br />import java.util.List;<br /><br />import org.aspectj.lang.ProceedingJoinPoint;<br />import org.aspectj.lang.annotation.Around;<br />import org.aspectj.lang.annotation.Aspect;<br />import org.aspectj.lang.annotation.Pointcut;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br /><br />import pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation;<br />import pl.grzejszczak.marcin.aop.service.UserService;<br />import pl.grzejszczak.marcin.aop.type.Role;<br />import pl.grzejszczak.marcin.aop.ui.UIComponent;<br /><br />@Aspect<br />public class SecurityInterceptor {<br /> private static final Logger LOGGER = LoggerFactory.getLogger(SecurityInterceptor.class);<br /><br /> public SecurityInterceptor() {<br />  LOGGER.debug(&quot;Security Interceptor created&quot;);<br /> }<br /><br /> @Autowired<br /> private UserService userService;<br /><br /> @Pointcut(&quot;execution(pl.grzejszczak.marcin.aop.ui.UIComponent pl.grzejszczak.marcin.aop.ui.UIFactory.createComponent(..))&quot;)<br /> private void getComponent(ProceedingJoinPoint thisJoinPoint) {<br /> }<br /><br /> @Around(&quot;getComponent(thisJoinPoint)&quot;)<br /> public UIComponent checkSecurity(ProceedingJoinPoint thisJoinPoint) throws Throwable {<br />  LOGGER.info(&quot;Intercepting creation of a component&quot;);<br /><br />  Object[] arguments = thisJoinPoint.getArgs();<br />  if (arguments.length == 0) {<br />   return null;<br />  }<br /><br />  Annotation annotation = checkTheAnnotation(arguments);<br />  boolean securityAnnotationPresent = (annotation != null);<br /><br />  if (securityAnnotationPresent) {<br />   boolean userHasRole = verifyRole(annotation);<br />   if (!userHasRole) {<br />    LOGGER.info(&quot;Current user doesn't have permission to have this component created&quot;);<br />    return null;<br />   }<br />  }<br />  LOGGER.info(&quot;Current user has required permissions for creating a component&quot;);<br />  return (UIComponent) thisJoinPoint.proceed();<br /> }<br /><br /> /**<br />  * Basing on the method's argument check if the class is annotataed with<br />  * {@link SecurityAnnotation}<br />  * <br />  * @param arguments<br />  * @return<br />  */<br /> private Annotation checkTheAnnotation(Object[] arguments) {<br />  Object concreteClass = arguments[0];<br />  LOGGER.info(&quot;Argument's class - [{}]&quot;, new Object[] { arguments });<br />  AnnotatedElement annotatedElement = (AnnotatedElement) concreteClass;<br />  Annotation annotation = annotatedElement.getAnnotation(SecurityAnnotation.class);<br />  LOGGER.info(&quot;Annotation present - [{}]&quot;, new Object[] { annotation });<br />  return annotation;<br /> }<br /><br /> /**<br />  * The function verifies if the current user has sufficient privilages to<br />  * have the component built<br />  * <br />  * @param annotation<br />  * @return<br />  */<br /> private boolean verifyRole(Annotation annotation) {<br />  LOGGER.info(&quot;Security annotation is present so checking if the user can use it&quot;);<br />  SecurityAnnotation annotationRule = (SecurityAnnotation) annotation;<br />  List&lt;Role&gt; requiredRolesList = Arrays.asList(annotationRule.allowedRole());<br />  Role userRole = userService.getUserRole();<br />  return requiredRolesList.contains(userRole);<br /> }<br />}<br /></pre><br /><br />This is the <b>aspect</b> defined at the <b>pointcut</b> of <b>executing</b> a function <span style="font-family: 'Courier New', Courier, monospace;">createComponent</span> of the <span style="font-family: 'Courier New', Courier, monospace;">UIFactory</span> interface. Inside the <b>Around</b> <b>advice</b> there is the logic that first checks what kind of an argument has been passed to the method <span style="font-family: 'Courier New', Courier, monospace;">createComponent</span> (for example&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">SomeComponentForAdminAndGuest.class</span>). Next it is checking if this class is annotated with <span style="font-family: 'Courier New', Courier, monospace;">SecurityAnnotation</span> and if that is the case it checks what kind of <span style="font-family: 'Courier New', Courier, monospace;">Roles</span> are required to have the component created. Afterwards it checks if the current user (from <span style="font-family: 'Courier New', Courier, monospace;">UserService</span> to <span style="font-family: 'Courier New', Courier, monospace;">UserHolder's</span> <span style="font-family: 'Courier New', Courier, monospace;">Roles</span>) has the required role to present the component. If that is the case <span style="font-family: 'Courier New', Courier, monospace;">thisJoinPoint.proceed()</span> is called which in effect returns the object of the class that extends <span style="font-family: 'Courier New', Courier, monospace;">UIComponent</span>.<br /><br />Now let's test it - here comes the&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">SpringJUnit4ClassRunner</span><br /><br /><b>AopTest.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop;<br /><br />import org.junit.Assert;<br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br /><br />import pl.grzejszczak.marcin.aop.service.UserService;<br />import pl.grzejszczak.marcin.aop.type.Role;<br />import pl.grzejszczak.marcin.aop.ui.SomeComponentForAdmin;<br />import pl.grzejszczak.marcin.aop.ui.SomeComponentForAdminAndGuest;<br />import pl.grzejszczak.marcin.aop.ui.SomeComponentForGuest;<br />import pl.grzejszczak.marcin.aop.ui.SomeComponentForWriter;<br />import pl.grzejszczak.marcin.aop.ui.UIFactory;<br />import pl.grzejszczak.marcin.aop.user.UserHolder;<br /><br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = { "classpath:aopApplicationContext.xml" })<br />public class AopTest {<br /><br /> @Autowired<br /> private UIFactory uiFactory;<br /><br /> @Autowired<br /> private UserService userService;<br /><br /> @Test<br /> public void adminTest() throws Exception {<br />  userService.setCurrentUser(new UserHolder(Role.ADMIN));<br />  Assert.assertNotNull(uiFactory.createComponent(SomeComponentForAdmin.class));<br />  Assert.assertNotNull(uiFactory.createComponent(SomeComponentForAdminAndGuest.class));<br />  Assert.assertNull(uiFactory.createComponent(SomeComponentForGuest.class));<br />  Assert.assertNull(uiFactory.createComponent(SomeComponentForWriter.class));<br /> }<br />}<br /></pre><br /><br />And the logs:<br /><br /><pre class="brush:xml"><br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:26 Security Interceptor created<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:38 Intercepting creation of a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:48 Argument's class - [[class pl.grzejszczak.marcin.aop.ui.SomeComponentForAdmin]]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:54 Annotation present - [@pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation(allowedRole=[ADM])]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:57 Security annotation is present so checking if the user can use it<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:70 Current user has required permissions for creating a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:38 Intercepting creation of a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:48 Argument's class - [[class pl.grzejszczak.marcin.aop.ui.SomeComponentForAdminAndGuest]]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:54 Annotation present - [@pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation(allowedRole=[ADM, GST])]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:57 Security annotation is present so checking if the user can use it<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:70 Current user has required permissions for creating a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:38 Intercepting creation of a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:48 Argument's class - [[class pl.grzejszczak.marcin.aop.ui.SomeComponentForGuest]]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:54 Annotation present - [@pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation(allowedRole=[GST])]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:57 Security annotation is present so checking if the user can use it<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:66 Current user doesn't have permission to have this component created<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:38 Intercepting creation of a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:48 Argument's class - [[class pl.grzejszczak.marcin.aop.ui.SomeComponentForWriter]]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:54 Annotation present - [@pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation(allowedRole=[WRT])]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:57 Security annotation is present so checking if the user can use it<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:66 Current user doesn't have permission to have this component created<br /></pre><br />The unit test shows that for given Admin role only first two components get created whereas for the two others nulls are returned (due to the fact that user doesn't have proper rights).<br /><br />That is how in our project we used Spring's AOP to create a simple framework that would check if the user can have the given component created or not. Thanks to this after having programmed the aspects one doesn't have to remember about writing any security related code since it will be done for him.<br /><br />If you have any suggestions related to this post please feel free to comment it :)</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring BeanPostProcessor for a Specified Type]]></title>
    <link href="http://toomuchcoding.com/blog/2012/10/22/spring-beanpostprocessor-for-specified/"/>
    <updated>2012-10-22T15:36:00-07:00</updated>
    <id>http://toomuchcoding.com/blog/2012/10/22/spring-beanpostprocessor-for-specified</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />I was recently having a discussion how can one use a BeanPostProcessor to execute some logic for a specified class.<br />
<!--more-->
<br />Looking at the Javadoc for the BeanPostProcessor one can read that:<br /><blockquote class="tr_bq"><span style="background-color: white; font-family: Arial; font-size: 13px;">Factory hook that allows for custom modification of new bean instances, e.g. checking for marker interfaces or wrapping them with proxies.</span></blockquote>So how can one create in an easy way a BeanPostProcessor for a precise type without creating a cascade of ifs or instance ofs? This is my concept of solving this problem - perhaps you know an easier one? :)<br /><br /><b>SomeService.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.postprocessor;<br /><br />public interface SomeService {<br /> void methodA();<br /><br /> void methodB();<br />}<br /></pre><br /><b>SomeServiceImpl.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.postprocessor;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br /><br />public class SomeServiceImpl implements SomeService {<br /> private static final Logger LOGGER = LoggerFactory.getLogger(SomeServiceImpl.class);<br /><br /> public SomeServiceImpl() {<br />  LOGGER.debug("SomeServiceImpl - I'm created!");<br /> }<br /><br /> private void afterInit() {<br />  LOGGER.debug("SomeServiceImpl - After init!");<br /> }<br /><br /> private void destroyMethod() {<br />  LOGGER.debug("SomeServiceImpl - Destroy Method!");<br /> }<br /><br /> @Override<br /> public void methodA() {<br />  LOGGER.debug("SomeServiceImpl - Method A executed");<br /> }<br /><br /> @Override<br /> public void methodB() {<br />  LOGGER.debug("SomeServiceImpl - Method B executed");<br /> }<br /><br />}<br /></pre><br /><b>SomeOtherService.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.postprocessor;<br /><br />public interface SomeOtherService {<br /> void methodC();<br /><br /> void methodD();<br />}<br /></pre><br /><b>SomeOtherServiceImpl.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.postprocessor;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br /><br />public class SomeOtherServiceImpl implements SomeOtherService {<br /> private static final Logger LOGGER = LoggerFactory.getLogger(SomeOtherServiceImpl.class);<br /><br /> public SomeOtherServiceImpl() {<br />  LOGGER.debug("SomeOtherServiceImpl - I'm created!");<br /> }<br /><br /> private void afterInit() {<br />  LOGGER.debug("SomeOtherServiceImpl - After init!");<br /> }<br /><br /> private void destroyMethod() {<br />  LOGGER.debug("SomeOtherServiceImpl - Destroy Method!");<br /> }<br /><br /> @Override<br /> public void methodC() {<br />  LOGGER.debug("SomeOtherServiceImpl - Method C executed");<br /> }<br /><br /> @Override<br /> public void methodD() {<br />  LOGGER.debug("SomeOtherServiceImpl - Method D executed");<br /> }<br /><br />}<br /></pre><br /><b>AbstractBeanPostProcessor.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.postprocessor;<br /><br />import org.springframework.beans.BeansException;<br />import org.springframework.beans.factory.config.BeanPostProcessor;<br /><br />public abstract class AbstractBeanPostProcessor&lt;T&gt; implements BeanPostProcessor {<br /><br /> private Class&lt;T&gt; clazz;<br /><br /> public AbstractBeanPostProcessor(Class&lt;T&gt; clazz) {<br />  this.clazz = clazz;<br /> }<br /><br /> @Override<br /> public Object postProcessAfterInitialization(Object bean, String name) throws BeansException {<br />  checkConditions();<br /><br />  if (clazz.isAssignableFrom(bean.getClass())) {<br />   doAfter();<br />  }<br />  return bean;<br /> }<br /><br /> @Override<br /> public Object postProcessBeforeInitialization(Object bean, String name) throws BeansException {<br />  checkConditions();<br /><br />  if (clazz.isAssignableFrom(bean.getClass())) {<br />   doBefore();<br />  }<br />  return bean;<br /> }<br /><br /> private void checkConditions() {<br />  if (clazz == null) {<br />   throw new NullArgumentException("Provide the interface for the post processor");<br />  }<br /> }<br /><br /> public abstract void doBefore();<br /><br /> public abstract void doAfter();<br /><br />}<br /></pre><br /><b>SomeServicePostProcessor.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.postprocessor;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.stereotype.Component;<br /><br />@Component<br />public class SomeServicePostProcessor extends AbstractBeanPostProcessor&lt;SomeService&gt; {<br /><br /> private static final Logger LOGGER = LoggerFactory.getLogger(SomeServicePostProcessor.class);<br /><br /> public SomeServicePostProcessor() {<br />  super(SomeService.class);<br /> }<br /><br /> @Override<br /> public void doBefore() {<br />  LOGGER.info("BEFORE it's init method has been executed but AFTER SomeServiceImpl has been instantiated I would like to do sth...");<br /> }<br /><br /> @Override<br /> public void doAfter() {<br />  LOGGER.info("AFTER SomeServiceImpl has executed its init method I would like to do sth more...");<br /> }<br />}<br /></pre><br /><b>SpringMain.java</b><br /><b><br /></b><br /><pre class="brush:java">package pl.grzejszczak.marcin.postprocessor;<br /><br />import org.springframework.context.ConfigurableApplicationContext;<br />import org.springframework.context.support.ClassPathXmlApplicationContext;<br /><br />public class SpringMain {<br /><br /> public static void main(String[] args) {<br />  ConfigurableApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");<br />  SomeService someService = context.getBean(SomeService.class);<br />  someService.methodA();<br />  someService.methodB();<br />  SomeOtherService someOtherService = context.getBean(SomeOtherService.class);<br />  someOtherService.methodC();<br />  someOtherService.methodD();<br />  context.close();<br /> }<br />}<br /></pre><br /><br /><b>ApplicationContext.xml</b><br /><br /><pre class="brush:xml"><beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"><br /><br /> &lt;bean class="pl.grzejszczak.marcin.postprocessor.SomeServiceImpl" destroy-method="destroyMethod" init-method="afterInit"/&gt;<br /> &lt;bean class="pl.grzejszczak.marcin.postprocessor.SomeOtherServiceImpl" destroy-method="destroyMethod" init-method="afterInit"/&gt;<br /> &lt;bean class="pl.grzejszczak.marcin.postprocessor.SomeServicePostProcessor"/&gt;<br /></beans><br /></pre><br /><b>Logs</b><br /><br /><pre class="brush:xml">2012-10-23 00:20:38,863 INFO  [main] org.springframework.context.support.ClassPathXmlApplicationContext:495 Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@28d11816: startup date [Tue Oct 23 00:20:38 CEST 2012]; root of context hierarchy<br />2012-10-23 00:20:38,956 INFO  [main] org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [applicationContext.xml]<br />2012-10-23 00:20:39,213 INFO  [main] org.springframework.beans.factory.support.DefaultListableBeanFactory:557 Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@6bb4469: defining beans [pl.grzejszczak.marcin.postprocessor.SomeServiceImpl#0,pl.grzejszczak.marcin.postprocessor.SomeOtherServiceImpl#0,pl.grzejszczak.marcin.postprocessor.SomeServicePostProcessor#0]; root of factory hierarchy<br />2012-10-23 00:20:39,214 DEBUG [main] pl.grzejszczak.marcin.postprocessor.SomeServiceImpl:10 SomeServiceImpl - I'm created!<br />2012-10-23 00:20:39,215 INFO  [main] pl.grzejszczak.marcin.postprocessor.SomeServicePostProcessor:18 BEFORE its init method has been executed but AFTER SomeServiceImpl has been instantiated I would like to do sth...<br />2012-10-23 00:20:39,216 DEBUG [main] pl.grzejszczak.marcin.postprocessor.SomeServiceImpl:14 SomeServiceImpl - After init!<br />2012-10-23 00:20:39,216 INFO  [main] pl.grzejszczak.marcin.postprocessor.SomeServicePostProcessor:23 AFTER SomeServiceImpl has executed its init method I would like to do sth more...<br />2012-10-23 00:20:39,220 DEBUG [main] pl.grzejszczak.marcin.postprocessor.SomeOtherServiceImpl:10 SomeOtherServiceImpl - I'm created!<br />2012-10-23 00:20:39,221 DEBUG [main] pl.grzejszczak.marcin.postprocessor.SomeOtherServiceImpl:14 SomeOtherServiceImpl - After init!<br />2012-10-23 00:20:39,225 DEBUG [main] pl.grzejszczak.marcin.postprocessor.SomeServiceImpl:23 SomeServiceImpl - Method A executed<br />2012-10-23 00:20:39,241 DEBUG [main] pl.grzejszczak.marcin.postprocessor.SomeServiceImpl:28 SomeServiceImpl - Method B executed<br />2012-10-23 00:20:39,242 DEBUG [main] pl.grzejszczak.marcin.postprocessor.SomeOtherServiceImpl:23 SomeOtherServiceImpl - Method C executed<br />2012-10-23 00:20:39,242 DEBUG [main] pl.grzejszczak.marcin.postprocessor.SomeOtherServiceImpl:28 SomeOtherServiceImpl - Method D executed<br />2012-10-23 00:20:39,242 INFO  [main] org.springframework.context.support.ClassPathXmlApplicationContext:1020 Closing org.springframework.context.support.ClassPathXmlApplicationContext@28d11816: startup date [Tue Oct 23 00:20:38 CEST 2012]; root of context hierarchy<br />2012-10-23 00:20:39,243 INFO  [main] org.springframework.beans.factory.support.DefaultListableBeanFactory:433 Destroying singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@6bb4469: defining beans [pl.grzejszczak.marcin.postprocessor.SomeServiceImpl#0,pl.grzejszczak.marcin.postprocessor.SomeOtherServiceImpl#0,pl.grzejszczak.marcin.postprocessor.SomeServicePostProcessor#0]; root of factory hierarchy<br />2012-10-23 00:20:39,244 DEBUG [main] pl.grzejszczak.marcin.postprocessor.SomeOtherServiceImpl:18 SomeOtherServiceImpl - Destroy Method!<br />2012-10-23 00:20:39,245 DEBUG [main] pl.grzejszczak.marcin.postprocessor.SomeServiceImpl:18 SomeServiceImpl - Destroy Method!<br /></pre>As you can see it is quite easy, using generics and the BeanPostProcessor, to specify certain behavors for a given type (generics and constructor of SomeServiceImpl) or a group of types of classes (generics and constructor of SomeService).</div>

]]></content>
  </entry>
  
</feed>
