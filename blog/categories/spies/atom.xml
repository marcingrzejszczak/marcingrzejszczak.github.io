<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: spies | TOO MUCH CODING]]></title>
  <link href="http://toomuchcoding.com/blog/categories/spies/atom.xml" rel="self"/>
  <link href="http://toomuchcoding.com/"/>
  <updated>2016-03-11T22:48:55+01:00</updated>
  <id>http://toomuchcoding.com/</id>
  <author>
    <name><![CDATA[Marcin Grzejszczak]]></name>
    <email><![CDATA[blog@toomuchcoding.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Injecting Test Doubles in Spring using Mockito and BeanPostProcessors]]></title>
    <link href="http://toomuchcoding.com/blog/2013/08/09/injecting-test-doubles-in-spring-using/"/>
    <updated>2013-08-09T14:39:00+02:00</updated>
    <id>http://toomuchcoding.com/blog/2013/08/09/injecting-test-doubles-in-spring-using</id>
    <content type="html"><![CDATA[<div class='post'>
<br />I'm pretty sure that if you have ever used Spring and are familliar with unit testing, you have encountered a problem related to injecting mocks / spies (Test Doubles) in the Spring's application context which you wouldn't want to modify. This article presents an approach how to solve this issue using Spring's components.<br />
<!--more-->
<br /><a name='more'></a><h2>Project structure</h2>Let's start with the project structure:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-24owAXPWDec/UgS1olJ038I/AAAAAAAABlA/O90115z1yIk/s1600/Project+structure.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://1.bp.blogspot.com/-24owAXPWDec/UgS1olJ038I/AAAAAAAABlA/O90115z1yIk/s320/Project+structure.jpg" width="207" /></a></div><br />As usual to present a problem I'm trying to show a very simple project structure. The approach that I'm about to show could show more benefits if I made the problem more extensive as we had in our project:<br /><br /><ul><li>we had dozens of interfaces and implementations autowired to lists</li><li>we wanted to perform some functional tests basing on the existing Spring application context&nbsp;</li><li>we wanted to verify that for certain input conditions some specific implementation would have their methods executed&nbsp;</li><li>we wanted to stub database access.</li></ul><br />In this example we have a <span style="font-family: Courier New, Courier, monospace;">PlayerService</span> that gets a <span style="font-family: Courier New, Courier, monospace;">Player </span>using a <span style="font-family: Courier New, Courier, monospace;">PlayerWebService</span>. We have an applicationContext that simply defines packages for autowiring:<br /><br /><b>applicationContext.xml</b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;<br /><br />    &lt;context:component-scan base-package="com.blogspot.toomuchcoding"/&gt;<br /><br />&lt;/beans&gt;<br /><br /></pre>Then we have our very simple model:<br /><br /><b>Player.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.model;<br /><br />import java.math.BigDecimal;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 08.08.13<br /> * Time: 14:38<br /> */<br />public final class Player {<br />    private final String playerName;<br />    private final BigDecimal playerValue;<br /><br />    public Player(final String playerName, final BigDecimal playerValue) {<br />        this.playerName = playerName;<br />        this.playerValue = playerValue;<br />    }<br /><br />    public String getPlayerName() {<br />        return playerName;<br />    }<br /><br />    public BigDecimal getPlayerValue() {<br />        return playerValue;<br />    }<br />}<br /><br /></pre><br />the implementation of the <span style="font-family: Courier New, Courier, monospace;">PlayerService </span>that uses <span style="font-family: Courier New, Courier, monospace;">PlayerWebService </span>to retrieve data regarding the <span style="font-family: Courier New, Courier, monospace;">Player</span>:<br /><br /><b>PlayerServiceImpl.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.service;<br /><br />import com.blogspot.toomuchcoding.model.Player;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.stereotype.Service;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 08.06.13<br /> * Time: 19:02<br /> */<br />@Service<br />public class PlayerServiceImpl implements PlayerService {<br />    private static final Logger LOGGER = LoggerFactory.getLogger(PlayerServiceImpl.class);<br /><br />    @Autowired<br />    private PlayerWebService playerWebService;<br /><br />    @Override<br />    public Player getPlayerByName(String playerName) {<br />        LOGGER.debug(String.format("Logging the player web service name [%s]", playerWebService.getWebServiceName()));<br />        return playerWebService.getPlayerByName(playerName);<br />    }<br /><br />    public PlayerWebService getPlayerWebService() {<br />        return playerWebService;<br />    }<br /><br />    public void setPlayerWebService(PlayerWebService playerWebService) {<br />        this.playerWebService = playerWebService;<br />    }<br />}<br /><br /></pre><br />the implementation of the PlayerWebService that is a provider of data (in this scenario we are simulating awaiting for response):<br /><br /><b>PlayerWebServiceImpl.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.service;<br /><br />import com.blogspot.toomuchcoding.model.Player;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.stereotype.Service;<br /><br />import java.math.BigDecimal;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 08.08.13<br /> * Time: 14:48<br /> */<br />@Service<br />public class PlayerWebServiceImpl implements PlayerWebService {<br />    private static final Logger LOGGER = LoggerFactory.getLogger(PlayerWebServiceImpl.class);<br />    public static final String WEB_SERVICE_NAME = "SuperPlayerWebService";<br />    public static final String SAMPLE_PLAYER_VALUE = "1000";<br /><br />    @Override<br />    public String getWebServiceName() {<br />        return WEB_SERVICE_NAME;<br />    }<br /><br />    @Override<br />    public Player getPlayerByName(String name) {<br />        try {<br />            LOGGER.debug("Simulating awaiting time for a response from a web service");<br />            Thread.sleep(5000);<br />        } catch (InterruptedException e) {<br />            LOGGER.error(String.format("[%s] occurred while trying to make the thread sleep", e));<br />        }<br />        return new Player(name, new BigDecimal(SAMPLE_PLAYER_VALUE));<br />    }<br />}<br /><br /></pre>Perhaps the project structure and the methods are not one of the most brilliant you have ever seen but I wanted to keep it simple to present the problem ;)<br /><br /><h2>The problem</h2>So what actually is the problem? Let us assume that we want our autowired <span style="font-family: Courier New, Courier, monospace;">PlayerWebServiceImpl</span> to be a Spy that we can verify. What is more you don't want to actually change anything in the <span style="font-family: Courier New, Courier, monospace;">applicationContext.xml</span> - you want to use the current version of the Spring context.<br /><br />With mocks it's easier since you can define in your XML file (using Mockito factory method) your bean as a mock to override the original implementation just like this:<br /><br /><pre class="brush:xml">    &lt;bean id="playerWebServiceImpl" class="org.mockito.Mockito" factory-method="mock"&gt;<br />        &lt;constructor-arg value="com.blogspot.toomuchcoding.service.PlayerWebServiceImpl"/&gt;<br />    &lt;/bean&gt;<br /></pre><br />What about the Spy? It's more problematic since in order to create a Spy you need an already existing object of the given type. In our example we have some autowiring going on so we would have to first create a spring bean of the <span style="font-family: Courier New, Courier, monospace;">PlayerWebService </span>type (Spring would have to wire all its dependencies) and then wrap it around with<span style="font-family: Courier New, Courier, monospace;"> Mockito.spy(...)</span> and only then would it have to be wired somewhere else... It's getting very complicatied doesn't it?<br /><h2>The solution</h2>You can see that the problem is not that trivial to be solved. An easy way to fix it however is to use native Spring mechanisms - BeanPostProcessors. You can check my article about how to create a <a href="http://toomuchcoding.blogspot.com/2012/10/spring-beanpostprocessor-for-specified.html">Spring BeanPostProcessor for a specified type</a>&nbsp;- we'll be using it in this example.<br /><br />Let's start with checking the test class:<br /><br /><b>PlayerServiceImplTest.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.service;<br /><br />import com.blogspot.toomuchcoding.model.Player;<br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br /><br />import java.math.BigDecimal;<br /><br />import static org.hamcrest.CoreMatchers.is;<br />import static org.junit.Assert.assertThat;<br />import static org.mockito.BDDMockito.doReturn;<br />import static org.mockito.Mockito.verify;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 08.06.13<br /> * Time: 19:26<br /> */<br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration("classpath:testApplicationContext.xml")<br />public class PlayerServiceImplTest {<br /><br />    public static final String PLAYER_NAME = "Lewandowski";<br />    public static final BigDecimal PLAYER_VALUE = new BigDecimal("35000000");<br /><br />    @Autowired<br />    PlayerWebService playerWebServiceSpy;<br /><br />    @Autowired<br />    PlayerService objectUnderTest;<br /><br />    @Test<br />    public void shouldReturnAPlayerFromPlayerWebService(){<br />        //given<br />        Player referencePlayer = new Player(PLAYER_NAME, PLAYER_VALUE);<br />        doReturn(referencePlayer).when(playerWebServiceSpy).getPlayerByName(PLAYER_NAME);<br /><br />        //when<br />        Player player = objectUnderTest.getPlayerByName(PLAYER_NAME);<br /><br />        //then<br />        assertThat(player, is(referencePlayer));<br />        verify(playerWebServiceSpy).getWebServiceName();<br />        assertThat(playerWebServiceSpy.getWebServiceName(), is(PlayerWebServiceImpl.WEB_SERVICE_NAME));<br />    }<br /><br /><br />}<br /><br /></pre>In this test we want to mock retrieval of <span style="font-family: Courier New, Courier, monospace;">Player </span>from the <span style="font-family: Courier New, Courier, monospace;">PlayerWebService </span>(let's assume that normally it would try to send a request to the outside world - and we wouldn't want that to happen in our scenario) and test that our <span style="font-family: Courier New, Courier, monospace;">PlayerService </span>returns the <span style="font-family: Courier New, Courier, monospace;">Player </span>that we provided in the method stub and what is more we want to perform verification on the Spy that the method <span style="font-family: Courier New, Courier, monospace;">getWebServiceName()</span> has been executed and that it has a very precisely defined return value. In other words we wanted to stub the method <span style="font-family: Courier New, Courier, monospace;">getPlayerByName(...)</span> and wanted to perform verification of the spy by checking the&nbsp;<span style="font-family: Courier New, Courier, monospace;">getWebServiceName()</span><span style="font-family: inherit;">method.</span><br /><br />Let's check the test context:<br /><br /><b>testApplicationContext.xml</b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;<br /><br />    &lt;import resource="applicationContext.xml"/&gt;<br />    &lt;bean class="com.blogspot.postprocessor.PlayerWebServicePostProcessor" /&gt;<br />&lt;/beans&gt;<br /></pre><br />The test context is very small since it's importing the current <span style="font-family: Courier New, Courier, monospace;">applicationContext.xml</span> and creating a Bean that is the key feature in this example - the <span style="font-family: Courier New, Courier, monospace;">BeanPostProcessor</span>:<br /><br /><b>PlayerWebServicePostProcessor.java</b><br /><br /><pre class="brush:java">package com.blogspot.postprocessor;<br /><br /><br />import com.blogspot.toomuchcoding.processor.AbstractBeanPostProcessor;<br />import com.blogspot.toomuchcoding.service.PlayerWebService;<br /><br />import static org.mockito.Mockito.spy;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 07.05.13<br /> * Time: 11:30<br /> */<br />public class PlayerWebServicePostProcessor extends AbstractBeanPostProcessor&lt;PlayerWebService&gt; {<br />    public PlayerWebServicePostProcessor() {<br />        super(PlayerWebService.class);<br />    }<br /><br />    @Override<br />    public PlayerWebService doBefore(PlayerWebService bean) {<br />        return spy(bean);<br />    }<br /><br />    @Override<br />    public PlayerWebService doAfter(PlayerWebService bean) {<br />        return bean;<br />    }<br />}<br /><br /></pre>The class is extending the <span style="font-family: Courier New, Courier, monospace;">AbstractBeanPostProcessor </span>that implements the <a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html">BeanPostProcessor </a>interface. The logic behind this class is to register the Class for which one wants to perform some actions either before initialization (<a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html#postProcessBeforeInitialization(java.lang.Object, java.lang.String)">postProcessBeforeInitialization</a>) or after initialization of the bean (<a href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html#postProcessAfterInitialization(java.lang.Object, java.lang.String)">postProcessAfterInitialization</a>). The AbstractBeanPostProcessor is well explained in my post&nbsp;<a href="http://toomuchcoding.blogspot.com/2012/10/spring-beanpostprocessor-for-specified.html">Spring BeanPostProcessor for a specified type</a>&nbsp;but there is one slight change - in my old post we were allowed by the abstraction to perform some actions on the bean without the possibility of returning a wrapper or a proxy on the bean.<br /><br />As you can see in the case of <span style="font-family: Courier New, Courier, monospace;">PlayerWebServicePostProcessor</span>&nbsp;before initialization we are creating a Spy using <span style="font-family: Courier New, Courier, monospace;">Mockito.spy(...)</span> method. In this way we create a factory hook on the intialization of beans of given type - it's as simple as that. This method will be executed for all the classes that implement the <span style="font-family: Courier New, Courier, monospace;">PlayerWebService&nbsp;</span>interface.<br /><h2>Other possibilities</h2><div>While checking out current solutions to this problem I have encountered the <a href="https://bitbucket.org/kubek2k/springockito/wiki/Home">Springockito library</a>&nbsp;by Jakub Janczak.</div><div><br /></div><div>I haven't been using this so I don't know what are (if there are any ;) ) production issues related to this library but it seems really nice and intuitive - great job Jakub! Still, you become dependent on the external library whereas in this example I've shown how to deal with the issue using Spring.</div><h2>Summary</h2><div>In this post I've shown how to</div><div><ul><li>create mocks for existing beans using XML Spring configuration</li><li>create a BeanPostProcessor implementation that performs logic for a given class of beans</li><li>return Spy (you could also return a Mock) for the given class of bean</li></ul></div><div>Now let's move through the Prons and Cons of my approach:</div><div><b><br /></b></div><div><b>Advantages</b></div><div><ul><li>you use Spring native mechanism to create Test Doubles for your beans</li><li>you are not required to add any additional external dependencies</li><li>if you use the <span style="font-family: Courier New, Courier, monospace;">AbstractBeanPostProcessor</span> you have very little changes to implement</li></ul></div><div><b>Disadvantages</b></div><div><ul><li>you have to be familliar with internal Spring architecture (that it uses BeanPostProcessors) - but is it a disadvantage? ;) - in fact if you use the&nbsp;<span style="font-family: Courier New, Courier, monospace;">AbstractBeanPostProcessor</span>&nbsp;&nbsp;you don't have to be familliar with it - you just have to provide the class type and actions to happen before and after initialization.</li><li>it's less intuitive than annotations like in&nbsp;the&nbsp;<a href="https://bitbucket.org/kubek2k/springockito/wiki/Home">Springockito library</a></li></ul></div><h2>Sources</h2>The sources are available at <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/0e7f9ad4eb4c1d2500562c3634253e26fc1e3a0e/Unit%20Testing/Mockito%20-%20Injecting%20Test%20Doubles%20in%20Spring?at=default">TooMuchCoding BitBucket repository</a> and <a href="https://github.com/marcingrzejszczak/too-much-coding/tree/master/Unit%20Testing/Mockito%20-%20Injecting%20Test%20Doubles%20in%20Spring">TooMuchCoding Github repository</a>.<br /><br /></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spock - return nested spies / mocks]]></title>
    <link href="http://toomuchcoding.com/blog/2013/08/06/spock-return-nested-spies-mocks/"/>
    <updated>2013-08-06T13:24:00+02:00</updated>
    <id>http://toomuchcoding.com/blog/2013/08/06/spock-return-nested-spies-mocks</id>
    <content type="html"><![CDATA[<div class='post'>
<br />Hi! Some time ago I have written an article about Mockito and using <a href="http://toomuchcoding.blogspot.com/2013/06/mockito-returndeepstubs-for-jaxb.html">RETURNS_DEEP_STUBS when working with JAXB</a>. Quite recently we have faced a similliar issue with deeply nesetd JAXB and the awesome testing framework written in Groovy called&nbsp;<a href="https://code.google.com/p/spock/">Spock</a>. Natively Spock does not support creating deep stubs or spies so we needed to create a workaround for it and this article will show you how to do it.<br />
<!--more-->
<br /><a name='more'></a><h2>Project structure</h2>We will be working on the same data structure as in the&nbsp;<a href="http://toomuchcoding.blogspot.com/2013/06/mockito-returndeepstubs-for-jaxb.html">RETURNS_DEEP_STUBS when working with JAXB</a>&nbsp;article so the project structure will be quite simillar:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-3AoyOo8WYuY/UgC3QJ5TuNI/AAAAAAAABkw/YJzt5EXB10s/s1600/Spock+Deep+Stubs+project+structure.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://4.bp.blogspot.com/-3AoyOo8WYuY/UgC3QJ5TuNI/AAAAAAAABkw/YJzt5EXB10s/s320/Spock+Deep+Stubs+project+structure.jpg" width="191" /></a></div><br />As you can see the main difference is such that the tests are present in the<span style="font-family: Courier New, Courier, monospace;"> /test/groovy/</span> folder instead of <span style="font-family: Courier New, Courier, monospace;">/test/java/</span> folder.<br /><h2>Extended Spock Specification</h2>In order to use Spock as a testing framework you have to create Groovy test scripts that extend the Spock Specification class. The details of how to use Spock are available <a href="https://code.google.com/p/spock/wiki/SpockBasics">here</a>. In this project I have created an abstract class that extends Specification and adds two additional methods for creating nested Test Doubles (I don't remember if I haven't seen a prototype of this approach somewhere on the internet).<br /><br /><b>ExtendedSpockSpecification.groovy</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.spock;<br /><br />import spock.lang.Specification<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: MGrzejszczak<br /> * Date: 14.06.13<br /> * Time: 15:26<br /> */<br />abstract class ExtendedSpockSpecification extends Specification {<br />    /**<br />     * The method creates nested structure of spies for all the elements present in the property parameter. Those spies are set on the input object.<br />     *<br />     * @param object - object on which you want to create nested spies<br />     * @param property - field accessors delimited by a dot - JavaBean convention<br />     * @return Spy of the last object from the property path<br />     */<br />    protected def createNestedSpies(object, String property) {<br />        def lastObject = object<br />        property.tokenize('.').inject object, { obj, prop -&gt;<br />            if (obj[prop] == null) {<br />                def foundProp = obj.metaClass.properties.find { it.name == prop }<br />                obj[prop] = Spy(foundProp.type)<br />            }<br />            lastObject = obj[prop]<br />        }<br />        lastObject<br />    }<br /><br />    /**<br />     * The method creates nested structure of mocks for all the elements present in the property parameter. Those mocks are set on the input object.<br />     *<br />     * @param object - object on which you want to create nested mocks<br />     * @param property - field accessors delimited by a dot - JavaBean convention<br />     * @return Mock of the last object from the property path<br />     */<br />    protected def createNestedMocks(object, String property) {<br />        def lastObject = object<br />        property.tokenize('.').inject object, { obj, prop -&gt;<br />            def foundProp = obj.metaClass.properties.find { it.name == prop }<br />            def mockedProp = Mock(foundProp.type)<br />            lastObject."${prop}" &gt;&gt; mockedProp<br />            lastObject = mockedProp<br />        }<br />        lastObject<br />    }<br />}<br /><br /></pre>These two methods work in a very simillar manner.<br /><ul><li>Assuming that the&nbsp;method's argument&nbsp;<span style="font-family: Courier New, Courier, monospace;">property </span>&nbsp;looks as follows: <span style="font-family: Courier New, Courier, monospace;">"a.b.c.d"</span> then the methods tokenize the string by <span style="font-family: Courier New, Courier, monospace;">"."</span> and iterate over the array - <span style="font-family: Courier New, Courier, monospace;">["a","b","c","d"]</span>.&nbsp;</li><li>We then iterate over the properties of the <a href="http://groovy.codehaus.org/api/groovy/lang/MetaClass.html">Meta Class</a>&nbsp;to find the one whose name is equal to <span style="font-family: Courier New, Courier, monospace;">prop</span> (for example<span style="font-family: Courier New, Courier, monospace;"> "a"</span>).&nbsp;</li><li>If that is the case we then use Spock's Mock/Spy method to create a Test Double of a given class (type).&nbsp;</li><li>Finally we have to bind the mocked nested element to its parent.&nbsp;</li><ul><li>For the Spy it's easy since we set the value on the parent (<span style="font-family: Courier New, Courier, monospace;">lastObject = obj[prop]</span>).&nbsp;</li><li>For the mocks however we need to use the overloaded <span style="font-family: Courier New, Courier, monospace;">&gt;&gt;</span> operator to record the behavior for our mock - that's why dynamically call the property that is present in the <span style="font-family: Courier New, Courier, monospace;">prop</span> variable (<span style="font-family: Courier New, Courier, monospace;">lastObject."${prop}" &gt;&gt; mockedProp</span>).&nbsp;</li></ul><li>Then we return from the closure the mocked/spied instance and we repeat the process for it</li></ul><div><h2>Class to be tested</h2>Let's take a look at the class to be tested:<br /><br /><b>PlayerServiceImpl.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.service;<br /><br />import com.blogspot.toomuchcoding.model.PlayerDetails;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 08.06.13<br /> * Time: 19:02<br /> */<br />public class PlayerServiceImpl implements PlayerService {<br />    @Override<br />    public boolean isPlayerOfGivenCountry(PlayerDetails playerDetails, String country) {<br />        String countryValue = playerDetails.getClubDetails().getCountry().getCountryCode().getCountryCode().value();<br />        return countryValue.equalsIgnoreCase(country);<br />    }<br />}<br /></pre><h2>The test class</h2>And now the test class:<br /><br /><b>PlayerServiceImplWrittenUsingSpockTest.groovy</b></div><div></div><br /><pre class="brush:java">package com.blogspot.toomuchcoding.service<br /><br />import com.blogspot.toomuchcoding.model.*<br />import com.blogspot.toomuchcoding.spock.ExtendedSpockSpecification<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 14.06.13<br /> * Time: 16:06<br /> */<br />class PlayerServiceImplWrittenUsingSpockTest extends ExtendedSpockSpecification {<br /><br />    public static final String COUNTRY_CODE_ENG = "ENG";<br /><br />    PlayerServiceImpl objectUnderTest<br /><br />    def setup(){<br />        objectUnderTest = new PlayerServiceImpl()<br />    }<br /><br />    def "should return true if country code is the same when creating nested structures using groovy"() {<br />        given:<br />            PlayerDetails playerDetails = new PlayerDetails(<br />                    clubDetails: new ClubDetails(<br />                            country: new CountryDetails(<br />                                    countryCode: new CountryCodeDetails(<br />                                            countryCode: CountryCodeType.ENG<br />                                    )<br />                            )<br />                    )<br />            )<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /><br />    def "should return true if country code is the same when creating nested structures using spock mocks - requires CGLIB for non interface types"() {<br />        given:<br />            PlayerDetails playerDetails = Mock()<br />            ClubDetails clubDetails = Mock()<br />            CountryDetails countryDetails = Mock()<br />            CountryCodeDetails countryCodeDetails = Mock()<br />            countryCodeDetails.countryCode &gt;&gt; CountryCodeType.ENG<br />            countryDetails.countryCode &gt;&gt; countryCodeDetails<br />            clubDetails.country &gt;&gt; countryDetails<br />            playerDetails.clubDetails &gt;&gt; clubDetails<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /><br /><br />    def "should return true if country code is the same using ExtendedSpockSpecification's createNestedMocks"() {<br />        given:<br />            PlayerDetails playerDetails = Mock()<br />            CountryCodeDetails countryCodeDetails = createNestedMocks(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode &gt;&gt; CountryCodeType.ENG<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /><br />    def "should return false if country code is not the same using ExtendedSpockSpecification createNestedMocks"() {<br />        given:<br />            PlayerDetails playerDetails = Mock()<br />            CountryCodeDetails countryCodeDetails = createNestedMocks(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode &gt;&gt; CountryCodeType.PL<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            !playerIsOfGivenCountry<br />    }<br /><br />    def "should return true if country code is the same using ExtendedSpockSpecification's createNestedSpies"() {<br />        given:<br />            PlayerDetails playerDetails = Spy()<br />            CountryCodeDetails countryCodeDetails = createNestedSpies(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode = CountryCodeType.ENG<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /><br />    def "should return false if country code is not the same using ExtendedSpockSpecification's createNestedSpies"() {<br />        given:<br />            PlayerDetails playerDetails = Spy()<br />            CountryCodeDetails countryCodeDetails = createNestedSpies(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode = CountryCodeType.PL<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            !playerIsOfGivenCountry<br />    }<br /><br /><br />}<br /></pre><br /><b>Let's move through the test methods one by one</b>. First I present the code and then have a quick description of the presented snippet.<br /><br /><pre class="brush:java">    def "should return true if country code is the same when creating nested structures using groovy"() {<br />        given:<br />            PlayerDetails playerDetails = new PlayerDetails(<br />                    clubDetails: new ClubDetails(<br />                            country: new CountryDetails(<br />                                    countryCode: new CountryCodeDetails(<br />                                            countryCode: CountryCodeType.ENG<br />                                    )<br />                            )<br />                    )<br />            )<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /></pre><br />Here you could find the approach of creating nested structures by using the Groovy feature of passing properties to be set in the constructor.<br /><br /><pre class="brush:java">    def "should return true if country code is the same when creating nested structures using spock mocks - requires CGLIB for non interface types"() {<br />        given:<br />            PlayerDetails playerDetails = Mock()<br />            ClubDetails clubDetails = Mock()<br />            CountryDetails countryDetails = Mock()<br />            CountryCodeDetails countryCodeDetails = Mock()<br />            countryCodeDetails.countryCode &gt;&gt; CountryCodeType.ENG<br />            countryDetails.countryCode &gt;&gt; countryCodeDetails<br />            clubDetails.country &gt;&gt; countryDetails<br />            playerDetails.clubDetails &gt;&gt; clubDetails<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /></pre><br />Here you can find a test that creates mocks using Spock - mind you that you need CGLIB as a dependency when you are mocking non interface types.<br /><br /><pre class="brush:java">    def "should return true if country code is the same using ExtendedSpockSpecification's createNestedMocks"() {<br />        given:<br />            PlayerDetails playerDetails = Mock()<br />            CountryCodeDetails countryCodeDetails = createNestedMocks(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode &gt;&gt; CountryCodeType.ENG<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /></pre><br />Here you have an example of creating nested mocks using the createNestedMocks method.<br /><br /><pre class="brush:java">    def "should return false if country code is not the same using ExtendedSpockSpecification createNestedMocks"() {<br />        given:<br />            PlayerDetails playerDetails = Mock()<br />            CountryCodeDetails countryCodeDetails = createNestedMocks(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode &gt;&gt; CountryCodeType.PL<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            !playerIsOfGivenCountry<br />    }<br /></pre><br />An example showing that creating nested mocks using the createNestedMocks method really works - should return false for improper country code.<br /><br /><pre class="brush:java">    def "should return true if country code is the same using ExtendedSpockSpecification's createNestedSpies"() {<br />        given:<br />            PlayerDetails playerDetails = Spy()<br />            CountryCodeDetails countryCodeDetails = createNestedSpies(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode = CountryCodeType.ENG<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /></pre><br />Here you have an example of creating nested spies using the createNestedSpies method.<br /><br /><pre class="brush:java">    def "should return false if country code is not the same using ExtendedSpockSpecification's createNestedSpies"() {<br />        given:<br />            PlayerDetails playerDetails = Spy()<br />            CountryCodeDetails countryCodeDetails = createNestedSpies(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode = CountryCodeType.PL<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            !playerIsOfGivenCountry<br />    }<br /></pre><br />An example showing that creating nested spies using the createNestedSpies method really works - should return false for improper country code.<br /><br /><h2>Summary</h2>In this post I have shown you how you can create nested mocks and spies using Spock. It can be useful especially when you are working with nested structures such as JAXB. Still you have to bear in mind that those structures to some extend violate the Law of Demeter. If you check my previous article about Mockito you would see that:<br /><blockquote class="tr_bq">We are getting the nested elements from the JAXB generated classes. Although it violates the&nbsp;<a href="http://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter</a>&nbsp;it is quite common to call methods of&nbsp;<b>structures</b>&nbsp;because JAXB generated classes are in fact structures so in fact I fully agree with&nbsp;<a href="http://martinfowler.com/articles/mocksArentStubs.html">Martin Fowler that it should be called the Suggestion of Demeter</a>.</blockquote>And in case of this example the idea is the same - we are talking about structures so we don't violate the Law of Demeter.<br /><br /><b>Advantages</b><br /><br /><ul><li>With a single method you can mock/spy nested elements</li><li>Code cleaner than creating tons of objects that you then have to manually set</li></ul><br /><b>Disadvantages</b><br /><br /><ul><li>Your IDE won't help you with providing the property names since the properties are presented as Strings</li><li>You have to set Test Doubles only in the Specification context (and sometimes you want to go outside this scope)</li></ul><br /><h2>Sources</h2>As usual the sources are available at&nbsp;<a href="https://bitbucket.org/gregorin1987/too-much-coding/src/9f0f64d405a0c0b8219043df9b599f60569c1633/Unit%20Testing/Spock%20-%20Deep%20Stubs?at=default">BitBucket</a>&nbsp;and&nbsp;<a href="https://github.com/marcingrzejszczak/too-much-coding/tree/master/Unit%20Testing/Spock%20-%20Deep%20Stubs">GitHub</a>.</div>

]]></content>
  </entry>
  
</feed>
