<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Decision Table | TOO MUCH CODING]]></title>
  <link href="https://toomuchcoding.com/blog/categories/decision-table/atom.xml" rel="self"/>
  <link href="https://toomuchcoding.com/"/>
  <updated>2019-04-08T15:17:02+02:00</updated>
  <id>https://toomuchcoding.com/</id>
  <author>
    <name><![CDATA[Marcin Grzejszczak]]></name>
    <email><![CDATA[blog@toomuchcoding.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Execution of Groovy Scripts From Java - XmlSlurper and MarkupBuilder in Mapping Issues]]></title>
    <link href="https://toomuchcoding.com/blog/2013/03/30/execution-of-groovy-scripts-from-java/"/>
    <updated>2013-03-30T15:09:00-07:00</updated>
    <id>https://toomuchcoding.com/blog/2013/03/30/execution-of-groovy-scripts-from-java</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><h2>Problem with mappings</h2><br />In our project we came across a really big problem related to mapping. Having two systems that initially were defined by the BA to be somehwat simillar we have chosen the simple XSLT (done through Altova Mapforce) of the input message to the output one.<br />
<!--more-->
<br />Afterwards it turned out that the functions required to perform a mapping are becoming enormous. An example of such a mapping is:<br /><blockquote class="tr_bq">From the input message take a list of Cars iterate over it and find a Car whose field "prodcutionDate" is the lowest and the attribute "make" is equal to "Honda" and as the output return the "saleDate"</blockquote>So in order to map it we decided to move to JBoss Drools. The <a href="https://toomuchcoding.blogspot.com/2013/02/drools-decision-tables-with-camel-and.html">decision tables</a> were out of question since the logic was to complex and customized to be placed in the spreadsheet so we coded everything in the DRL files. Soon the rules got really big and some of our developers were forced to spend plenty of time on constant recreation of rules stated by the BA.<br /><br />Out of frustration and after having seen all the amazing things at the&nbsp;<a href="http://2013.33degree.org/">33rd degree conference</a> I decided to start finding solutions to my problems which were:<br /><br /><a name='more'></a><br /><ol><li>The DRL files are big and started to become unmaintainable (for a single field we had for example 4 rules)</li><li>Since the BA has never coded a single Drools rule / XSLT &nbsp;in his life adding a simple if... else... statement for him is not a problem</li><li>The BA has to wait for the mapping implementation by the devs until he can test it</li><li>The devs are spending far too much time on coding the mapping rules instead of developing other features</li></ol><div>After stating these problems a research regarding mapping frameworks took place and one of the concepts that I began working on was trying to create the mapping in Groovy. Since Groovy (thanks to for example PropertyMissing and MethodMissing) is a perfect language for creating a DSL I decided to start right away. The only two things I had to remember about were:</div><div><ol><li>The current application is written purely in Java</li><li>The mapping code (in order to perform fast testing) has to be detached from the application as such - it can't be compiled during deployment because we want to have the possibility of frequent substitutions of the mappings</li></ol><div><h2>Project structure&nbsp;</h2><br />Having defined the language, the constraints I created the following solution:</div></div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-LUqaZQkqom4/UVdMZkiW7RI/AAAAAAAABDc/f3sRJ9fF6AM/s1600/Project+structure.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://2.bp.blogspot.com/-LUqaZQkqom4/UVdMZkiW7RI/AAAAAAAABDc/f3sRJ9fF6AM/s320/Project+structure.png" width="255" /></a></div><div><br /></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;">The project structure</div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: left;">As you can see the project structure is very simple. To begin with it is built in <b>Gradle</b>. The main function can be found in the <b>XmlTransformer.java</b>. The flow is such that the <b>TransformerFactory</b>&nbsp;creates a <b>Transformer</b>&nbsp;basing on the Groovy script that came out of the <b>ScriptFactory </b>(in our project for different types of products that we distinguish by a field in the XML file, we have different DRL files). The Groovy scripts are residing in the classpath in the <b>/groovy/</b> folder (of course at the end of the day those scripts should be placed outside any jars).&nbsp;</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">In the <b>build.gradle</b>&nbsp;</div><div class="separator" style="clear: both; text-align: left;"><br /></div><pre class="brush:groovy">apply plugin: 'java'<br /><br />group = 'com.blogspot.toomuchcoding'<br />version = '1.0'<br /><br />repositories {<br />    mavenCentral()<br />}<br /><br />dependencies {<br />    compile 'org.codehaus.groovy:groovy-all:2.0.5'<br />    compile 'org.slf4j:slf4j-log4j12:1.7.2'<br />    compile 'log4j:log4j:1.2.16'<br />    compile 'com.google.guava:guava:14.0'<br /><br />    testCompile group: 'junit', name: 'junit', version: '4.+'<br />}<br /><br />task(executeMain, dependsOn: 'classes', type: JavaExec) {<br />    main = 'com.blogspot.toomuchcoding.XmlTransformer'<br />    classpath = sourceSets.main.runtimeClasspath<br />}<br /></pre><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">we can see that there is no groovy plugin -&nbsp;it has been done deliberately since we don't want our scripts to be compiled. Now let's take a look at the logic behind the TransformerFactory that compiles the Groovy script. What is really important is the fact that our Groovy class implements an interface created in our Java project - we want from the Java point of view to have no problems with execution of the Groovy code.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;"><b>TransformerFactoryImpl.java</b></div><div class="separator" style="clear: both; text-align: left;"><br /></div><pre class="brush:java">package com.blogspot.toomuchcoding.factory;<br /><br />import com.blogspot.toomuchcoding.transformer.Transformer;<br />import com.google.common.io.Resources;<br />import groovy.util.GroovyScriptEngine;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br /><br />import java.io.File;<br />import java.net.URL;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 22.03.13<br /> * Time: 23:54<br /> */<br />public class TransformerFactoryImpl implements TransformerFactory&lt;String, String&gt; {<br />    private static final String GROOVY_SCRIPTS_CLASSPATH = "groovy/";<br />    private static Logger LOGGER = LoggerFactory.getLogger(TransformerFactoryImpl.class);<br /><br />    private ScriptFactory scriptFactory;<br />    private GroovyScriptEngine groovyScriptEngine;<br /><br />    public TransformerFactoryImpl(ScriptFactory scriptFactory) {<br />        this.scriptFactory = scriptFactory;<br />        try {<br />            groovyScriptEngine = new GroovyScriptEngine(GROOVY_SCRIPTS_CLASSPATH);<br />        } catch (IOException e) {<br />            LOGGER.error("Exception occurred while trying to create the Groovy script engine", e);<br />            throw new RuntimeException(e);<br />        }<br />    }<br /><br />    @Override<br />    public Transformer&lt;String, String&gt; createTransformer() {<br />        Transformer&lt;String, String&gt; transformerFromScript = null;<br />        try {<br />            File scriptFile = scriptFactory.createScript();<br />            URL scriptAsAClasspathResource = Resources.getResource(GROOVY_SCRIPTS_CLASSPATH + scriptFile.getName());<br />            Class classFromScript = groovyScriptEngine.loadScriptByName(scriptAsAClasspathResource.getFile());<br />            transformerFromScript = (Transformer&lt;String, String&gt;) classFromScript.newInstance();<br />        } catch (Exception e) {<br />            LOGGER.error("Exception occurred while trying to execute Groovy script", e);<br />        }<br />        return transformerFromScript;<br />    }<br /><br />}<br /><br /></pre><div class="separator" style="clear: both; text-align: left;">A <b>GroovyScriptEngine</b>&nbsp;is used to load a script by name. I chose the <a href="http://docs.codehaus.org/display/GROOVY/Embedding+Groovy">GroovyScriptEngine</a> (hopefully I used it in a good way ;) ) &nbsp;because:</div><blockquote class="tr_bq"><span style="background-color: white; font-family: Arial, Helvetica, FreeSans, sans-serif; font-size: 13px; line-height: 17.328125px;">The most complete solution for people who want to embed groovy scripts into their servers and have them reloaded on modification is the GroovyScriptEngine. You initialize the GroovyScriptEngine with a set of CLASSPATH like roots that can be URLs or directory names. You can then execute any Groovy script within those roots. The GSE will also track dependencies between scripts so that if any dependent script is modified the whole tree will be recompiled and reloaded.</span></blockquote><div class="separator" style="clear: both; text-align: left;">I wanted to have some way of caching the compiled classes in order not to have any issues with PermGen.</div><div class="separator" style="clear: both; text-align: left;">Anyway you can see that I am doing some conversions to have the URL of the classpath Groovy script resource. At the end we are extracting a class from the Groovy script and we are casting it to the Transformer.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;"><b>AbstractGroovyXmlTransformer.groovy</b></div><div class="separator" style="clear: both; text-align: left;"><br /></div><pre class="brush:groovy">package groovy<br /><br />import com.blogspot.toomuchcoding.transformer.Transformer<br />import groovy.util.slurpersupport.NodeChildren<br />import groovy.xml.MarkupBuilder<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 23.03.13<br /> * Time: 02:16<br /> */<br />abstract class AbstractGroovyXmlTransformer implements Transformer&lt;String, String&gt; {<br /><br />    static Map&lt;String, Object&gt; MISSING_PROPERTIES = ["convertDate": new DateConverter(), "map": new Mapper()]<br /><br />    @Override<br />    String transform(String input) {<br />        def inputXml = new XmlSlurper().parseText input<br />        def writer = new StringWriter()<br />        def outputXml = new MarkupBuilder(writer)<br />        doTransform inputXml, outputXml<br />        writer.toString()<br />    }<br /><br />    abstract void doTransform(inputXml, outputXml)<br /><br />    def propertyMissing(String name) {<br />        Object property = MISSING_PROPERTIES[name]<br />        assert property != null, "There is no function like [$name]. The ones that are supported are ${MISSING_PROPERTIES.keySet()}"<br />        property<br />    }<br /><br /><br /><br />    protected static class Mapper {<br />        private Map&lt;String, String&gt; inputParameters<br /><br />        Mapper given(Map inputParameters) {<br />            this.inputParameters = inputParameters<br />            this<br />        }<br /><br />        String from(NodeChildren nodeChildren) {<br />            assert inputParameters != null, "The mapping can't be null!"<br />            assert nodeChildren != null, "Node can't be null!"<br />            String nodeText = nodeChildren.text()<br />            String mappedValue = inputParameters[nodeText]<br />            mappedValue ?: inputParameters.default<br />        }<br /><br />        static Mapper map(Map&lt;String, String&gt; inputParameters) {<br />            return new Mapper(inputParameters)<br />        }<br />    }<br /><br />    protected static class DateConverter {<br />        private String inputDate<br />        private String inputDateFormat<br /><br />        DateConverter from(NodeChildren nodeChildren) {<br />            this.inputDate = nodeChildren.text()<br />            this<br />        }<br /><br />        DateConverter havingDateFormat(String inputDateFormat) {<br />            this.inputDateFormat = inputDateFormat<br />            this<br />        }<br /><br />        String toOutputDateFormat(String outputDateFormat) {<br />            assert inputDate != null, "The input date for which you are trying to do the conversion can't be null"<br />            assert inputDateFormat != null, "The input date format for which you are trying to do the conversion can't be null"<br />            assert outputDateFormat != null, "The output date format for which you are trying to do the conversion can't be null"<br />            Date.parse(inputDateFormat, inputDate).format(outputDateFormat)<br />        }<br /><br />        static DateConverter convertDate() {<br />            new DateConverter()<br />        }<br />    }<br />}</pre><pre class="brush:groovy"></pre><div class="separator" style="clear: both; text-align: left;">In this abstract Groovy class I decided to place all the logic that could blur the image for the BA. In addition to that I created some helper classes and methods. In order to fully use the Groovy's DSL capabilities I used the propertyMissing method to map the words <b>"map"</b> and <b>"convertDate"</b>&nbsp;to create the instances of the helper classes which are used in the <b>Builder</b> design pattern way:</div><div class="separator" style="clear: both; text-align: left;"><br /></div><pre class="brush:groovy">convertDate.from(inputXml.InputSystemContext.InputDate).havingDateFormat("dd/MM/yyyy").toOutputDateFormat("yy/MM/dd")<br /><br />or<br /><br />map.given("Some_action" : "Some_output_action", "default" : "something else").from(inputXml.AdditionalData.TypeOfAction)<br /></pre><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">If there is no such "function" (for example a BA makes a typo or sth) then an assertion error is being thrown and a list of supported "function" (which in reality are properties - but they are functions from the BA's perspective) is being printed.&nbsp;</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">Now let's move to the script that would be used by the BA.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;"><b>GroovyXmlTransformer.groovy</b></div><div class="separator" style="clear: both; text-align: left;"><br /></div><pre class="brush:groovy">package groovy<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 22.03.13<br /> * Time: 23:59<br /> *<br /> * additional functions:<br /> *<br /> * convertDate.from(Node).havingDateFormat("DateFormat").toOutputDateFormat("AnotherDateFormat")<br /> * map.given("Value to be mapped from" : "Value to be mapped to", "default" : "default value").from(Node)<br /> *<br /> */<br />class GroovyXmlTransformer extends AbstractGroovyXmlTransformer {<br /><br />    @Override<br />    void doTransform(inputXml, outputXml) {<br />        outputXml.OutputSystemEnvelope() {<br />            OutputSystemContext {<br />                ResponseID(inputXml.InputSystemContext.RequestID.text().reverse())<br />                OutputSource('OUTPUT_SYSTEM')<br />                OutputDate(convertDate.from(inputXml.InputSystemContext.InputDate).havingDateFormat("dd/MM/yyyy").toOutputDateFormat("yy/MM/dd"))<br />            }<br />            OutputAdditionalData {<br />                OutputReferenceNo("SOME_PREFIX_${inputXml.AdditionalData.ReferenceNo.text()}_SOME_SUFIX")<br />                OutputTypeOfAction(map.given("Some_action" : "Some_output_action", "default" : "something else").from(inputXml.AdditionalData.TypeOfAction))<br />                OutputTransactions {<br />                    inputXml.AdditionalData.Transactions.Transaction.each {<br />                        OutputTransaction(Client: it.Client, ProductType: it.ProductType, 'Done')<br />                    }<br />                }<br />                OutputProducts {<br />                    def minProduct = inputXml.AdditionalData.Products.Product.list().min { it.Value.text() }<br />                    def maxProduct = inputXml.AdditionalData.Products.Product.list().max { it.Value.text() }<br />                    MinProduct(name: minProduct.Name.text(), minProduct.Value.text())<br />                    MaxProduct(name: maxProduct.Name.text(), maxProduct.Value.text())<br />                }<br />            }<br />        }<br />    }<br />}<br /></pre><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">This piece of code does the following mapping (You can check the <b>/xml/SampleXml.xml</b> ):</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="datagrid"><table><thead><tr><th>Mapped from</th><th>Mapped to</th></tr></thead><tbody><tr><td>InputSystemEnvelope</td><td>OutputSystemEnvelope</td></tr><tr class="alt"><td>InputSystemContex</td><td>OutputSystemContex</td></tr><tr><td>RequestId</td><td>ResponseId (the Id should be reverted)</td></tr><tr class="alt"><td>InputSource</td><td>OutputSoutce (constant "UTPUT_SYSTEM")</td></tr><tr><td>InputDate</td><td>OutputDate (converted from dd/MM/yyyy to yy/MM/dd) </td></tr><tr class="alt"><td>InputAdditionalData</td><td>OutputAdditionalData</td></tr><tr><td>InputReferenceNo</td><td>OutputReferenceNo ( "SOME_PREFIX_" + value from InputReferenceNo + "_SOME_SUFIX") </td></tr><tr class="alt"><td>InputTypeOfAction</td><td>OutputTypeOfAction (mapped in such a way that if InputTypeOfAction is equal to "Some_action" then we will have "Some_output_action". Otherwise we get "something else")</td></tr><tr><td>Transactions</td><td>OutputTransactions</td></tr><tr class="alt"><td>Transaction</td><td>OutputTransaction ( Attribute Client from Transaction.Client, Attribute ProductType from Transaction.ProductType, and the value "Done")</td></tr><tr><td>Products</td><td>OutputProducts</td></tr><tr class="alt"><td>Product having min value</td><td>MinProduct</td></tr><tr><td>Product having max value</td><td>MaxProduct</td></tr></tbody></table></div><div class="separator" style="clear: both; text-align: left;"><br /></div><h2>The output</h2><div class="separator" style="clear: both; text-align: left;"><br /></div><pre class="brush:xml">Converted from [&lt;InputSystemEnvelope&gt;<br />    &lt;InputSystemContext&gt;<br />        &lt;RequestID&gt;1234567890&lt;/RequestID&gt;<br />        &lt;InputSource&gt;INPUT_SYSTEM&lt;/InputSource&gt;<br />        &lt;InputDate&gt;22/03/2013&lt;/InputDate&gt;<br />    &lt;/InputSystemContext&gt;<br />    &lt;AdditionalData&gt;<br />        &lt;ReferenceNo&gt;Ref1234567&lt;/ReferenceNo&gt;<br />        &lt;TypeOfAction&gt;Some_action&lt;/TypeOfAction&gt;<br />        &lt;Transactions&gt;<br />            &lt;Transaction&gt;<br />                &lt;Client&gt;ACME&lt;/Client&gt;<br />                &lt;ProductType&gt;IRS&lt;/ProductType&gt;<br />            &lt;/Transaction&gt;<br />            &lt;Transaction&gt;<br />                &lt;Client&gt;Oracle&lt;/Client&gt;<br />                &lt;ProductType&gt;DB&lt;/ProductType&gt;<br />            &lt;/Transaction&gt;<br />        &lt;/Transactions&gt;<br />        &lt;Products&gt;<br />            &lt;Product&gt;<br />                &lt;Name&gt;Book&lt;/Name&gt;<br />                &lt;Value&gt;1&lt;/Value&gt;<br />            &lt;/Product&gt;<br />            &lt;Product&gt;<br />                &lt;Name&gt;Car&lt;/Name&gt;<br />                &lt;Value&gt;10000&lt;/Value&gt;<br />            &lt;/Product&gt;<br />            &lt;Product&gt;<br />                &lt;Name&gt;Boat&lt;/Name&gt;<br />                &lt;Value&gt;100000000&lt;/Value&gt;<br />            &lt;/Product&gt;<br />            &lt;Product&gt;<br />                &lt;Name&gt;Spaceship&lt;/Name&gt;<br />                &lt;Value&gt;1000000000000000000&lt;/Value&gt;<br />            &lt;/Product&gt;<br />        &lt;/Products&gt;<br />    &lt;/AdditionalData&gt;<br />&lt;/InputSystemEnvelope&gt;]<br /><br /> to<br /><br />[&lt;OutputSystemEnvelope&gt;<br />  &lt;OutputSystemContext&gt;<br />    &lt;ResponseID&gt;0987654321&lt;/ResponseID&gt;<br />    &lt;OutputSource&gt;OUTPUT_SYSTEM&lt;/OutputSource&gt;<br />    &lt;OutputDate&gt;13/03/22&lt;/OutputDate&gt;<br />  &lt;/OutputSystemContext&gt;<br />  &lt;OutputAdditionalData&gt;<br />    &lt;OutputReferenceNo&gt;SOME_PREFIX_Ref1234567_SOME_SUFIX&lt;/OutputReferenceNo&gt;<br />    &lt;OutputTypeOfAction&gt;Some_output_action&lt;/OutputTypeOfAction&gt;<br />    &lt;OutputTransactions&gt;<br />      &lt;OutputTransaction Client='ACME' ProductType='IRS'&gt;Done&lt;/OutputTransaction&gt;<br />      &lt;OutputTransaction Client='Oracle' ProductType='DB'&gt;Done&lt;/OutputTransaction&gt;<br />    &lt;/OutputTransactions&gt;<br />    &lt;OutputProducts&gt;<br />      &lt;MinProduct name='Book'&gt;1&lt;/MinProduct&gt;<br />      &lt;MaxProduct name='Spaceship'&gt;1000000000000000000&lt;/MaxProduct&gt;<br />    &lt;/OutputProducts&gt;<br />  &lt;/OutputAdditionalData&gt;<br />&lt;/OutputSystemEnvelope&gt;]<br /></pre><div><h2>Pros and cons</h2>The pros and cons of this approach are as follows:<br /><br />Pros:<br /><ul><li>The mapping is done sequentialy - field by field (it is easier to debug the problem)</li><li>The mapping consists of vocabulary understandable by the BA</li><li>Most of mappings could be done by the BA</li><li>The majority of non-mapping grammar is hidden in the abstraction</li><li>The compilation of the Groovy script is faster than creation of KnowledgeBases and compilation of Drools scripts</li><li>Independence on the XML schema (each change of the schema would require the recompilation of the JAXB classes)</li></ul><div>Cons:</div><div><ul><li>The BA would have to have some knowledge from the domain of computer science</li><li>No parallel mapping</li><li>The mapping might get less readable due to the fact that it is highly probable that the BA (out of lack of time) won't create a single function - all the logic will end up in the closures for a given Node.</li><li>There might be some memory issues with parsing and recompilation of the Groovy scripts</li><li>No XML schema may lead to improper output / input XML path setting</li></ul><h2>Summary</h2></div><div>The problem with mapping that we encountered in our project turned out to be a very interesting issue to deal with. The example shown in this post is only a proposition of solving the issue and hopefully could be a starting point to a further discussion on the topic. If you have any ideas or opinions on this topic please leave a comment under <a href="https://toomuchcoding.blogspot.com/2013/03/execution-of-groovy-scripts-from-java.html">this article</a>.</div><div><br /></div><div>The sources can be found on the <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/69f4b59e4452e630670c71150d125e7ea86170aa/Groovy/Mappings?at=default">Too Much Coding BitBucket repository</a> and on <a href="https://github.com/marcingrzejszczak/too-much-coding/tree/master/Groovy/Mappings">GitHub</a>.</div></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Drools Decision Tables With Camel and Spring]]></title>
    <link href="https://toomuchcoding.com/blog/2013/02/03/drools-decision-tables-with-camel-and/"/>
    <updated>2013-02-03T13:28:00-08:00</updated>
    <id>https://toomuchcoding.com/blog/2013/02/03/drools-decision-tables-with-camel-and</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />Hi!<br /><br /><div style="text-align: justify;">As I've shown it in my previous post <a href="https://toomuchcoding.blogspot.com/2013/01/drools-integration-with-spring-vs.html">JBoss Drools are a very useful rules engine</a>. The only problem is that creating the rules in the Rule language might be pretty complicated for a non-technical person. That's why one can provide an easy way for creating business rules - decision tables created in a spreadsheet!</div><div style="text-align: justify;"><br />
<!--more-->
</div><div style="text-align: justify;">In the following example I will show you a really complicated business rule example converted to a decision table in a spreadsheet. As a backend we will have Drools, Camel and Spring.</div><br /><br /><a name='more'></a><br /><br /><div style="text-align: justify;">To begin with let us take a look at our imaginary business problem. Let us assume that we are running a business that focuses on selling products (either Medical or Electronic). We are shipping our products to several countries (PL, USA, GER, SWE, UK, ESP) and depending on the country there are different law regulations concerning the buyer's age. In some countries you can buy products when you are younger than in others. What is more depending on the country from which the buyer and the product comes from and on the quantity of products, the buyer might get a discount. As you can see there is a substantial number of conditions needed to be fullfield in this scenario (imagine the number of ifs needed to program this :P ).</div><br /><div style="text-align: justify;">Another problem would be the business side (as usual). Anybody who has been working on a project knows how fast the requirements are changing. If one entered all the rules in the code he would have to redeploy the software each time the requirements changed. That's why it is a good practice to divide the business logic from the code itself. Anyway, let's go back to our example.</div><br />To begin with let us take a look at the spreadsheets (before that it is worth taking a look at the <a href="http://docs.jboss.org/drools/release/5.2.0.Final/drools-expert-docs/html/ch06.html">JBoss website with precise description of how the decision table should look like</a>):<br /><br /><br /><div style="text-align: justify;">The point of entry of our program is the first spreadsheet that checks if the given user should be granted with the possibility of buying a product (it will be better if you download the spreadsheets and play with them from Too Much Coding's repository at Bitbucket: <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/eeda79f74a4af30091490ab3507879254540e118/Drools/Decision%20table/src/main/resources/rules/user_table.xls?at=default">user_table.xls</a> and <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/eeda79f74a4af30091490ab3507879254540e118/Drools/Decision%20table/src/main/resources/rules/product_table.xls?at=default">product_table.xls</a>, or Github<a href="https://github.com/marcingrzejszczak/too-much-coding/blob/master/Drools/Decision%20table/src/main/resources/rules/user_table.xls?raw=true"> user_table.xls </a>and <a href="https://github.com/marcingrzejszczak/too-much-coding/blob/master/Drools/Decision%20table/src/main/resources/rules/product_table.xls?raw=true">product_table.xls</a>):</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><b>user_table.xls (tables worksheet)</b></div><div style="text-align: justify;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-J5-tXPECwJI/UQ7TmutXq5I/AAAAAAAAAzU/3c9KrRFaZ5w/s1600/user_table.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="120" src="http://1.bp.blogspot.com/-J5-tXPECwJI/UQ7TmutXq5I/AAAAAAAAAzU/3c9KrRFaZ5w/s320/user_table.png" width="320" /></a></div><div><br /></div><div>Once the user has been approved he might get a discount:</div><br /><br /><b>product_table.xls (tables worksheet)</b><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-v-fAUhcn4HI/UQ69XrrT06I/AAAAAAAAAy0/8fU1nropIhU/s1600/product_table.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="129" src="http://2.bp.blogspot.com/-v-fAUhcn4HI/UQ69XrrT06I/AAAAAAAAAy0/8fU1nropIhU/s320/product_table.png" width="320" /></a></div><br /><b>product_table.xls (lists worksheet)</b><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-_MkDqjqjuDU/UQ69mEuCy5I/AAAAAAAAAy8/u09czbpift0/s1600/user_table_lists.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="81" src="http://4.bp.blogspot.com/-_MkDqjqjuDU/UQ69mEuCy5I/AAAAAAAAAy8/u09czbpift0/s320/user_table_lists.png" width="320" /></a></div><br /><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: justify;">As you can see in the images the business problem is quite complex. Each row represents a rule, and each column represents a condition. <a href="https://toomuchcoding.blogspot.com/2013/01/drools-integration-with-spring-vs.html">Do you remember the rules syntax from my recent post?</a> So you would understand the hidden part of the spreadsheet that is right above the first visible row:</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/--f9FvvQaAhM/UQ6-gcczcQI/AAAAAAAAAzM/GxGmoV6s3OE/s1600/product_table_header.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="71" src="http://2.bp.blogspot.com/--f9FvvQaAhM/UQ6-gcczcQI/AAAAAAAAAzM/GxGmoV6s3OE/s320/product_table_header.png" width="320" /></a></div><div class="separator" style="clear: both; text-align: left;"><br /></div><br /><div style="text-align: justify;">The rows from 2 to 6 represent some fixed configuration values such as rule set, imports (<a href="https://toomuchcoding.blogspot.com/2013/01/drools-integration-with-spring-vs.html"> you've already seen that in my recent post</a>) and functions. Next in row number 7 you can find the name of the RuleTable. Then in row number 8 you have in our scenario either a CONDITION or an ACTION - so in other words either the LHS or rhe RHS respectively. Row number 9 is both representation of types presented in the condition and the binding to a variable. In row number 10 we have the exact LHS condition. Row number 11 shows the label of columns. From row number 12 we have the rules one by one. You can find the spreadsheets in the sources.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">Now let's take a look at the code. Let's start with taking a look at the schemas defining the Product and the User.<br /><br /></div><div style="text-align: justify;"><b>Person.xsd</b><br /><br /></div><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;<br />    &lt;xsd:include schemaLocation="user.xsd"/&gt;<br /><br />    &lt;xsd:element name="Product"&gt;<br />        &lt;xsd:complexType&gt;<br />            &lt;xsd:sequence&gt;<br />                &lt;xsd:element name="Name" type="xsd:string"/&gt;<br />                &lt;xsd:element name="Type" type="ProductType"/&gt;<br />                &lt;xsd:element name="Price" type="xsd:double"/&gt;<br />                &lt;xsd:element name="CountryOfOrigin" type="CountryType"/&gt;<br />                &lt;xsd:element name="AdditionalInfo" type="xsd:string"/&gt;<br />                &lt;xsd:element name="Quantity" type="xsd:int"/&gt;<br />            &lt;/xsd:sequence&gt;<br />        &lt;/xsd:complexType&gt;<br />    &lt;/xsd:element&gt;<br /><br />    &lt;xsd:simpleType name="ProductType"&gt;<br />        &lt;xsd:restriction base="xsd:string"&gt;<br />            &lt;xsd:enumeration value="MEDICAL"/&gt;<br />            &lt;xsd:enumeration value="ELECTRONIC"/&gt;<br />        &lt;/xsd:restriction&gt;<br />    &lt;/xsd:simpleType&gt;<br /><br />&lt;/xsd:schema&gt;<br /></pre><br /><div style="text-align: justify;"><b>User.xsd</b><br /><br /></div><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;<br />    &lt;xsd:include schemaLocation="product.xsd"/&gt;<br /><br />    &lt;xsd:element name="User"&gt;<br />        &lt;xsd:complexType&gt;<br />            &lt;xsd:sequence&gt;<br />                &lt;xsd:element name="UserName" type="xsd:string"/&gt;<br />                &lt;xsd:element name="UserAge" type="xsd:int"/&gt;<br />                &lt;xsd:element name="UserCountry" type="CountryType"/&gt;<br />                &lt;xsd:element name="Decision" type="DecisionType"/&gt;<br />                &lt;xsd:element name="DecisionDescription" type="xsd:string"/&gt;<br />            &lt;/xsd:sequence&gt;<br />        &lt;/xsd:complexType&gt;<br />    &lt;/xsd:element&gt;<br /><br />    &lt;xsd:simpleType name="CountryType"&gt;<br />        &lt;xsd:restriction base="xsd:string"&gt;<br />            &lt;xsd:enumeration value="PL"/&gt;<br />            &lt;xsd:enumeration value="USA"/&gt;<br />            &lt;xsd:enumeration value="GER"/&gt;<br />            &lt;xsd:enumeration value="SWE"/&gt;<br />            &lt;xsd:enumeration value="UK"/&gt;<br />            &lt;xsd:enumeration value="ESP"/&gt;<br />        &lt;/xsd:restriction&gt;<br />    &lt;/xsd:simpleType&gt;<br /><br />    &lt;xsd:simpleType name="DecisionType"&gt;<br />        &lt;xsd:restriction base="xsd:string"&gt;<br />            &lt;xsd:enumeration value="ACCEPTED"/&gt;<br />            &lt;xsd:enumeration value="REJECTED"/&gt;<br />        &lt;/xsd:restriction&gt;<br />    &lt;/xsd:simpleType&gt;<br /><br />&lt;/xsd:schema&gt;<br /></pre><br />Due to the fact that we are using maven we may use a plugin that will convert the XSD into Java classes.<br /><br />part of the <b>pom.xml  </b><br /><br /><pre class="brush:xml"> &lt;build&gt;<br />        &lt;pluginManagement&gt;<br />            &lt;plugins&gt;<br />                &lt;plugin&gt;<br />                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br />                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br />                    &lt;version&gt;2.5.1&lt;/version&gt;<br />                &lt;/plugin&gt;<br />            &lt;/plugins&gt;<br />        &lt;/pluginManagement&gt;<br />        &lt;plugins&gt;<br />            &lt;plugin&gt;<br />                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br />                &lt;artifactId&gt;jaxb2-maven-plugin&lt;/artifactId&gt;<br />                &lt;version&gt;1.5&lt;/version&gt;<br />                &lt;executions&gt;<br />                    &lt;execution&gt;<br />                        &lt;id&gt;xjc&lt;/id&gt;<br />                        &lt;goals&gt;<br />                            &lt;goal&gt;xjc&lt;/goal&gt;<br />                        &lt;/goals&gt;<br />                    &lt;/execution&gt;<br />                &lt;/executions&gt;<br />                &lt;configuration&gt;<br />                    &lt;packageName&gt;pl.grzejszczak.marcin.drools.decisiontable.model&lt;/packageName&gt;<br />                    &lt;schemaDirectory&gt;${project.basedir}/src/main/resources/xsd&lt;/schemaDirectory&gt;<br />                &lt;/configuration&gt;<br />            &lt;/plugin&gt;<br />        &lt;/plugins&gt;<br />    &lt;/build&gt;<br /></pre><br />Thanks to this plugin we have our generated by JAXB classes in the <b>pl.grzejszczak.marcin.decisiontable.model</b> package.<br /><br />Now off to the drools-context.xml file where we've defined all the necessary beans as far as Drools are concerned:<br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:drools="http://drools.org/schema/drools-spring"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />  http://drools.org/schema/drools-spring http://drools.org/schema/drools-spring.xsd"&gt;<br /><br />    &lt;!-- Grid Node identifier that is registered in the CamelContext --&gt;<br />    &lt;drools:grid-node id="node1"/&gt;<br /><br />    &lt;drools:kbase id="productsKBase" node="node1"&gt;<br />        &lt;drools:resources&gt;<br />            &lt;drools:resource type="DTABLE" source="classpath:rules/product_table.xls"/&gt;<br />        &lt;/drools:resources&gt;<br />    &lt;/drools:kbase&gt;<br /><br />    &lt;drools:ksession id="productsKSession" name="productsKSession" type="stateless" kbase="productsKBase" node="node1"/&gt;<br /><br />    &lt;drools:kbase id="usersKBase" node="node1"&gt;<br />        &lt;drools:resources&gt;<br />            &lt;drools:resource type="DTABLE" source="classpath:rules/user_table.xls"/&gt;<br />        &lt;/drools:resources&gt;<br />    &lt;/drools:kbase&gt;<br /><br />    &lt;drools:ksession id="usersKSession" name="usersKSession" type="stateless" kbase="usersKBase" node="node1"/&gt;<br /><br />&lt;/beans&gt;</pre><br /><div style="text-align: justify;">As you can see in comparison to <a href="https://toomuchcoding.blogspot.com/2013/01/drools-integration-with-spring-vs.html">the application context from the recent post </a>there are some differences. First instead of passing the DRL file as the resource inside the knowledge base we are providing the Decision table (<span style="font-family: Courier New, Courier, monospace;">DTABLE</span>). I've decided to pass in two seperate files but you can provide one file with several worksheets and access those worksheets (through the <span style="font-family: Courier New, Courier, monospace;">decisiontable-conf</span> element). Also there is an additional element called <span style="font-family: Courier New, Courier, monospace;">node</span>. We have to choose an implementation of the Node interface (Execution, Grid...) for the Camel route to work properly as you will see in a couple of seconds in the Spring application context file.&nbsp;</div><br /><b>applicationContext.xml</b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:camel="http://camel.apache.org/schema/spring"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xsi:schemaLocation="http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd<br />                           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />                           http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring-2.8.0.xsd"&gt;<br /><br />    &lt;import resource="classpath:drools-context.xml"/&gt;<br />    &lt;!-- Show Spring where to search for the beans (in which packages) --&gt;<br />    &lt;context:component-scan base-package="pl.grzejszczak.marcin.drools.decisiontable" /&gt;<br /><br />    &lt;camel:camelContext id="camelContext"&gt;<br />        &lt;camel:route id="acceptanceRoute"&gt;<br />            &lt;camel:from uri="direct:acceptanceRoute"/&gt;<br />            &lt;camel:to uri="drools:node1/usersKSession"/&gt;<br />        &lt;/camel:route&gt;<br />        &lt;camel:route id="discountRoute"&gt;<br />            &lt;camel:from uri="direct:discountRoute"/&gt;<br />            &lt;camel:to uri="drools:node1/productsKSession"/&gt;<br />        &lt;/camel:route&gt;<br />    &lt;/camel:camelContext&gt;<br /><br />&lt;/beans&gt;<br /><br /></pre><div style="text-align: justify;">As you can see in order to access the Drools Camel Component we have to provide the <b>node </b>through which we will access the proper<b> knowledge session</b>. We have defined two routes - the first one ends at the Drools component that accesses the users knowledge session and the other the products knowledge session.&nbsp;</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;">We have a ProductService interface implementation called ProductServiceImpl that given an input User and Product objects pass them through the Camel's Producer Template to two Camel routes each ending at the Drools components. The concept behind this product service is that we are first processing the User if he can even buy the software and then we are checking what kind of a discount he would receive. From the service's point of view in fact we are just sending the object out and waiting for the response. Finally having reveived the response we are passing the User and the Product to the Financial Service implementation that will bill the user for the products that he has bought or reject his offer if needed.</div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"><b>ProductServiceImpl.java</b></div><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.decisiontable.service;<br /><br />import org.apache.camel.CamelContext;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.decisiontable.model.Product;<br />import pl.grzejszczak.marcin.drools.decisiontable.model.User;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("productServiceImpl")<br />public class ProductServiceImpl implements ProductService {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ProductServiceImpl.class);<br /><br />    @Autowired<br />    CamelContext camelContext;<br /><br />    @Autowired<br />    FinancialService financialService;<br /><br />    @Override<br />    public void runProductLogic(User user, Product product) {<br />        LOGGER.debug("Running product logic - first acceptance Route, then discount Route");<br />        camelContext.createProducerTemplate().sendBody("direct:acceptanceRoute", newArrayList(user, product));<br />        camelContext.createProducerTemplate().sendBody("direct:discountRoute", newArrayList(user, product));<br />        financialService.processOrder(user, product);<br />    }<br /><br />}<br /></pre><pre class="brush:java"></pre><div style="text-align: justify;"><br /></div><span style="text-align: justify;">Another crucial thing to remember about is that the Camel Drools Component requires the Command object as the input. As you can see, in the body we are sending a list of objects (and these are not Command objects). I did it on purpose since in my opinion it is better not to bind our code to a concrete solution. What if we find out that there is a better solution than Drools? Will we change all the code that we have created or just change the Camel route to point at our new solution? That's why Camel has the TypeConverters. We have our own here&nbsp;as well. First of all let's take a look at the implementation.</span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;"><b>ProductTypeConverter.java</b></span><br /><span style="text-align: justify;"><br /></span><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.decisiontable.converter;<br /><br />import org.apache.camel.Converter;<br />import org.drools.command.Command;<br />import org.drools.command.CommandFactory;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import pl.grzejszczak.marcin.drools.decisiontable.model.Product;<br /><br />import java.util.List;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 30.01.13<br /> * Time: 21:42<br /> */<br />@Converter<br />public class ProductTypeConverter {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ProductTypeConverter.class);<br /><br />    @Converter<br />    public static Command toCommandFromList(List inputList) {<br />        LOGGER.debug("Executing ProductTypeConverter's toCommandFromList method");<br />        return CommandFactory.newInsertElements(inputList);<br />    }<br /><br />    @Converter<br />    public static Command toCommand(Product product) {<br />        LOGGER.debug("Executing ProductTypeConverter's toCommand method");<br />        return CommandFactory.newInsert(product);<br />    }<br />}<br /><br /></pre><span style="text-align: justify;">There is a good tutorial on TypeConverters on the <a href="http://camel.apache.org/type-converter.html">Camel website</a> - if you needed some more indepth info about it. Anyway, we are annotating our class and the functions used to convert different types into one another. What is important here is that we are showing Camel how to convert a list and a single product to Commands. Due to type erasure this will work regardless of the provided type that is why even though we are giving a list of Product &nbsp;and User, the toCommandFromList function will get executed.&nbsp;</span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;">In addition to this in order for the type converter to work we have to provide the fully quallified name of our class (FQN) in the&nbsp;<b>/META-INF/services/org/apache/camel/TypeConverter</b> file.</span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;"><b>TypeConverter</b></span><br /><span style="text-align: justify;"><br /></span><br /><pre class="brush:xml">pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter</pre><br /><span style="text-align: justify;">In order to properly test our functionality one should write quite a few tests that would verify the rules. A pretty good way would be to have input files stored in the test resources folders that are passed to the rule engine and then the result would be compared against the verified output (unfortunately it is rather impossible to make the business side develop such a reference set of outputs). Anyway let's take a look at the unit test that verifies only a few of the rules and the logs that are produced from running those rules:</span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;"><b>ProductServiceImplTest.java</b></span><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.decisiontable.service.drools;<br /><br />import org.apache.commons.lang.builder.ReflectionToStringBuilder;<br />import org.apache.commons.lang.builder.ToStringStyle;<br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br />import pl.grzejszczak.marcin.drools.decisiontable.model.*;<br />import pl.grzejszczak.marcin.drools.decisiontable.service.ProductService;<br /><br />import static org.junit.Assert.assertEquals;<br />import static org.junit.Assert.assertTrue;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.02.13<br /> * Time: 16:06<br /> */<br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration("classpath:applicationContext.xml")<br />public class ProductServiceImplTest {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ProductServiceImplTest.class);<br /><br />    @Autowired<br />    ProductService objectUnderTest;<br /><br />    @Test<br />    public void testRunProductLogicUserPlUnderageElectronicCountryPL() throws Exception {<br />        int initialPrice = 1000;<br />        int userAge = 6;<br />        int quantity = 10;<br /><br />        User user = createUser("Smith", CountryType.PL, userAge);<br />        Product product = createProduct("Electronic", initialPrice, CountryType.PL, ProductType.ELECTRONIC, quantity);<br /><br />        printInputs(user, product);<br /><br />        objectUnderTest.runProductLogic(user, product);<br /><br />        printInputs(user, product);<br /><br />        assertTrue(product.getPrice() == initialPrice);<br />        assertEquals(DecisionType.REJECTED, user.getDecision());<br />    }<br /><br />    @Test<br />    public void testRunProductLogicUserPlHighAgeElectronicCountryPLLowQuantity() throws Exception {<br />        int initialPrice = 1000;<br />        int userAge = 19;<br />        int quantity = 1;<br /><br />        User user = createUser("Smith", CountryType.PL, userAge);<br />        Product product = createProduct("Electronic", initialPrice, CountryType.PL, ProductType.ELECTRONIC, quantity);<br /><br />        printInputs(user, product);<br /><br />        objectUnderTest.runProductLogic(user, product);<br /><br />        printInputs(user, product);<br /><br />        assertTrue(product.getPrice() == initialPrice);<br />        assertEquals(DecisionType.ACCEPTED, user.getDecision());<br />    }<br /><br />    @Test<br />    public void testRunProductLogicUserPlHighAgeElectronicCountryPLHighQuantity() throws Exception {<br />        int initialPrice = 1000;<br />        int userAge = 19;<br />        int quantity = 8;<br /><br />        User user = createUser("Smith", CountryType.PL, userAge);<br />        Product product = createProduct("Electronic", initialPrice, CountryType.PL, ProductType.ELECTRONIC, quantity);<br /><br />        printInputs(user, product);<br /><br />        objectUnderTest.runProductLogic(user, product);<br /><br />        printInputs(user, product);<br />        double expectedDiscount = 0.1;<br /><br />        assertTrue(product.getPrice() == initialPrice * (1 - expectedDiscount));<br />        assertEquals(DecisionType.ACCEPTED, user.getDecision());<br />    }<br /><br />    @Test<br />    public void testRunProductLogicUserUsaLowAgeElectronicCountryPLHighQuantity() throws Exception {<br />        int initialPrice = 1000;<br />        int userAge = 19;<br />        int quantity = 8;<br /><br />        User user = createUser("Smith", CountryType.USA, userAge);<br />        Product product = createProduct("Electronic", initialPrice, CountryType.PL, ProductType.ELECTRONIC, quantity);<br /><br />        printInputs(user, product);<br /><br />        objectUnderTest.runProductLogic(user, product);<br /><br />        printInputs(user, product);<br /><br />        assertTrue(product.getPrice() == initialPrice);<br />        assertEquals(DecisionType.REJECTED, user.getDecision());<br />    }<br /><br />    @Test<br />    public void testRunProductLogicUserUsaHighAgeMedicalCountrySWELowQuantity() throws Exception {<br />        int initialPrice = 1000;<br />        int userAge = 22;<br />        int quantity = 4;<br /><br />        User user = createUser("Smith", CountryType.USA, userAge);<br />        Product product = createProduct("Some name", initialPrice, CountryType.SWE, ProductType.MEDICAL, quantity);<br /><br />        printInputs(user, product);<br /><br />        objectUnderTest.runProductLogic(user, product);<br /><br />        printInputs(user, product);<br /><br />        assertTrue(product.getPrice() == initialPrice);<br />        assertEquals(DecisionType.ACCEPTED, user.getDecision());<br />    }<br /><br />    @Test<br />    public void testRunProductLogicUserUsaHighAgeMedicalCountrySWEHighQuantity() throws Exception {<br />        int initialPrice = 1000;<br />        int userAge = 22;<br />        int quantity = 8;<br /><br />        User user = createUser("Smith", CountryType.USA, userAge);<br />        Product product = createProduct("Some name", initialPrice, CountryType.SWE, ProductType.MEDICAL, quantity);<br /><br />        printInputs(user, product);<br /><br />        objectUnderTest.runProductLogic(user, product);<br /><br />        printInputs(user, product);<br />        double expectedDiscount = 0.25;<br /><br />        assertTrue(product.getPrice() == initialPrice * (1 - expectedDiscount));<br />        assertEquals(DecisionType.ACCEPTED, user.getDecision());<br />    }<br /><br />    private void printInputs(User user, Product product) {<br />        LOGGER.debug(ReflectionToStringBuilder.reflectionToString(user, ToStringStyle.MULTI_LINE_STYLE));<br />        LOGGER.debug(ReflectionToStringBuilder.reflectionToString(product, ToStringStyle.MULTI_LINE_STYLE));<br />    }<br /><br />    private User createUser(String name, CountryType countryType, int userAge){<br />        User user = new User();<br />        user.setUserName(name);<br />        user.setUserCountry(countryType);<br />        user.setUserAge(userAge);<br />        return user;<br />    }<br /><br />    private Product createProduct(String name, double price, CountryType countryOfOrigin, ProductType productType, int quantity){<br />        Product product = new Product();<br />        product.setPrice(price);<br />        product.setCountryOfOrigin(countryOfOrigin);<br />        product.setName(name);<br />        product.setType(productType);<br />        product.setQuantity(quantity);<br />        return product;<br />    }<br /><br />}<br /><br /></pre><span style="text-align: justify;">Of course the log.debugs in the tests are totally redundant but I wanted you to quickly see that the rules are operational :) Sorry for the length of the logs but I wrote a few tests to show different combinations of rules (in fact it's better too have too many logs than the other way round :) )</span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;"><br /></span><br /><pre class="brush:xml">pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@1d48043[<br />  userName=Smith<br />  userAge=6<br />  userCountry=PL<br />  decision=&lt;null&gt;<br />  decisionDescription=&lt;null&gt;<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@1e8f2a0[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=1000.0<br />  countryOfOrigin=PL<br />  additionalInfo=&lt;null&gt;<br />  quantity=10<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductServiceImpl:31 Running product logic - first acceptance Route, then discount Route<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Sorry, according to your age (&lt; 18) and country (PL) you can't buy this product<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.FinancialServiceImpl:29 Sorry, user has been rejected...<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@1d48043[<br />  userName=Smith<br />  userAge=6<br />  userCountry=PL<br />  decision=REJECTED<br />  decisionDescription=Sorry, according to your age (&lt; 18) and country (PL) you can't buy this product<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@1e8f2a0[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=1000.0<br />  countryOfOrigin=PL<br />  additionalInfo=&lt;null&gt;<br />  quantity=10<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@b28f30[<br />  userName=Smith<br />  userAge=19<br />  userCountry=PL<br />  decision=&lt;null&gt;<br />  decisionDescription=&lt;null&gt;<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@d6a0e0[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=1000.0<br />  countryOfOrigin=PL<br />  additionalInfo=&lt;null&gt;<br />  quantity=1<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductServiceImpl:31 Running product logic - first acceptance Route, then discount Route<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Congratulations, you have successfully bought the product<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Sorry, no discount will be granted.<br />pl.grzejszczak.marcin.drools.decisiontable.service.FinancialServiceImpl:25 User has been approved - processing the order...<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@b28f30[<br />  userName=Smith<br />  userAge=19<br />  userCountry=PL<br />  decision=ACCEPTED<br />  decisionDescription=Congratulations, you have successfully bought the product<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@d6a0e0[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=1000.0<br />  countryOfOrigin=PL<br />  additionalInfo=Sorry, no discount will be granted.<br />  quantity=1<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@14510ac[<br />  userName=Smith<br />  userAge=19<br />  userCountry=PL<br />  decision=&lt;null&gt;<br />  decisionDescription=&lt;null&gt;<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@1499616[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=1000.0<br />  countryOfOrigin=PL<br />  additionalInfo=&lt;null&gt;<br />  quantity=8<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductServiceImpl:31 Running product logic - first acceptance Route, then discount Route<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Congratulations, you have successfully bought the product<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Congratulations - you've been granted a 10% discount!<br />pl.grzejszczak.marcin.drools.decisiontable.service.FinancialServiceImpl:25 User has been approved - processing the order...<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@14510ac[<br />  userName=Smith<br />  userAge=19<br />  userCountry=PL<br />  decision=ACCEPTED<br />  decisionDescription=Congratulations, you have successfully bought the product<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@1499616[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=900.0<br />  countryOfOrigin=PL<br />  additionalInfo=Congratulations - you've been granted a 10% discount!<br />  quantity=8<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@17667bd[<br />  userName=Smith<br />  userAge=19<br />  userCountry=USA<br />  decision=&lt;null&gt;<br />  decisionDescription=&lt;null&gt;<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@ad9f5d[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=1000.0<br />  countryOfOrigin=PL<br />  additionalInfo=&lt;null&gt;<br />  quantity=8<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductServiceImpl:31 Running product logic - first acceptance Route, then discount Route<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Sorry, according to your age (&lt; 18) and country (USA) you can't buy this product<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.FinancialServiceImpl:29 Sorry, user has been rejected...<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@17667bd[<br />  userName=Smith<br />  userAge=19<br />  userCountry=USA<br />  decision=REJECTED<br />  decisionDescription=Sorry, according to your age (&lt; 18) and country (USA) you can't buy this product<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@ad9f5d[<br />  name=Electronic<br />  type=ELECTRONIC<br />  price=1000.0<br />  countryOfOrigin=PL<br />  additionalInfo=&lt;null&gt;<br />  quantity=8<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@9ff588[<br />  userName=Smith<br />  userAge=22<br />  userCountry=USA<br />  decision=&lt;null&gt;<br />  decisionDescription=&lt;null&gt;<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@1b0d2d0[<br />  name=Some name<br />  type=MEDICAL<br />  price=1000.0<br />  countryOfOrigin=SWE<br />  additionalInfo=&lt;null&gt;<br />  quantity=4<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductServiceImpl:31 Running product logic - first acceptance Route, then discount Route<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Congratulations, you have successfully bought the product<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.FinancialServiceImpl:25 User has been approved - processing the order...<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@9ff588[<br />  userName=Smith<br />  userAge=22<br />  userCountry=USA<br />  decision=ACCEPTED<br />  decisionDescription=Congratulations, you have successfully bought the product<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@1b0d2d0[<br />  name=Some name<br />  type=MEDICAL<br />  price=1000.0<br />  countryOfOrigin=SWE<br />  additionalInfo=&lt;null&gt;<br />  quantity=4<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@1b27882[<br />  userName=Smith<br />  userAge=22<br />  userCountry=USA<br />  decision=&lt;null&gt;<br />  decisionDescription=&lt;null&gt;<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@5b84b[<br />  name=Some name<br />  type=MEDICAL<br />  price=1000.0<br />  countryOfOrigin=SWE<br />  additionalInfo=&lt;null&gt;<br />  quantity=8<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductServiceImpl:31 Running product logic - first acceptance Route, then discount Route<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Congratulations, you have successfully bought the product<br />pl.grzejszczak.marcin.drools.decisiontable.converter.ProductTypeConverter:25 Executing ProductTypeConverter's toCommandFromList method<br />pl.grzejszczak.marcin.drools.decisiontable.service.ProductService:8 Congratulations, you are granted a discount<br />pl.grzejszczak.marcin.drools.decisiontable.service.FinancialServiceImpl:25 User has been approved - processing the order...<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:150 pl.grzejszczak.marcin.drools.decisiontable.model.User@1b27882[<br />  userName=Smith<br />  userAge=22<br />  userCountry=USA<br />  decision=ACCEPTED<br />  decisionDescription=Congratulations, you have successfully bought the product<br />]<br />pl.grzejszczak.marcin.drools.decisiontable.service.drools.ProductServiceImplTest:151 pl.grzejszczak.marcin.drools.decisiontable.model.Product@5b84b[<br />  name=Some name<br />  type=MEDICAL<br />  price=750.0<br />  countryOfOrigin=SWE<br />  additionalInfo=Congratulations, you are granted a discount<br />  quantity=8<br />]<br /><br /></pre><span style="text-align: justify;">In this post I've presented how you can push some of your developing work to your BA by giving him a tool which he can be able to work woth - the Decision Tables in a spreadsheet. What is more now you will now how to integrate Drools with Camel. Hopefully you will see how you can simplify (thus minimize the cost of implementing and supporting) the implementation of business rules bearing in mind how prone to changes they are. I hope that this example will even better illustrate how difficult it would be to implement all the business rules in Java than in the <a href="https://toomuchcoding.blogspot.com/2013/01/drools-integration-with-spring-vs.html">previous post about Drools.</a></span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;">If you have any experience with Drools in terms of decision tables, integration with Spring and Camel please feel free to leave a comment - let's have a discussion on that :)</span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;">All the code is available at Too Much Coding repository at <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/eeda79f74a4af30091490ab3507879254540e118/Drools/Decision%20table?at=default">Bitbucket </a>and <a href="https://github.com/marcingrzejszczak/too-much-coding/tree/master/Drools/Decision%20table">GitHub</a>.</span><span style="text-align: justify;"><br /></span><br /><span style="text-align: justify;"><br /></span><span style="text-align: justify;">Cheers!</span></div>

]]></content>
  </entry>
  
</feed>
