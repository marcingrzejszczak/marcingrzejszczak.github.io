<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Specification | TOO MUCH CODING]]></title>
  <link href="http://toomuchcoding.com/blog/categories/specification/atom.xml" rel="self"/>
  <link href="http://toomuchcoding.com/"/>
  <updated>2019-01-24T12:58:03+01:00</updated>
  <id>http://toomuchcoding.com/</id>
  <author>
    <name><![CDATA[Marcin Grzejszczak]]></name>
    <email><![CDATA[blog@toomuchcoding.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spock - Return Nested Spies / Mocks]]></title>
    <link href="http://toomuchcoding.com/blog/2013/08/06/spock-return-nested-spies-mocks/"/>
    <updated>2013-08-06T04:24:00-07:00</updated>
    <id>http://toomuchcoding.com/blog/2013/08/06/spock-return-nested-spies-mocks</id>
    <content type="html"><![CDATA[<div class='post'>
<br />Hi! Some time ago I have written an article about Mockito and using <a href="http://toomuchcoding.blogspot.com/2013/06/mockito-returndeepstubs-for-jaxb.html">RETURNS_DEEP_STUBS when working with JAXB</a>. Quite recently we have faced a similliar issue with deeply nesetd JAXB and the awesome testing framework written in Groovy called&nbsp;<a href="https://code.google.com/p/spock/">Spock</a>. Natively Spock does not support creating deep stubs or spies so we needed to create a workaround for it and this article will show you how to do it.<br />
<!--more-->
<br /><a name='more'></a><h2>Project structure</h2>We will be working on the same data structure as in the&nbsp;<a href="http://toomuchcoding.blogspot.com/2013/06/mockito-returndeepstubs-for-jaxb.html">RETURNS_DEEP_STUBS when working with JAXB</a>&nbsp;article so the project structure will be quite simillar:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-3AoyOo8WYuY/UgC3QJ5TuNI/AAAAAAAABkw/YJzt5EXB10s/s1600/Spock+Deep+Stubs+project+structure.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://4.bp.blogspot.com/-3AoyOo8WYuY/UgC3QJ5TuNI/AAAAAAAABkw/YJzt5EXB10s/s320/Spock+Deep+Stubs+project+structure.jpg" width="191" /></a></div><br />As you can see the main difference is such that the tests are present in the<span style="font-family: Courier New, Courier, monospace;"> /test/groovy/</span> folder instead of <span style="font-family: Courier New, Courier, monospace;">/test/java/</span> folder.<br /><h2>Extended Spock Specification</h2>In order to use Spock as a testing framework you have to create Groovy test scripts that extend the Spock Specification class. The details of how to use Spock are available <a href="https://code.google.com/p/spock/wiki/SpockBasics">here</a>. In this project I have created an abstract class that extends Specification and adds two additional methods for creating nested Test Doubles (I don't remember if I haven't seen a prototype of this approach somewhere on the internet).<br /><br /><b>ExtendedSpockSpecification.groovy</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.spock;<br /><br />import spock.lang.Specification<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: MGrzejszczak<br /> * Date: 14.06.13<br /> * Time: 15:26<br /> */<br />abstract class ExtendedSpockSpecification extends Specification {<br />    /**<br />     * The method creates nested structure of spies for all the elements present in the property parameter. Those spies are set on the input object.<br />     *<br />     * @param object - object on which you want to create nested spies<br />     * @param property - field accessors delimited by a dot - JavaBean convention<br />     * @return Spy of the last object from the property path<br />     */<br />    protected def createNestedSpies(object, String property) {<br />        def lastObject = object<br />        property.tokenize('.').inject object, { obj, prop -&gt;<br />            if (obj[prop] == null) {<br />                def foundProp = obj.metaClass.properties.find { it.name == prop }<br />                obj[prop] = Spy(foundProp.type)<br />            }<br />            lastObject = obj[prop]<br />        }<br />        lastObject<br />    }<br /><br />    /**<br />     * The method creates nested structure of mocks for all the elements present in the property parameter. Those mocks are set on the input object.<br />     *<br />     * @param object - object on which you want to create nested mocks<br />     * @param property - field accessors delimited by a dot - JavaBean convention<br />     * @return Mock of the last object from the property path<br />     */<br />    protected def createNestedMocks(object, String property) {<br />        def lastObject = object<br />        property.tokenize('.').inject object, { obj, prop -&gt;<br />            def foundProp = obj.metaClass.properties.find { it.name == prop }<br />            def mockedProp = Mock(foundProp.type)<br />            lastObject."${prop}" &gt;&gt; mockedProp<br />            lastObject = mockedProp<br />        }<br />        lastObject<br />    }<br />}<br /><br /></pre>These two methods work in a very simillar manner.<br /><ul><li>Assuming that the&nbsp;method's argument&nbsp;<span style="font-family: Courier New, Courier, monospace;">property </span>&nbsp;looks as follows: <span style="font-family: Courier New, Courier, monospace;">"a.b.c.d"</span> then the methods tokenize the string by <span style="font-family: Courier New, Courier, monospace;">"."</span> and iterate over the array - <span style="font-family: Courier New, Courier, monospace;">["a","b","c","d"]</span>.&nbsp;</li><li>We then iterate over the properties of the <a href="http://groovy.codehaus.org/api/groovy/lang/MetaClass.html">Meta Class</a>&nbsp;to find the one whose name is equal to <span style="font-family: Courier New, Courier, monospace;">prop</span> (for example<span style="font-family: Courier New, Courier, monospace;"> "a"</span>).&nbsp;</li><li>If that is the case we then use Spock's Mock/Spy method to create a Test Double of a given class (type).&nbsp;</li><li>Finally we have to bind the mocked nested element to its parent.&nbsp;</li><ul><li>For the Spy it's easy since we set the value on the parent (<span style="font-family: Courier New, Courier, monospace;">lastObject = obj[prop]</span>).&nbsp;</li><li>For the mocks however we need to use the overloaded <span style="font-family: Courier New, Courier, monospace;">&gt;&gt;</span> operator to record the behavior for our mock - that's why dynamically call the property that is present in the <span style="font-family: Courier New, Courier, monospace;">prop</span> variable (<span style="font-family: Courier New, Courier, monospace;">lastObject."${prop}" &gt;&gt; mockedProp</span>).&nbsp;</li></ul><li>Then we return from the closure the mocked/spied instance and we repeat the process for it</li></ul><div><h2>Class to be tested</h2>Let's take a look at the class to be tested:<br /><br /><b>PlayerServiceImpl.java</b><br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.service;<br /><br />import com.blogspot.toomuchcoding.model.PlayerDetails;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 08.06.13<br /> * Time: 19:02<br /> */<br />public class PlayerServiceImpl implements PlayerService {<br />    @Override<br />    public boolean isPlayerOfGivenCountry(PlayerDetails playerDetails, String country) {<br />        String countryValue = playerDetails.getClubDetails().getCountry().getCountryCode().getCountryCode().value();<br />        return countryValue.equalsIgnoreCase(country);<br />    }<br />}<br /></pre><h2>The test class</h2>And now the test class:<br /><br /><b>PlayerServiceImplWrittenUsingSpockTest.groovy</b></div><div></div><br /><pre class="brush:java">package com.blogspot.toomuchcoding.service<br /><br />import com.blogspot.toomuchcoding.model.*<br />import com.blogspot.toomuchcoding.spock.ExtendedSpockSpecification<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 14.06.13<br /> * Time: 16:06<br /> */<br />class PlayerServiceImplWrittenUsingSpockTest extends ExtendedSpockSpecification {<br /><br />    public static final String COUNTRY_CODE_ENG = "ENG";<br /><br />    PlayerServiceImpl objectUnderTest<br /><br />    def setup(){<br />        objectUnderTest = new PlayerServiceImpl()<br />    }<br /><br />    def "should return true if country code is the same when creating nested structures using groovy"() {<br />        given:<br />            PlayerDetails playerDetails = new PlayerDetails(<br />                    clubDetails: new ClubDetails(<br />                            country: new CountryDetails(<br />                                    countryCode: new CountryCodeDetails(<br />                                            countryCode: CountryCodeType.ENG<br />                                    )<br />                            )<br />                    )<br />            )<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /><br />    def "should return true if country code is the same when creating nested structures using spock mocks - requires CGLIB for non interface types"() {<br />        given:<br />            PlayerDetails playerDetails = Mock()<br />            ClubDetails clubDetails = Mock()<br />            CountryDetails countryDetails = Mock()<br />            CountryCodeDetails countryCodeDetails = Mock()<br />            countryCodeDetails.countryCode &gt;&gt; CountryCodeType.ENG<br />            countryDetails.countryCode &gt;&gt; countryCodeDetails<br />            clubDetails.country &gt;&gt; countryDetails<br />            playerDetails.clubDetails &gt;&gt; clubDetails<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /><br /><br />    def "should return true if country code is the same using ExtendedSpockSpecification's createNestedMocks"() {<br />        given:<br />            PlayerDetails playerDetails = Mock()<br />            CountryCodeDetails countryCodeDetails = createNestedMocks(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode &gt;&gt; CountryCodeType.ENG<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /><br />    def "should return false if country code is not the same using ExtendedSpockSpecification createNestedMocks"() {<br />        given:<br />            PlayerDetails playerDetails = Mock()<br />            CountryCodeDetails countryCodeDetails = createNestedMocks(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode &gt;&gt; CountryCodeType.PL<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            !playerIsOfGivenCountry<br />    }<br /><br />    def "should return true if country code is the same using ExtendedSpockSpecification's createNestedSpies"() {<br />        given:<br />            PlayerDetails playerDetails = Spy()<br />            CountryCodeDetails countryCodeDetails = createNestedSpies(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode = CountryCodeType.ENG<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /><br />    def "should return false if country code is not the same using ExtendedSpockSpecification's createNestedSpies"() {<br />        given:<br />            PlayerDetails playerDetails = Spy()<br />            CountryCodeDetails countryCodeDetails = createNestedSpies(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode = CountryCodeType.PL<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            !playerIsOfGivenCountry<br />    }<br /><br /><br />}<br /></pre><br /><b>Let's move through the test methods one by one</b>. First I present the code and then have a quick description of the presented snippet.<br /><br /><pre class="brush:java">    def "should return true if country code is the same when creating nested structures using groovy"() {<br />        given:<br />            PlayerDetails playerDetails = new PlayerDetails(<br />                    clubDetails: new ClubDetails(<br />                            country: new CountryDetails(<br />                                    countryCode: new CountryCodeDetails(<br />                                            countryCode: CountryCodeType.ENG<br />                                    )<br />                            )<br />                    )<br />            )<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /></pre><br />Here you could find the approach of creating nested structures by using the Groovy feature of passing properties to be set in the constructor.<br /><br /><pre class="brush:java">    def "should return true if country code is the same when creating nested structures using spock mocks - requires CGLIB for non interface types"() {<br />        given:<br />            PlayerDetails playerDetails = Mock()<br />            ClubDetails clubDetails = Mock()<br />            CountryDetails countryDetails = Mock()<br />            CountryCodeDetails countryCodeDetails = Mock()<br />            countryCodeDetails.countryCode &gt;&gt; CountryCodeType.ENG<br />            countryDetails.countryCode &gt;&gt; countryCodeDetails<br />            clubDetails.country &gt;&gt; countryDetails<br />            playerDetails.clubDetails &gt;&gt; clubDetails<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /></pre><br />Here you can find a test that creates mocks using Spock - mind you that you need CGLIB as a dependency when you are mocking non interface types.<br /><br /><pre class="brush:java">    def "should return true if country code is the same using ExtendedSpockSpecification's createNestedMocks"() {<br />        given:<br />            PlayerDetails playerDetails = Mock()<br />            CountryCodeDetails countryCodeDetails = createNestedMocks(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode &gt;&gt; CountryCodeType.ENG<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /></pre><br />Here you have an example of creating nested mocks using the createNestedMocks method.<br /><br /><pre class="brush:java">    def "should return false if country code is not the same using ExtendedSpockSpecification createNestedMocks"() {<br />        given:<br />            PlayerDetails playerDetails = Mock()<br />            CountryCodeDetails countryCodeDetails = createNestedMocks(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode &gt;&gt; CountryCodeType.PL<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            !playerIsOfGivenCountry<br />    }<br /></pre><br />An example showing that creating nested mocks using the createNestedMocks method really works - should return false for improper country code.<br /><br /><pre class="brush:java">    def "should return true if country code is the same using ExtendedSpockSpecification's createNestedSpies"() {<br />        given:<br />            PlayerDetails playerDetails = Spy()<br />            CountryCodeDetails countryCodeDetails = createNestedSpies(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode = CountryCodeType.ENG<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            playerIsOfGivenCountry<br />    }<br /></pre><br />Here you have an example of creating nested spies using the createNestedSpies method.<br /><br /><pre class="brush:java">    def "should return false if country code is not the same using ExtendedSpockSpecification's createNestedSpies"() {<br />        given:<br />            PlayerDetails playerDetails = Spy()<br />            CountryCodeDetails countryCodeDetails = createNestedSpies(playerDetails, "clubDetails.country.countryCode")<br />            countryCodeDetails.countryCode = CountryCodeType.PL<br /><br />        when:<br />            boolean playerIsOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        then:<br />            !playerIsOfGivenCountry<br />    }<br /></pre><br />An example showing that creating nested spies using the createNestedSpies method really works - should return false for improper country code.<br /><br /><h2>Summary</h2>In this post I have shown you how you can create nested mocks and spies using Spock. It can be useful especially when you are working with nested structures such as JAXB. Still you have to bear in mind that those structures to some extend violate the Law of Demeter. If you check my previous article about Mockito you would see that:<br /><blockquote class="tr_bq">We are getting the nested elements from the JAXB generated classes. Although it violates the&nbsp;<a href="http://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter</a>&nbsp;it is quite common to call methods of&nbsp;<b>structures</b>&nbsp;because JAXB generated classes are in fact structures so in fact I fully agree with&nbsp;<a href="http://martinfowler.com/articles/mocksArentStubs.html">Martin Fowler that it should be called the Suggestion of Demeter</a>.</blockquote>And in case of this example the idea is the same - we are talking about structures so we don't violate the Law of Demeter.<br /><br /><b>Advantages</b><br /><br /><ul><li>With a single method you can mock/spy nested elements</li><li>Code cleaner than creating tons of objects that you then have to manually set</li></ul><br /><b>Disadvantages</b><br /><br /><ul><li>Your IDE won't help you with providing the property names since the properties are presented as Strings</li><li>You have to set Test Doubles only in the Specification context (and sometimes you want to go outside this scope)</li></ul><br /><h2>Sources</h2>As usual the sources are available at&nbsp;<a href="https://bitbucket.org/gregorin1987/too-much-coding/src/9f0f64d405a0c0b8219043df9b599f60569c1633/Unit%20Testing/Spock%20-%20Deep%20Stubs?at=default">BitBucket</a>&nbsp;and&nbsp;<a href="https://github.com/marcingrzejszczak/too-much-coding/tree/master/Unit%20Testing/Spock%20-%20Deep%20Stubs">GitHub</a>.</div>

]]></content>
  </entry>
  
</feed>
