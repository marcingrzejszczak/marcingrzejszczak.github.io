<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: google guava | TOO MUCH CODING]]></title>
  <link href="http://toomuchcoding.com/blog/categories/google-guava/atom.xml" rel="self"/>
  <link href="http://toomuchcoding.com/"/>
  <updated>2016-03-04T11:35:37+01:00</updated>
  <id>http://toomuchcoding.com/</id>
  <author>
    <name><![CDATA[Marcin Grzejszczak]]></name>
    <email><![CDATA[blog@toomuchcoding.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Review of the Getting Started with Guava book]]></title>
    <link href="http://toomuchcoding.com/blog/2013/09/30/review-of-getting-started-with-guava/"/>
    <updated>2013-09-30T22:10:00+02:00</updated>
    <id>http://toomuchcoding.com/blog/2013/09/30/review-of-getting-started-with-guava</id>
    <content type="html"><![CDATA[<div class='post'>
<span style="font-family: inherit;"><span style="color: black;">Hi!</span></span><span style="font-family: inherit;"><br /></span><br /><span style="font-family: inherit;">I didn't have much time to write posts recently (beacuse of work and my book <a href="http://www.packtpub.com/how-to-create-stubs-mocks-spies-using-mockito/book">"Mockito Instant"</a>) but&nbsp;</span><span style="font-family: inherit;">I came across Bill Bejeck's book entitled <a href="http://www.packtpub.com/getting-started-with-google-guava/book">"Getting Started with Guava"</a>. After having read it I decided that I will try also to blog about computer science related books. So without any futher ado let's move to the review :)</span><br />
<!--more-->
<span style="font-family: inherit;"></span><br /><a name='more'></a><br /><span style="font-family: inherit;"><span style="color: black;">To begin with I really enjoyed the book's structure – one can see that the author had a clear view of the book: introduction to the functionality, its presentation with examples and a short review. By keeping such a fixed structure the reader wasn't surprised by the content in each of the chapters what made reading even more pleasant.</span></span><br /><span style="font-family: inherit;"><span style="color: black;"><br /></span></span><span style="font-family: inherit;"><span style="color: black;">Let's move quickly through the book content chapter by chapter.&nbsp;</span></span><br /><span style="font-family: inherit;"><span style="color: black;"><br /></span></span><span style="font-family: inherit;"><span style="color: black;"></span></span><br /><b>Basic Guava Utilities</b><br /><div><br /></div><span style="font-family: inherit;"><span style="color: black;">First of all you will be able to increase your knowledge about joining and splitting operations on collections by means of the Joiner and Splitter classes - no more unnecessary writing of loops! You will be able also to learn how to operate on Strings using&nbsp;</span></span><span class="Apple-tab-span" style="white-space: pre;"> </span> CharMatcher, Charsets,&nbsp;Strings which often is extremely tidious and produces a lot of boilerplate code. Next you will be able to learn about Preconditions - you won't have to write those cascades of if's in terms of defensive programming. Instead how about checking a condition and throw a runtime exception? To end with the author shows how to use Guava's utility classes to create implementation of toString, hashCode and compareTo methods.<br /><div><br /></div><div><div><b>Functional Programming with Guava</b></div></div><div><br /></div><div>In this chapter the author shows how to introduce some functional approach to your Object oriented Java code with the Function, Predicate and Supplier interfaces and their corresponding utility classes Functions, Predicates and Suppliers.</div><div><br /></div><div><div><b>Working with Collections</b></div></div><div><br /></div><div>Since the Guava library emerged from issues related with collection manipulation the author could show the best examples in this chapter. You will learn about the Collections,&nbsp;FluentIterables, and Iterables utility classes. The author also mentions the Range class that you can use to represent boundaries. You will also be able to find information on other types of collections such as Bimaps (maps that aside from being navigated in the standard key to value way can be navigated from values to keys), Tables (replacement for map of maps), Multimaps (values are collections). There is also a part of the chapter related to the Ordering class that fives you additional posisbilities of working with Comparators.</div><div><br /></div><div><b>Concurrency</b></div><div><br /></div><div>The issue of concurrency is a very difficult issue as such. Guava can assist you in this difficult subject in a number of was that the author depicts: the Monitor class (version of a Mutex) can help you provide the serial access to part of your code, the Futures utility class to work with Future instances and many more cool solutions ;)</div><div><br /></div><div><b>Guava Cache</b></div><div><br /></div><div>The author shows several ways of creating caches, showing their statistics and how to configure them. You will also be able to learn how to register listeners for different cashe related types of events.&nbsp;</div><div><br /></div><div><b>The Event Bus</b></div><div><br /></div><div>The author shows how to subscribe to events by using the Google Guava's Event Bus. What I really liked about this chapter was the presentation of the reason for incorporating it in a project (loose coupling) and a sample of using it in a Spring based application.</div><div><br /></div><div><b>Working with Files</b></div><div><br /></div><div>You will be able to find presentations of the utility classes and helpful solutions related to working with IO such as Files, CharStreams, ByteStreams, Readers , Writers the Closer class (elegant way of ensuring that the Closeable instance gets properly closed). The author presents the concept behind source and sinks too. So if you work a lot with files you will find plenty of cool stuff here.</div><div><br /></div><div><b>Odds and Ends</b></div><div><br /></div><div>Useful classes related to creating hash codes, working with Throwables and creating your applications in a null safe way.</div><div><br /></div><span style="font-family: inherit;"><span style="color: black;">I would never say that I know every aspect of Guava but I tend to use a lot of its functionalities at work. That's why I was really curious about the level of details that the author wanted to present in his book and whether I would find some really interesting details of the library that I wasn't aware of. What I found in the book was very satisfactory for me because although I was already familliar with the majority of the presented examples and functionalities, still I found plenty of those „little things” that I can use to improve my code and remove more boilerplate.</span></span><span style="font-family: inherit;"><span style="color: black;"><br /></span></span><br /><span style="font-family: inherit;"><span style="color: black;">Speaking of which, what I really wanted to look at from the very beginning where the code samples showing how cool and helpful Guava really is. Being a true fan of unit testing I was very happy to see that the author put a lot of effort in those examples - the majority of functionalities were described by means of unit tests and showing some real life situations.</span></span><span style="font-family: inherit;"><span style="color: black;"><br /></span></span><br /><span style="font-family: inherit;"><span style="color: black;">To sum it up I think that Bill Bejeck has put a tremendous effort in writing his book and he has done the job exceptionally well. I would recommend „Getting Started with Guava” for both newbies and experts – for sure both of these groups will be very satisfied.</span></span></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hamcrest Matchers, Guava Predicate and Builder design pattern]]></title>
    <link href="http://toomuchcoding.com/blog/2013/01/04/hamcrest-matchers-guava-predicate-and/"/>
    <updated>2013-01-04T01:35:00+01:00</updated>
    <id>http://toomuchcoding.com/blog/2013/01/04/hamcrest-matchers-guava-predicate-and</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />Hi coding addicts :)<br /><br />Often, while coding we have to deal with some POJO objects that have dozens of fields in them. Many times we initialize those classes through a constructor having dozens of arguments which is terrible in any possibly imaginable way :) Apart from that the functions that use those constructors are hardly testable. Let's take a closer look at using a Builder to change that situation, together with Hamcrest matchers and Guava Predicates to unit test it.<br />
<!--more-->
<br />Let's start off with taking a look at the POJO class.<br /><br /><br /><a name='more'></a><br /><br /><b>SomeBigPojo.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.pojo;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 21:05<br /> */<br />public class SomeBigPojo {<br />    private String stringField0;<br />    private Integer integerField0;<br />    private Boolean booleanField0;<br />    private String stringField1;<br />    private Integer integerField1;<br />    private Boolean booleanField1;<br />    private String stringField2;<br />    private Integer integerField2;<br />    private Boolean booleanField2;<br />    private String stringField3;<br />    private Integer integerField3;<br />    private Boolean booleanField3;<br />    private String stringField4;<br />    private Integer integerField4;<br />    private Boolean booleanField4;<br />    private String stringField5;<br />    private Integer integerField5;<br />    private Boolean booleanField5;<br />    private String stringField6;<br />    private Integer integerField6;<br />    private Boolean booleanField6;<br />    private String stringField7;<br />    private String stringField8;<br />    private String stringField9;<br /><br />    public SomeBigPojo(String stringField0, Integer integerField0, Boolean booleanField0, String stringField1, Integer integerField1, Boolean booleanField1, String stringField2, Integer integerField2, Boolean booleanField2, String stringField3, Integer integerField3, Boolean booleanField3, String stringField4, Integer integerField4, Boolean booleanField4, String stringField5, Integer integerField5, Boolean booleanField5, String stringField6, Integer integerField6, Boolean booleanField6, String stringField7, String stringField8, String stringField9) {<br />        this.stringField0 = stringField0;<br />        this.integerField0 = integerField0;<br />        this.booleanField0 = booleanField0;<br />        this.stringField1 = stringField1;<br />        this.integerField1 = integerField1;<br />        this.booleanField1 = booleanField1;<br />        this.stringField2 = stringField2;<br />        this.integerField2 = integerField2;<br />        this.booleanField2 = booleanField2;<br />        this.stringField3 = stringField3;<br />        this.integerField3 = integerField3;<br />        this.booleanField3 = booleanField3;<br />        this.stringField4 = stringField4;<br />        this.integerField4 = integerField4;<br />        this.booleanField4 = booleanField4;<br />        this.stringField5 = stringField5;<br />        this.integerField5 = integerField5;<br />        this.booleanField5 = booleanField5;<br />        this.stringField6 = stringField6;<br />        this.integerField6 = integerField6;<br />        this.booleanField6 = booleanField6;<br />        this.stringField7 = stringField7;<br />        this.stringField8 = stringField8;<br />        this.stringField9 = stringField9;<br />    }<br /><br />    public String getStringField0() {<br />        return stringField0;<br />    }<br /><br />    public void setStringField0(String stringField0) {<br />        this.stringField0 = stringField0;<br />    }<br /><br />    public Integer getIntegerField0() {<br />        return integerField0;<br />    }<br /><br />    public void setIntegerField0(Integer integerField0) {<br />        this.integerField0 = integerField0;<br />    }<br /><br />    public Boolean getBooleanField0() {<br />        return booleanField0;<br />    }<br /><br />    public void setBooleanField0(Boolean booleanField0) {<br />        this.booleanField0 = booleanField0;<br />    }<br /><br />    public String getStringField1() {<br />        return stringField1;<br />    }<br /><br />    public void setStringField1(String stringField1) {<br />        this.stringField1 = stringField1;<br />    }<br /><br />    public Integer getIntegerField1() {<br />        return integerField1;<br />    }<br /><br />    public void setIntegerField1(Integer integerField1) {<br />        this.integerField1 = integerField1;<br />    }<br /><br />    public Boolean getBooleanField1() {<br />        return booleanField1;<br />    }<br /><br />    public void setBooleanField1(Boolean booleanField1) {<br />        this.booleanField1 = booleanField1;<br />    }<br /><br />    public String getStringField2() {<br />        return stringField2;<br />    }<br /><br />    public void setStringField2(String stringField2) {<br />        this.stringField2 = stringField2;<br />    }<br /><br />    public Integer getIntegerField2() {<br />        return integerField2;<br />    }<br /><br />    public void setIntegerField2(Integer integerField2) {<br />        this.integerField2 = integerField2;<br />    }<br /><br />    public Boolean getBooleanField2() {<br />        return booleanField2;<br />    }<br /><br />    public void setBooleanField2(Boolean booleanField2) {<br />        this.booleanField2 = booleanField2;<br />    }<br /><br />    public String getStringField3() {<br />        return stringField3;<br />    }<br /><br />    public void setStringField3(String stringField3) {<br />        this.stringField3 = stringField3;<br />    }<br /><br />    public Integer getIntegerField3() {<br />        return integerField3;<br />    }<br /><br />    public void setIntegerField3(Integer integerField3) {<br />        this.integerField3 = integerField3;<br />    }<br /><br />    public Boolean getBooleanField3() {<br />        return booleanField3;<br />    }<br /><br />    public void setBooleanField3(Boolean booleanField3) {<br />        this.booleanField3 = booleanField3;<br />    }<br /><br />    public String getStringField4() {<br />        return stringField4;<br />    }<br /><br />    public void setStringField4(String stringField4) {<br />        this.stringField4 = stringField4;<br />    }<br /><br />    public Integer getIntegerField4() {<br />        return integerField4;<br />    }<br /><br />    public void setIntegerField4(Integer integerField4) {<br />        this.integerField4 = integerField4;<br />    }<br /><br />    public Boolean getBooleanField4() {<br />        return booleanField4;<br />    }<br /><br />    public void setBooleanField4(Boolean booleanField4) {<br />        this.booleanField4 = booleanField4;<br />    }<br /><br />    public String getStringField5() {<br />        return stringField5;<br />    }<br /><br />    public void setStringField5(String stringField5) {<br />        this.stringField5 = stringField5;<br />    }<br /><br />    public Integer getIntegerField5() {<br />        return integerField5;<br />    }<br /><br />    public void setIntegerField5(Integer integerField5) {<br />        this.integerField5 = integerField5;<br />    }<br /><br />    public Boolean getBooleanField5() {<br />        return booleanField5;<br />    }<br /><br />    public void setBooleanField5(Boolean booleanField5) {<br />        this.booleanField5 = booleanField5;<br />    }<br /><br />    public String getStringField6() {<br />        return stringField6;<br />    }<br /><br />    public void setStringField6(String stringField6) {<br />        this.stringField6 = stringField6;<br />    }<br /><br />    public Integer getIntegerField6() {<br />        return integerField6;<br />    }<br /><br />    public void setIntegerField6(Integer integerField6) {<br />        this.integerField6 = integerField6;<br />    }<br /><br />    public Boolean getBooleanField6() {<br />        return booleanField6;<br />    }<br /><br />    public void setBooleanField6(Boolean booleanField6) {<br />        this.booleanField6 = booleanField6;<br />    }<br /><br />    public String getStringField7() {<br />        return stringField7;<br />    }<br /><br />    public void setStringField7(String stringField7) {<br />        this.stringField7 = stringField7;<br />    }<br /><br />    public String getStringField8() {<br />        return stringField8;<br />    }<br /><br />    public void setStringField8(String stringField8) {<br />        this.stringField8 = stringField8;<br />    }<br /><br />    public String getStringField9() {<br />        return stringField9;<br />    }<br /><br />    public void setStringField9(String stringField9) {<br />        this.stringField9 = stringField9;<br />    }<br /><br />    @Override<br />    public String toString() {<br />        final StringBuilder sb = new StringBuilder();<br />        sb.append("SomeBigPojo");<br />        sb.append("{stringField0='").append(stringField0).append('\'');<br />        sb.append(", integerField0=").append(integerField0);<br />        sb.append(", booleanField0=").append(booleanField0);<br />        sb.append(", stringField1='").append(stringField1).append('\'');<br />        sb.append(", integerField1=").append(integerField1);<br />        sb.append(", booleanField1=").append(booleanField1);<br />        sb.append(", stringField2='").append(stringField2).append('\'');<br />        sb.append(", integerField2=").append(integerField2);<br />        sb.append(", booleanField2=").append(booleanField2);<br />        sb.append(", stringField3='").append(stringField3).append('\'');<br />        sb.append(", integerField3=").append(integerField3);<br />        sb.append(", booleanField3=").append(booleanField3);<br />        sb.append(", stringField4='").append(stringField4).append('\'');<br />        sb.append(", integerField4=").append(integerField4);<br />        sb.append(", booleanField4=").append(booleanField4);<br />        sb.append(", stringField5='").append(stringField5).append('\'');<br />        sb.append(", integerField5=").append(integerField5);<br />        sb.append(", booleanField5=").append(booleanField5);<br />        sb.append(", stringField6='").append(stringField6).append('\'');<br />        sb.append(", integerField6=").append(integerField6);<br />        sb.append(", booleanField6=").append(booleanField6);<br />        sb.append(", stringField7='").append(stringField7).append('\'');<br />        sb.append(", stringField8='").append(stringField8).append('\'');<br />        sb.append(", stringField9='").append(stringField9).append('\'');<br />        sb.append('}');<br />        return sb.toString();<br />    }<br />}<br /><br /></pre>Now take a look at the builder class that was used in order to get rid of usage of the humongous constructor. What is more you can set whatever you want to without the need to enter nulls for the undesired fields.<br /><br /><b>SomeBigPojoBuilder.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.builder;<br /><br />import pl.grzejszczak.marcin.junit.matchers.pojo.SomeBigPojo;<br /><br />import static com.google.common.base.Preconditions.checkNotNull;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 21:08<br /> */<br />public class SomeBigPojoBuilder {<br />    /** A field with some default value */<br />    private String stringField0 = "defaultValueForString0";<br />    /** A field with some default value */<br />    private Integer integerField0 = 100;<br />    /** A field with some default value */<br />    private Boolean booleanField0 = true;<br />    private String stringField1;<br />    private Integer integerField1;<br />    private Boolean booleanField1;<br />    private String stringField2;<br />    private Integer integerField2;<br />    private Boolean booleanField2;<br />    private String stringField3;<br />    private Integer integerField3;<br />    private Boolean booleanField3;<br />    private String stringField4;<br />    private Integer integerField4;<br />    private Boolean booleanField4;<br />    private String stringField5;<br />    private Integer integerField5;<br />    private Boolean booleanField5;<br />    private String stringField6;<br />    private Integer integerField6;<br />    private Boolean booleanField6;<br />    private String stringField7;<br />    private String stringField8;<br />    private String stringField9;<br /><br />    public SomeBigPojoBuilder setStringField0(String stringField0) {<br />        this.stringField0 = stringField0;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField0(Integer integerField0) {<br />        this.integerField0 = integerField0;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField0(Boolean booleanField0) {<br />        this.booleanField0 = booleanField0;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField1(String stringField1) {<br />        this.stringField1 = stringField1;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField1(Integer integerField1) {<br />        this.integerField1 = integerField1;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField1(Boolean booleanField1) {<br />        this.booleanField1 = booleanField1;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField2(String stringField2) {<br />        this.stringField2 = stringField2;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField2(Integer integerField2) {<br />        this.integerField2 = integerField2;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField2(Boolean booleanField2) {<br />        this.booleanField2 = booleanField2;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField3(String stringField3) {<br />        this.stringField3 = stringField3;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField3(Integer integerField3) {<br />        this.integerField3 = integerField3;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField3(Boolean booleanField3) {<br />        this.booleanField3 = booleanField3;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField4(String stringField4) {<br />        this.stringField4 = stringField4;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField4(Integer integerField4) {<br />        this.integerField4 = integerField4;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField4(Boolean booleanField4) {<br />        this.booleanField4 = booleanField4;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField5(String stringField5) {<br />        this.stringField5 = stringField5;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField5(Integer integerField5) {<br />        this.integerField5 = integerField5;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField5(Boolean booleanField5) {<br />        this.booleanField5 = booleanField5;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField6(String stringField6) {<br />        this.stringField6 = stringField6;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField6(Integer integerField6) {<br />        this.integerField6 = integerField6;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField6(Boolean booleanField6) {<br />        this.booleanField6 = booleanField6;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField7(String stringField7) {<br />        this.stringField7 = stringField7;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField8(String stringField8) {<br />        this.stringField8 = stringField8;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField9(String stringField9) {<br />        this.stringField9 = stringField9;<br />        return this;<br />    }<br /><br />    /**<br />     * Some function checking the state of our POJO<br />     */<br />    private void checkState(){<br />        checkNotNull(stringField1, "StringField1 must not be null!");<br />    }<br /><br />    public SomeBigPojo createSomeBigPojoWithBuilder() {<br />        checkState();<br />        return new SomeBigPojo(stringField0, integerField0, booleanField0, stringField1, integerField1, booleanField1, stringField2, integerField2, booleanField2, stringField3, integerField3, booleanField3, stringField4, integerField4, booleanField4, stringField5, integerField5, booleanField5, stringField6, integerField6, booleanField6, stringField7, stringField8, stringField9);<br />    }<br />}<br /></pre><br />Take a look at the function checkState that verifies whether the object is of a desired state. In this way we may disallow the creation of an object if some conditions where not fullfiled. For that case we are using the Guava's Predicate - checkNotNull method. <br /><br />Note that the concept behind the Builder pattern is to delegate creation of an object to a Builder. In fact in the pure Builder design pattern implementation we would have to have a Director, some abstraction over a Builder and the concrete implementation of the Builder as such. In our case we have a simplification of that pattern - I used the refactoring option of IntelliJ. What can be done to make it look even better is to remove the constructor from the POJO and pass the values only by setters (that's what in fact I did in one of my projects ;) ) <br /><br />Now let's take a look at some usage examples: <br /><b><br /></b><b>SomeServiceImpl.java </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.service;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import pl.grzejszczak.marcin.junit.matchers.builder.SomeBigPojoBuilder;<br />import pl.grzejszczak.marcin.junit.matchers.pojo.SomeBigPojo;<br /><br />import static java.lang.String.format;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 21:25<br /> */<br />public class SomeServiceImpl implements SomeService {<br />    private static final Logger LOGGER = LoggerFactory.getLogger(SomeServiceImpl.class);<br /><br />    /** Could be an abstraction of builders injected by a setter - possible to mock */<br />    private SomeBigPojoBuilder someBigPojoBuilder;<br /><br />    /**<br />     * Hard to unit test<br />     */<br />    @Override<br />    public void someLogicForAPojoWithoutBuilder() {<br />        LOGGER.debug("SomeLogicForAPojoWithoutBuilder executed");<br />        SomeBigPojo someBigPojo = new SomeBigPojo("string", 1, false, "other string", 123, true, "something else", 321, false, "yet another string", 111, true, "something", 2, false, "More", 3, true, "String", 12, false, "some", "value", "ofString");<br />        // Any chance of knowing what is the value of stringField8 basing on the constructor?<br />        LOGGER.debug(format("StringField8 is equal [%s]%n", someBigPojo.getStringField8()));<br />        // Print the object<br />        LOGGER.debug(someBigPojo.toString());<br />    }<br /><br />    @Override<br />    public void someLogicForAPojoWithBuilder() {<br />        LOGGER.debug("SomeLogicForAPojoWithBuilder executed");<br />        SomeBigPojo someBigPojo = someBigPojoBuilder<br />                .setStringField0("string")<br />                .setIntegerField0(1)<br />                .setBooleanField0(false)<br />                .setStringField1("other string")<br />                .setIntegerField1(123)<br />                .setBooleanField1(true)<br />                .setStringField2("something else")<br />                .setIntegerField2(321)<br />                .setBooleanField2(false)<br />                .setStringField3("yet another string")<br />                .setIntegerField3(111)<br />                .setBooleanField3(false)<br />                .setStringField4("something")<br />                .setIntegerField4(2)<br />                .setBooleanField4(false)<br />                .setStringField5("More")<br />                .setIntegerField5(3)<br />                .setBooleanField5(true)<br />                .setStringField6("String")<br />                .setIntegerField6(12)<br />                .setBooleanField6(false)<br />                .setStringField7("some")<br />                .setStringField8("value")<br />                .setStringField9("ofString")<br />                .createSomeBigPojoWithBuilder();<br />        // Looking at the builder now I guess it's obvious what the value of StringField8<br />        LOGGER.debug(format("StringField8 is equal [%s]%n", someBigPojo.getStringField8()));<br />        // Print the object<br />        LOGGER.debug(someBigPojo.toString());<br />    }<br /><br />    @Override<br />    public void someLogicForAPojoWithBuilderBadArgument() {<br />        LOGGER.debug("someLogicForAPojoWithBuilderBadArgument executed");<br />        SomeBigPojo someBigPojo = someBigPojoBuilder<br />                .setStringField0("string")<br />                .setIntegerField0(1)<br />                .setBooleanField0(true)<br />                .setIntegerField1(123)<br />                .setBooleanField1(true)<br />                .setStringField2("something else")<br />                .setIntegerField2(321)<br />                .setBooleanField2(false)<br />                .setStringField3("yet another string")<br />                .setIntegerField3(111).setBooleanField3(false)<br />                .setStringField4("something")<br />                .setIntegerField4(2)<br />                .setBooleanField4(false)<br />                .setStringField5("More")<br />                .setIntegerField5(3)<br />                .setBooleanField5(true)<br />                .setStringField6("String")<br />                .setIntegerField6(12)<br />                .setBooleanField6(false)<br />                .setStringField7("some")<br />                .setStringField8("value")<br />                .setStringField9("ofString")<br />                .createSomeBigPojoWithBuilder();<br />        // Print the object - will we even see an output<br />        LOGGER.debug(someBigPojo.toString());<br />    }<br /><br />    public void setSomeBigPojoBuilder(SomeBigPojoBuilder someBigPojoBuilder) {<br />        this.someBigPojoBuilder = someBigPojoBuilder;<br />    }<br />}<br /><br /><br /></pre><br /><br />Notice how clear it is now to create an object and how easy is to define if a field has been set or not. <br /><br />Let's move on to Hamcrest matchers that will help us in unit testing of our classes. I will not try to do the complete, 100% code coverage - the idea behind this post is to show how Hamcrest Matchers can become an addition to your unit tests. <br /><br />Often unit tests are quite unclear and look like this:<br /><b><br /></b><b>SomeBigPojoBuilderNoMatchersAndNoRefactoringTest.java </b><br /><b><br /></b><br /><pre class="brush:java"></pre><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.builder;<br /><br />import org.junit.Before;<br />import org.junit.Test;<br />import pl.grzejszczak.marcin.junit.matchers.pojo.SomeBigPojo;<br /><br />import static junit.framework.Assert.assertTrue;<br />import static org.apache.commons.lang.StringUtils.isNumeric;<br />import static pl.grzejszczak.marcin.junit.matchers.pojo.SomePojoConstants.*;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 23:02<br /> */<br />public class SomeBigPojoBuilderNoMatchersAndNoRefactoringTest {<br /><br />    private SomeBigPojoBuilder objectUnderTest;<br /><br />    @Before<br />    public void setUp() {<br />        objectUnderTest = new SomeBigPojoBuilder();<br />    }<br /><br />    @Test<br />    public void testCreateSomeBigPojoWithBuilder() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setBooleanField1(true)<br />                .setStringField0("1")<br />                .setStringField1("12")<br />                .setStringField2("123")<br />                .setStringField3("1234")<br />                .setStringField4("12345")<br />                .setStringField5("123456")<br />                .setStringField6("1234567")<br />                .setStringField7("12345678")<br />                .setStringField8("123456789")<br />                .setStringField9("1234567890")<br />                .createSomeBigPojoWithBuilder();<br /><br />        isPojoProperlyBuilt(someBigPojo);<br />    }<br /><br />    @Test(expected = AssertionError.class)<br />    public void testCreateSomeBigPojoWithBuilderWrongFields() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setStringField0("0")<br />                .setStringField1("Too long")<br />                .createSomeBigPojoWithBuilder();<br /><br />        isPojoProperlyBuilt(someBigPojo);<br />    }<br /><br />    private void isPojoProperlyBuilt(SomeBigPojo someBigPojo) {<br />        assertTrue(someBigPojo.getStringField0().length() == STRING_FIELD_0_LENGTH);<br />        assertTrue(isNumeric(someBigPojo.getStringField0()));<br /><br />        assertTrue(someBigPojo.getStringField1().length() == STRING_FIELD_1_LENGTH);<br />        assertTrue(isNumeric(someBigPojo.getStringField0()));<br /><br />        assertTrue(someBigPojo.getStringField2().length() == STRING_FIELD_2_LENGTH);<br />        assertTrue(isNumeric(someBigPojo.getStringField0()));<br /><br />        assertTrue(someBigPojo.getStringField3().length() == STRING_FIELD_3_LENGTH);<br />        assertTrue(isNumeric(someBigPojo.getStringField0()));<br /><br />        assertTrue(someBigPojo.getStringField4().length() == STRING_FIELD_4_LENGTH);<br />        assertTrue(isNumeric(someBigPojo.getStringField0()));<br /><br />        assertTrue(someBigPojo.getStringField5().length() == STRING_FIELD_5_LENGTH);<br /><br />        assertTrue(someBigPojo.getStringField6().length() == STRING_FIELD_6_LENGTH);<br /><br />        assertTrue(someBigPojo.getStringField7().length() == STRING_FIELD_7_LENGTH);<br /><br />        assertTrue(someBigPojo.getStringField8().length() == STRING_FIELD_8_LENGTH);<br /><br />        assertTrue(someBigPojo.getStringField9().length() == STRING_FIELD_9_LENGTH);<br /><br />    }<br />}<br /><br /></pre><br />Simple refactoring can make them look nicer... <br /><br /><b>SomeBigPojoBuilderNoMatchersTest.java </b><br /><b><br /></b><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.builder;<br /><br />import org.junit.Before;<br />import org.junit.Test;<br />import pl.grzejszczak.marcin.junit.matchers.pojo.SomeBigPojo;<br /><br />import static junit.framework.Assert.assertNotNull;<br />import static junit.framework.Assert.assertTrue;<br />import static org.apache.commons.lang.StringUtils.isNumeric;<br />import static pl.grzejszczak.marcin.junit.matchers.pojo.SomePojoConstants.*;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 23:02<br /> */<br />public class SomeBigPojoBuilderNoMatchersTest {<br /><br />    private SomeBigPojoBuilder objectUnderTest;<br /><br />    @Before<br />    public void setUp() {<br />        objectUnderTest = new SomeBigPojoBuilder();<br />    }<br /><br />    @Test<br />    public void testCreateSomeBigPojoWithBuilder() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setBooleanField1(true)<br />                .setStringField0("1")<br />                .setStringField1("12")<br />                .setStringField2("123")<br />                .setStringField3("1234")<br />                .setStringField4("12345")<br />                .setStringField5("123456")<br />                .setStringField6("1234567")<br />                .setStringField7("12345678")<br />                .setStringField8("123456789")<br />                .setStringField9("1234567890")<br />                .createSomeBigPojoWithBuilder();<br /><br />        isPojoProperlyBuilt(someBigPojo);<br />    }<br /><br />    @Test(expected = AssertionError.class)<br />    public void testCreateSomeBigPojoWithBuilderWrongFields() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setStringField0("0")<br />                .setStringField1("too long")<br />                .createSomeBigPojoWithBuilder();<br /><br />        isPojoProperlyBuilt(someBigPojo);<br />    }<br /><br />    private void isPojoProperlyBuilt(SomeBigPojo someBigPojo) {<br />        isOfGivenLength(someBigPojo.getStringField0(), STRING_FIELD_0_LENGTH);<br />        isFieldOfNumericValue(someBigPojo.getStringField0());<br /><br />        isOfGivenLength(someBigPojo.getStringField1(), STRING_FIELD_1_LENGTH);<br />        isFieldOfNumericValue(someBigPojo.getStringField0());<br /><br />        isOfGivenLength(someBigPojo.getStringField2(), STRING_FIELD_2_LENGTH);<br />        isFieldOfNumericValue(someBigPojo.getStringField0());<br /><br />        isOfGivenLength(someBigPojo.getStringField3(), STRING_FIELD_3_LENGTH);<br />        isFieldOfNumericValue(someBigPojo.getStringField0());<br /><br />        isOfGivenLength(someBigPojo.getStringField4(), STRING_FIELD_4_LENGTH);<br />        isFieldOfNumericValue(someBigPojo.getStringField0());<br /><br />        isOfGivenLength(someBigPojo.getStringField5(), STRING_FIELD_5_LENGTH);<br /><br />        isOfGivenLength(someBigPojo.getStringField6(), STRING_FIELD_6_LENGTH);<br /><br />        isOfGivenLength(someBigPojo.getStringField7(), STRING_FIELD_7_LENGTH);<br /><br />        isOfGivenLength(someBigPojo.getStringField8(), STRING_FIELD_8_LENGTH);<br /><br />        isOfGivenLength(someBigPojo.getStringField9(), STRING_FIELD_9_LENGTH);<br /><br />    }<br /><br />    private void isOfGivenLength(String pojo, final Integer expectedLength) {<br />        assertNotNull(pojo);<br />        assertTrue(expectedLength == pojo.length());<br />    }<br /><br />    private void isFieldOfNumericValue(String field) {<br />        assertTrue(isNumeric(field));<br />    }<br />}<br /><br /></pre><br /><br />That looks nice, doesn't it? :) And how about using Matchers instead of functions? <br /><br /><b>SomeBigPojoBuilderTest.kava </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.builder;<br /><br />import org.hamcrest.BaseMatcher;<br />import org.hamcrest.Description;<br />import org.hamcrest.Matcher;<br />import org.junit.Before;<br />import org.junit.Test;<br />import pl.grzejszczak.marcin.junit.matchers.pojo.SomeBigPojo;<br /><br />import static java.lang.String.format;<br />import static junit.framework.Assert.assertTrue;<br />import static org.apache.commons.lang.StringUtils.isNumeric;<br />import static org.junit.Assert.assertThat;<br />import static pl.grzejszczak.marcin.junit.matchers.pojo.SomePojoConstants.*;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 23:02<br /> */<br />public class SomeBigPojoBuilderTest {<br /><br />    private SomeBigPojoBuilder objectUnderTest;<br /><br />    @Before<br />    public void setUp(){<br />        objectUnderTest = new SomeBigPojoBuilder();<br />    }<br /><br />    @Test<br />    public void testCreateSomeBigPojoWithBuilder() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setBooleanField1(true)<br />                .setStringField0("1")<br />                .setStringField1("12")<br />                .setStringField2("123")<br />                .setStringField3("1234")<br />                .setStringField4("12345")<br />                .setStringField5("123456")<br />                .setStringField6("1234567")<br />                .setStringField7("12345678")<br />                .setStringField8("123456789")<br />                .setStringField9("1234567890")<br />                .createSomeBigPojoWithBuilder();<br /><br />        assertThat(someBigPojo, isPojoProperlyBuilt());<br />    }<br /><br />    @Test(expected = AssertionError.class)<br />    public void testCreateSomeBigPojoWithBuilderWrongFields() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setStringField0("0")<br />                .setStringField1("Too long")<br />                .createSomeBigPojoWithBuilder();<br /><br />        assertThat(someBigPojo, isPojoProperlyBuilt());<br />    }<br /><br />    /**<br />     * Let us assume that there is a specific business case that we have to take into consideration regarding some particular field<br />     *<br />     * @return<br />     */<br />    private static Matcher isPojoProperlyBuilt() {<br /><br />        return new BaseMatcher() {<br /><br />            @Override<br />            public boolean matches(Object o) {<br />                assertTrue(o instanceof SomeBigPojo);<br />                SomeBigPojo someBigPojo = (SomeBigPojo) o;<br />                assertThat(someBigPojo.getStringField0(), isOfGivenLength(STRING_FIELD_0_LENGTH));<br />                assertThat(someBigPojo.getStringField0(), isFieldOfNumericValue());<br /><br />                assertThat(someBigPojo.getStringField1(), isOfGivenLength(STRING_FIELD_1_LENGTH));<br />                assertThat(someBigPojo.getStringField1(), isFieldOfNumericValue());<br /><br />                assertThat(someBigPojo.getStringField2(), isOfGivenLength(STRING_FIELD_2_LENGTH));<br />                assertThat(someBigPojo.getStringField2(), isFieldOfNumericValue());<br /><br />                assertThat(someBigPojo.getStringField3(), isOfGivenLength(STRING_FIELD_3_LENGTH));<br />                assertThat(someBigPojo.getStringField3(), isFieldOfNumericValue());<br /><br />                assertThat(someBigPojo.getStringField4(), isOfGivenLength(STRING_FIELD_4_LENGTH));<br />                assertThat(someBigPojo.getStringField4(), isFieldOfNumericValue());<br /><br />                assertThat(someBigPojo.getStringField5(), isOfGivenLength(STRING_FIELD_5_LENGTH));<br /><br />                assertThat(someBigPojo.getStringField6(), isOfGivenLength(STRING_FIELD_6_LENGTH));<br /><br />                assertThat(someBigPojo.getStringField7(), isOfGivenLength(STRING_FIELD_7_LENGTH));<br /><br />                assertThat(someBigPojo.getStringField8(), isOfGivenLength(STRING_FIELD_8_LENGTH));<br /><br />                assertThat(someBigPojo.getStringField9(), isOfGivenLength(STRING_FIELD_9_LENGTH));<br /><br />                return true;<br />            }<br /><br />            @Override<br />            public void describeTo(Description description) {<br />                description.appendText("Lengths of fields are limited and the first 4 fields are numeric");<br />            }<br />        };<br />    }<br /><br />    private static Matcher isOfGivenLength(final Integer expectedLength) {<br /><br />        return new BaseMatcher() {<br /><br />            public boolean matches(Object o) {<br />                assertTrue(o instanceof String);<br />                return expectedLength == String.valueOf(o).length();<br />            }<br /><br />            public void describeTo(Description description) {<br />                description.appendText(format("String's length should be equal to [%d]", expectedLength));<br />            }<br />        };<br />    }<br /><br />    private static Matcher isFieldOfNumericValue() {<br /><br />        return new BaseMatcher() {<br /><br />            public boolean matches(Object o) {<br />                assertTrue(o instanceof String);<br />                return isNumeric(String.valueOf(o));<br />            }<br /><br />            public void describeTo(Description description) {<br />                description.appendText("The value of the field should be numeric");<br />            }<br />        };<br />    }<br />}<br /><br /></pre><br />The following main method executes the functions of the Service:<br /><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers;<br /><br />import pl.grzejszczak.marcin.junit.matchers.builder.SomeBigPojoBuilder;<br />import pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 22:38<br /> */<br />public class MatcherMain {<br />    public static void main(String[] args){<br />        SomeServiceImpl someService = new SomeServiceImpl();<br /><br />        someService.setSomeBigPojoBuilder(new SomeBigPojoBuilder());<br />        someService.someLogicForAPojoWithoutBuilder();<br /><br />        someService.setSomeBigPojoBuilder(new SomeBigPojoBuilder());<br />        someService.someLogicForAPojoWithBuilder();<br /><br />        someService.setSomeBigPojoBuilder(new SomeBigPojoBuilder());<br />        someService.someLogicForAPojoWithBuilderBadArgument();<br />    }<br />}<br /><br /></pre><br />And the logs are:<br /><br /><br /><pre class="brush:xml">pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:27 SomeLogicForAPojoWithoutBuilder executed<br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:30 StringField8 is equal [value]<br /><br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:32 SomeBigPojo{stringField0='string', integerField0=1, booleanField0=false, stringField1='other string', integerField1=123, booleanField1=true, stringField2='something else', integerField2=321, booleanField2=false, stringField3='yet another string', integerField3=111, booleanField3=true, stringField4='something', integerField4=2, booleanField4=false, stringField5='More', integerField5=3, booleanField5=true, stringField6='String', integerField6=12, booleanField6=false, stringField7='some', stringField8='value', stringField9='ofString'}<br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:37 SomeLogicForAPojoWithBuilder executed<br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:65 StringField8 is equal [value]<br /><br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:67 SomeBigPojo{stringField0='string', integerField0=1, booleanField0=false, stringField1='other string', integerField1=123, booleanField1=true, stringField2='something else', integerField2=321, booleanField2=false, stringField3='yet another string', integerField3=111, booleanField3=false, stringField4='something', integerField4=2, booleanField4=false, stringField5='More', integerField5=3, booleanField5=true, stringField6='String', integerField6=12, booleanField6=false, stringField7='some', stringField8='value', stringField9='ofString'}<br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:72 someLogicForAPojoWithBuilderBadArgument executed<br />Exception in thread "main" java.lang.NullPointerException: StringField1 must not be null!<br /> at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:208)<br /> at pl.grzejszczak.marcin.junit.matchers.builder.SomeBigPojoBuilder.checkState(SomeBigPojoBuilder.java:166)<br /> at pl.grzejszczak.marcin.junit.matchers.builder.SomeBigPojoBuilder.createSomeBigPojoWithBuilder(SomeBigPojoBuilder.java:170)<br /> at pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl.someLogicForAPojoWithBuilderBadArgument(SomeServiceImpl.java:73)<br /> at pl.grzejszczak.marcin.junit.matchers.MatcherMain.main(MatcherMain.java:23)<br /> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br /> at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)<br /> at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)<br /> at java.lang.reflect.Method.invoke(Method.java:597)<br /> at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)</pre><br />In my opinion that looks really nice :) And what is yours?<br /><br /><a href="https://bitbucket.org/gregorin1987/too-much-coding/src/36becc07728e/Unit%20Testing%20-%20Matchers?at=default">Sources are available here at Too Much Codings code repository.</a><br /><br /><h2>UPDATE</h2><br />I've made some code changes and cleaning (not much though cause I didn't have too much time) and the code is available at github -&nbsp;<a href="https://github.com/marcingrzejszczak/too-much-coding/tree/master/Unit_Testing_-_Matchers">https://github.com/marcingrzejszczak/too-much-coding/tree/master/Unit_Testing_-_Matchers</a><br /><br /></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Guava Cache with regular expression patterns]]></title>
    <link href="http://toomuchcoding.com/blog/2012/12/24/google-guava-cache-with-regular/"/>
    <updated>2012-12-24T14:54:00+01:00</updated>
    <id>http://toomuchcoding.com/blog/2012/12/24/google-guava-cache-with-regular</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />Hi!  Merry Christmas everyone :)  Quite recently I've seen <a href="http://toomuchcoding.blogspot.com/2012/12/google-guava.html">a nice presentation about Google Guava</a> and we came to the conclusion in our project that it could be really interesting to use the <a href="http://code.google.com/p/guava-libraries/wiki/CachesExplained">its Cache functionallity</a>.  Let us take a look at the regexp Pattern class and its <a href="http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#compile(java.lang.String)">compile function</a>. Quite often in the code we can see that each time a regular expression is being used a programmer is repeatidly calling the aforementioned Pattern.compile() function with the same argument thus compiling the same regular expression over and over again. What could be done however is to cache the result of such compilations - let us take a look at the RegexpUtils utility class:<br /><br />
<!--more-->
<b>RegexpUtils.java </b><br /><b><br /></b><pre class="brush:java">package pl.grzejszczak.marcin.guava.cache.utils;<br /><br />import com.google.common.cache.CacheBuilder;<br />import com.google.common.cache.CacheLoader;<br />import com.google.common.cache.LoadingCache;<br /><br />import java.util.concurrent.ExecutionException;<br />import java.util.regex.Matcher;<br />import java.util.regex.Pattern;<br /><br />import static java.lang.String.format;<br /><br />public final class RegexpUtils {<br /><br />    private RegexpUtils() {<br />        throw new UnsupportedOperationException("RegexpUtils is a utility class - don't instantiate it!");<br />    }<br /><br />    private static final LoadingCache&lt;String, Pattern&gt; COMPILED_PATTERNS =<br />            CacheBuilder.newBuilder().build(new CacheLoader&lt;String, Pattern&gt;() {<br />                @Override<br />                public Pattern load(String regexp) throws Exception {<br />                    return Pattern.compile(regexp);<br />                }<br />            });<br /><br />    public static Pattern getPattern(String regexp) {<br />        try {<br />            return COMPILED_PATTERNS.get(regexp);<br />        } catch (ExecutionException e) {<br />            throw new RuntimeException(format("Error when getting a pattern [%s] from cache", regexp), e);<br />        }<br />    }<br /><br />    public static boolean matches(String stringToCheck, String regexp) {<br />        return doGetMatcher(stringToCheck, regexp).matches();<br />    }<br /><br />    public static Matcher getMatcher(String stringToCheck, String regexp) {<br />        return doGetMatcher(stringToCheck, regexp);<br />    }<br /><br />    private static Matcher doGetMatcher(String stringToCheck, String regexp) {<br />        Pattern pattern = getPattern(regexp);<br />        return pattern.matcher(stringToCheck);<br />    }<br /><br />}<br /><br /></pre>As you can see the Guava's LoadingCache with the CacheBuilder is being used to populate a cache with a new compiled pattern if one is not found. Due to caching the compiled pattern if a compilation has already taken place it will not be repeated ever again (in our case since we dno't have any expiry set).  Now a simple test<br /><br /><b>GuavaCache.java </b><br /><b><br /></b><pre class="brush:java">package pl.grzejszczak.marcin.guava.cache;<br /><br /><br />import com.google.common.base.Stopwatch;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import pl.grzejszczak.marcin.guava.cache.utils.RegexpUtils;<br /><br />import java.util.regex.Pattern;<br /><br />import static java.lang.String.format;<br /><br />public class GuavaCache {<br />    private static final Logger LOGGER = LoggerFactory.getLogger(GuavaCache.class);<br />    public static final String STRING_TO_MATCH = "something";<br /><br />    public static void main(String[] args) {<br />        runTestForManualCompilationAndOneUsingCache(1);<br />        runTestForManualCompilationAndOneUsingCache(10);<br />        runTestForManualCompilationAndOneUsingCache(100);<br />        runTestForManualCompilationAndOneUsingCache(1000);<br />        runTestForManualCompilationAndOneUsingCache(10000);<br />        runTestForManualCompilationAndOneUsingCache(100000);<br />        runTestForManualCompilationAndOneUsingCache(1000000);<br />    }<br /><br />    private static void runTestForManualCompilationAndOneUsingCache(int firstNoOfRepetitions) {<br />        repeatManualCompilation(firstNoOfRepetitions);<br />        repeatCompilationWithCache(firstNoOfRepetitions);<br />    }<br /><br />    private static void repeatManualCompilation(int noOfRepetitions) {<br />        Stopwatch stopwatch = new Stopwatch().start();<br />        compileAndMatchPatternManually(noOfRepetitions);<br />        LOGGER.debug(format("Time needed to compile and check regexp expression [%d] ms, no of iterations [%d]", stopwatch.elapsedMillis(), noOfRepetitions));<br />    }<br /><br />    private static void repeatCompilationWithCache(int noOfRepetitions) {<br />        Stopwatch stopwatch = new Stopwatch().start();<br />        compileAndMatchPatternUsingCache(noOfRepetitions);<br />        LOGGER.debug(format("Time needed to compile and check regexp expression using Cache [%d] ms, no of iterations [%d]", stopwatch.elapsedMillis(), noOfRepetitions));<br />    }<br /><br />    private static void compileAndMatchPatternManually(int limit) {<br />        for (int i = 0; i &lt; limit; i++) {<br />            Pattern.compile("something").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something1").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something2").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something3").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something4").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something5").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something6").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something7").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something8").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something9").matcher(STRING_TO_MATCH).matches();<br />        }<br />    }<br /><br /><br />    private static void compileAndMatchPatternUsingCache(int limit) {<br />        for (int i = 0; i &lt; limit; i++) {<br />            RegexpUtils.matches(STRING_TO_MATCH, "something");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something1");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something2");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something3");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something4");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something5");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something6");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something7");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something8");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something9");<br />        }<br />    }<br /><br />}<br /><br /></pre>We are running a series of tests and checking the time of their execution. Note that the results of these tests are not precise due to the fact that the application is not being run in isolation so numerous conditions can affect the time of the execution. We are interested in showing some degree of the problem rather than showing the precise execution time.  For a given number of iterations (1,10,100,1000,10000,100000,1000000) we are either compiling 10 regular expressions or using a Guava's cache to retrieve the compiled Pattern and then we match them against a string to match.  These are the logs: <br /><br /><pre class="brush:xml">pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [1] ms, no of iterations [1]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [35] ms, no of iterations [1]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [1] ms, no of iterations [10]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [0] ms, no of iterations [10]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [8] ms, no of iterations [100]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [3] ms, no of iterations [100]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [10] ms, no of iterations [1000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [10] ms, no of iterations [1000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [83] ms, no of iterations [10000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [33] ms, no of iterations [10000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [800] ms, no of iterations [100000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [279] ms, no of iterations [100000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [7562] ms, no of iterations [1000000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [3067] ms, no of iterations [1000000]<br /></pre><br />You can find the <a href="https://bitbucket.org/gregorin1987/too-much-coding/src">sources over here</a> under the Guava/Cache directory or go to the url <a href="https://bitbucket.org/gregorin1987/too-much-coding/src">https://bitbucket.org/gregorin1987/too-much-coding/src</a>  </div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Guava]]></title>
    <link href="http://toomuchcoding.com/blog/2012/12/07/google-guava/"/>
    <updated>2012-12-07T13:18:00+01:00</updated>
    <id>http://toomuchcoding.com/blog/2012/12/07/google-guava</id>
    <content type="html"><![CDATA[<div class='post'>
Some interesting link:<br /><br /><a href="http://tomaszdziurko.pl/2012/02/google-guava/">Very nice presentation about Google Guava</a>, <a href="https://github.com/tdziurko/Guava-Lessons">sources</a></div>

]]></content>
  </entry>
  
</feed>
