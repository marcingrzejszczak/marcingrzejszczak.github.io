<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Jaxb | TOO MUCH CODING]]></title>
  <link href="http://toomuchcoding.com/blog/categories/jaxb/atom.xml" rel="self"/>
  <link href="http://toomuchcoding.com/"/>
  <updated>2017-12-03T07:15:17-05:00</updated>
  <id>http://toomuchcoding.com/</id>
  <author>
    <name><![CDATA[Marcin Grzejszczak]]></name>
    <email><![CDATA[blog@toomuchcoding.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mockito - RETURNS_DEEP_STUBS for JAXB]]></title>
    <link href="http://toomuchcoding.com/blog/2013/06/08/mockito-returndeepstubs-for-jaxb/"/>
    <updated>2013-06-08T12:10:00-07:00</updated>
    <id>http://toomuchcoding.com/blog/2013/06/08/mockito-returndeepstubs-for-jaxb</id>
    <content type="html"><![CDATA[<div class='post'>
<br />Sorry for not having written for some time but I was busy with writing the JBoss Drools Refcard for DZone and I am in the middle of writing a book about Mockito so I don't have too much time left for blogging...<br />
<!--more-->
<br />Anyway quite recently on my current project I had an interesting situation regarding unit testing with Mockito and JAXB structures. We have very deeply nested JAXB structures generated from schemas that are provided for us which means that we can't change it in anyway.<br /><br /><a name='more'></a><br /><br />Let's take a look at the project structure:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-V5rYljCB5V4/UbN2mTKQ_QI/AAAAAAAABY8/C4WL8Tg-9b8/s1600/project_structure.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://1.bp.blogspot.com/-V5rYljCB5V4/UbN2mTKQ_QI/AAAAAAAABY8/C4WL8Tg-9b8/s320/project_structure.jpg" width="173" /></a></div><br />The project structure is pretty simple - there is a <b>Player.xsd</b> schema file that thanks to using the&nbsp;<b>jaxb2-maven-plugin</b>&nbsp;produces the generated JAXB Java classes corresponding to the schema in the <b>target/jaxb/</b> folder in the appropriate package that is defined in the <b>pom.xml</b>. Speaking of which let's take a look at the <b>pom.xml</b> file.<br /><br />The pom.xml :<br /><br /><pre class="brush:xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br /> xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br /> &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br /> &lt;groupId&gt;com.blogspot.toomuchcoding&lt;/groupId&gt;<br /> &lt;artifactId&gt;mockito-deep_stubs&lt;/artifactId&gt;<br /> &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br /><br /> &lt;properties&gt;<br />  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;<br />  &lt;maven.compiler.source&gt;1.6&lt;/maven.compiler.source&gt;<br />  &lt;maven.compiler.target&gt;1.6&lt;/maven.compiler.target&gt;<br /> &lt;/properties&gt;<br /> &lt;repositories&gt;<br />  &lt;repository&gt;<br />   &lt;id&gt;spring-release&lt;/id&gt;<br />   &lt;url&gt;http://maven.springframework.org/release&lt;/url&gt;<br />  &lt;/repository&gt;<br />  &lt;repository&gt;<br />   &lt;id&gt;maven-us-nuxeo&lt;/id&gt;<br />   &lt;url&gt;https://maven-us.nuxeo.org/nexus/content/groups/public&lt;/url&gt;<br />  &lt;/repository&gt;<br /> &lt;/repositories&gt;<br /><br /> &lt;dependencies&gt;<br />  &lt;dependency&gt;<br />   &lt;groupId&gt;junit&lt;/groupId&gt;<br />   &lt;artifactId&gt;junit&lt;/artifactId&gt;<br />   &lt;version&gt;4.10&lt;/version&gt;<br />  &lt;/dependency&gt;<br />  &lt;dependency&gt;<br />            &lt;groupId&gt;org.mockito&lt;/groupId&gt;<br />            &lt;artifactId&gt;mockito-all&lt;/artifactId&gt;<br />            &lt;version&gt;1.9.5&lt;/version&gt;<br />            &lt;scope&gt;test&lt;/scope&gt;<br />        &lt;/dependency&gt;<br /> &lt;/dependencies&gt;<br /> <br /> <br />    &lt;build&gt;<br />        &lt;pluginManagement&gt;<br />            &lt;plugins&gt;<br />                &lt;plugin&gt;<br />                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br />                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br />                    &lt;version&gt;2.5.1&lt;/version&gt;<br />                &lt;/plugin&gt;<br />            &lt;/plugins&gt;<br />        &lt;/pluginManagement&gt;<br />        &lt;plugins&gt;<br />            &lt;plugin&gt;<br />                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br />                &lt;artifactId&gt;jaxb2-maven-plugin&lt;/artifactId&gt;<br />                &lt;version&gt;1.5&lt;/version&gt;<br />                &lt;executions&gt;<br />                    &lt;execution&gt;<br />                        &lt;id&gt;xjc&lt;/id&gt;<br />                        &lt;goals&gt;<br />                            &lt;goal&gt;xjc&lt;/goal&gt;<br />                        &lt;/goals&gt;<br />                    &lt;/execution&gt;<br />                &lt;/executions&gt;<br />                &lt;configuration&gt;<br />                    &lt;packageName&gt;com.blogspot.toomuchcoding.model&lt;/packageName&gt;<br />                    &lt;schemaDirectory&gt;${project.basedir}/src/main/resources/xsd&lt;/schemaDirectory&gt;<br />                &lt;/configuration&gt;<br />            &lt;/plugin&gt;<br />        &lt;/plugins&gt;<br />    &lt;/build&gt;<br /><br />&lt;/project&gt;<br /><br /></pre>Apart from the previously defined project dependencies, as mentioned previously in the <b>jaxb2-maven-plugin</b>&nbsp;in the configuration node you can define the <b>packageName</b> value that defines to which package should the JAXB classes be generated basing on the <b>schemaDirectory</b> value where the plugin can find the proper schema files.<br /><br />Speaking of which let's check the <b>Player.xsd</b> schema file (simillar to the one that was present in the <a href="http://toomuchcoding.blogspot.com/2012/11/spring-jms-message-automatic-conversion.html">Spring JMS automatic message conversion article of mine</a>):<br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;<br /><br />    &lt;xsd:element name="PlayerDetails"&gt;<br />        &lt;xsd:complexType&gt;<br />            &lt;xsd:sequence&gt;<br />                &lt;xsd:element name="Name" type="xsd:string"/&gt;<br />                &lt;xsd:element name="Surname" type="xsd:string"/&gt;<br />                &lt;xsd:element name="Position" type="PositionType"/&gt;<br />                &lt;xsd:element name="Age" type="xsd:int"/&gt;<br />                &lt;xsd:element name="ClubDetails" type="ClubDetails"/&gt;<br />            &lt;/xsd:sequence&gt;<br />        &lt;/xsd:complexType&gt;<br />    &lt;/xsd:element&gt;<br /><br />    &lt;xsd:complexType name="ClubDetails"&gt;<br />        &lt;xsd:sequence&gt;<br />            &lt;xsd:element name="TeamName" type="xsd:string"/&gt;<br />            &lt;xsd:element name="Country" type="CountryDetails"/&gt;<br />        &lt;/xsd:sequence&gt;<br />    &lt;/xsd:complexType&gt;<br /><br />    &lt;xsd:complexType name="CountryDetails"&gt;<br />        &lt;xsd:sequence&gt;<br />            &lt;xsd:element name="CountryName" type="xsd:string"/&gt;<br />            &lt;xsd:element name="CountryCode" type="CountryCodeDetails"/&gt;<br />        &lt;/xsd:sequence&gt;<br />    &lt;/xsd:complexType&gt;<br /><br />    &lt;xsd:complexType name="CountryCodeDetails"&gt;<br />        &lt;xsd:sequence&gt;<br />            &lt;xsd:element name="CountryName" type="xsd:string"/&gt;<br />            &lt;xsd:element name="CountryCode" type="CountryCodeType"/&gt;<br />        &lt;/xsd:sequence&gt;<br />    &lt;/xsd:complexType&gt;<br /><br />    &lt;xsd:simpleType name="CountryCodeType"&gt;<br />        &lt;xsd:restriction base="xsd:string"&gt;<br />            &lt;xsd:enumeration value="PL"/&gt;<br />            &lt;xsd:enumeration value="GER"/&gt;<br />            &lt;xsd:enumeration value="FRA"/&gt;<br />            &lt;xsd:enumeration value="ENG"/&gt;<br />            &lt;xsd:enumeration value="ESP"/&gt;<br />        &lt;/xsd:restriction&gt;<br />    &lt;/xsd:simpleType&gt;<br /><br />    &lt;xsd:simpleType name="PositionType"&gt;<br />        &lt;xsd:restriction base="xsd:string"&gt;<br />            &lt;xsd:enumeration value="GK"/&gt;<br />            &lt;xsd:enumeration value="DEF"/&gt;<br />            &lt;xsd:enumeration value="MID"/&gt;<br />            &lt;xsd:enumeration value="ATT"/&gt;<br />        &lt;/xsd:restriction&gt;<br />    &lt;/xsd:simpleType&gt;<br /><br />&lt;/xsd:schema&gt;<br /></pre><br />As you can see I'm defining some complex types that even though might have no business sense but you can find such examples in the real life :)<br /><br />Let's find out how the method that we would like to test looks like. Here we have the <b>PlayerServiceImpl</b> that implements the <b>PlayerService</b> interface:<br /><br /><pre class="brush:java">package com.blogspot.toomuchcoding.service;<br /><br />import com.blogspot.toomuchcoding.model.PlayerDetails;<br /><br />/**<br /> * User: mgrzejszczak<br /> * Date: 08.06.13<br /> * Time: 19:02<br /> */<br />public class PlayerServiceImpl implements PlayerService {<br />    @Override<br />    public boolean isPlayerOfGivenCountry(PlayerDetails playerDetails, String country) {<br />        String countryValue = playerDetails.getClubDetails().getCountry().getCountryCode().getCountryCode().value();<br />        return countryValue.equalsIgnoreCase(country);<br />    }<br />}<br /></pre><br />We are getting the nested elements from the JAXB generated classes. Although it violates the <a href="http://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter</a>&nbsp;it is quite common to call methods of <b>structures</b>&nbsp;because JAXB generated classes are in fact structures so in fact I fully agree with <a href="http://martinfowler.com/articles/mocksArentStubs.html">Martin Fowler that it should be called the Suggestion of Demeter</a>. Anyway let's see how you could test the method:<br /><br /><pre class="brush:java">    @Test<br />    public void shouldReturnTrueIfCountryCodeIsTheSame() throws Exception {<br />        //given<br />        PlayerDetails playerDetails = new PlayerDetails();<br />        ClubDetails clubDetails = new ClubDetails();<br />        CountryDetails countryDetails = new CountryDetails();<br />        CountryCodeDetails countryCodeDetails = new CountryCodeDetails();<br />        playerDetails.setClubDetails(clubDetails);<br />        clubDetails.setCountry(countryDetails);<br />        countryDetails.setCountryCode(countryCodeDetails);<br />        countryCodeDetails.setCountryCode(CountryCodeType.ENG);<br /><br />        //when<br />        boolean playerOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetails, COUNTRY_CODE_ENG);<br /><br />        //then<br />        assertThat(playerOfGivenCountry, is(true));<br />    }<br /></pre>The function checks if, once you have the same Country Code, you get a true boolean from the method. The only problem is the amount of sets and instantiations that take place when you want to create the input message. In our projects we have twice as many nested elements so you can only imagine the number of code that we would have to produce to create the input object...<br /><br />So what can be done to improve this code? Mockito comes to the rescue to together with the <b>RETURN_DEEP_STUBS</b> default answer to the <b><a href="http://docs.mockito.googlecode.com/hg/org/mockito/Mockito.html#mock(java.lang.Class, org.mockito.stubbing.Answer)">Mockito.mock(...)</a></b> method:<br /><br /><pre class="brush:java">  @Test<br />    public void shouldReturnTrueIfCountryCodeIsTheSameUsingMockitoReturnDeepStubs() throws Exception {<br />        //given<br />        PlayerDetails playerDetailsMock = mock(PlayerDetails.class, RETURNS_DEEP_STUBS);<br />        CountryCodeType countryCodeType = CountryCodeType.ENG;<br />        when(playerDetailsMock.getClubDetails().getCountry().getCountryCode().getCountryCode()).thenReturn(countryCodeType);<br /><br />        //when<br />        boolean playerOfGivenCountry = objectUnderTest.isPlayerOfGivenCountry(playerDetailsMock, COUNTRY_CODE_ENG);<br /><br />        //then<br />        assertThat(playerOfGivenCountry, is(true));<br />    }<br /></pre>So what happened here is that you use the <b>Mockito.mock(...)</b> method and provide the <b>RETURNS_DEEP_STUBS</b> answer that will create mocks automatically for you. Mind you that Enums can't be mocked that's why you can't write in the <b>Mockito.when(...)</b> function <b>playerDetailsMock.getClubDetails().getCountry().getCountryCode().getCountryCode().getValue()</b>.<br /><br />Summing it up you can compare the readability of both tests and see how clearer it is to work with JAXB structures by using Mockito <b>RETURNS_DEEP_STUBS</b> default answer.<br /><br />Naturally sources for this example are available at <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/fc1bc010cf16e1f6477391f54e83f8ad446f7608/Unit%20Testing/Mockito%20-%20Deep%20Stubs?at=default">BitBucket</a> and <a href="https://github.com/marcingrzejszczak/too-much-coding/tree/master/Unit%20Testing/Mockito%20-%20Deep%20Stubs">GitHub</a>.<br /><br /><br /></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apache Camel With Spring, Routing With Enrichment Service]]></title>
    <link href="http://toomuchcoding.com/blog/2012/11/22/apache-camel-with-spring-routing-with/"/>
    <updated>2012-11-22T14:13:00-08:00</updated>
    <id>http://toomuchcoding.com/blog/2012/11/22/apache-camel-with-spring-routing-with</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />Sorry for not having posted anything in some time but I had plenty of work. Anyway today I will continue the example with JMS that I've shown you some time ago.<br />
<!--more-->
<br />The idea of the previous example was to simplify the work that we had to do in a manual way - we've sed JmsTemplate and Spring listener containers. The routing as such unfortunately was still done by us. In order to facilitate this process we can use <a href="http://camel.apache.org/">Apache Camel</a>.<br /><br />The following example bases on the one that we've seen in this post&nbsp;<a href="http://toomuchcoding.blogspot.com/2012/11/spring-jms-message-automatic-conversion.html">Spring JMS, message automatic conversion, JMS template</a>&nbsp;but with slight modifications:<br /><br /><b>CamelRouter.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel;<br /><br />import org.apache.camel.spring.Main;<br /><br />public class CamelRouter {<br /><br /> /**<br />  * @param args<br />  * @throws Exception<br />  */<br /> public static void main(String[] args) throws Exception {<br />  Main main = new Main();<br />  main.setApplicationContextUri("/camel/camelContext.xml");<br />  main.run(args);<br /> }<br /><br />}<br /><br /><br /></pre>What we can see here is the usage of the Camel's <span style="font-family: Courier New, Courier, monospace;">Main</span> class which you can reuse to more easily boot up Camel and keep it running until the JVM terminate. <br /><br />Then we have a new file <span style="font-family: Courier New, Courier, monospace;">camelContext.xml</span> in which we have the Camel context in the Spring configuration file.<br /><br /><b>camelContext.xml</b><br /><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans" <br /> xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br /> xsi:schemaLocation="http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd "&gt;<br /> <br /> &lt;import resource="classpath:/camel/jmsApplicationContext.xml" /&gt;<br /> <br /> &lt;camel:camelContext id="camel" xmlns:camel="http://camel.apache.org/schema/spring"&gt;<br />  &lt;camel:dataFormats&gt;<br />   &lt;camel:jaxb id="jaxb" prettyPrint="true" contextPath="pl.grzejszczak.marcin.camel.jaxb.generated" /&gt;<br />  &lt;/camel:dataFormats&gt;<br /><br />  &lt;camel:route&gt;<br />   &lt;camel:from uri="activemq:topic:Initial.Topic" /&gt;<br />   &lt;camel:unmarshal ref="jaxb" /&gt;<br />   &lt;camel:bean ref="enrichingService" /&gt;<br />   &lt;camel:marshal ref="jaxb" /&gt;<br />   &lt;camel:to uri="activemq:topic:Routed.Topic" /&gt;<br />  &lt;/camel:route&gt;<br /><br /> &lt;/camel:camelContext&gt;<br />&lt;/beans&gt;<br /></pre><br />We are defining in this file in order to create a Camel Route - from the activemq topic called <i>Initial.Topic</i> to the one called <i>Routed.Topic</i>. In the meantime we are doing some unmarshalling and marshalling by means of Jaxb.<br /><br />In the jmsApplicationContext we no longer define the sender to the final topic: <i>Routed.Topic</i>.<br /><br /><b>jmsApplicationContext.java</b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br /> xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"<br /> xmlns:jms="http://www.springframework.org/schema/jms" xmlns:oxm="http://www.springframework.org/schema/oxm"<br /> xsi:schemaLocation="http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-3.0.xsd http://www.springframework.org/schema/oxm http://www.springframework.org/schema/oxm/spring-oxm-3.0.xsd"&gt;<br /><br /> &lt;!-- Spring configuration based on annotations --&gt;<br /> &lt;context:annotation-config /&gt;<br /> &lt;!-- Show Spring where to search for the beans (in which packages) --&gt;<br /> &lt;context:component-scan base-package="pl.grzejszczak.marcin.camel" /&gt;<br /> <br /> &lt;!-- Show Spring where to search for the properties files --&gt;<br /> &lt;context:property-placeholder location="classpath:/camel/jms.properties" /&gt;<br /><br /> &lt;!-- The ActiveMQ connection factory with specification of the server URL --&gt;<br /> &lt;bean id="activeMQConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;<br />  &lt;property name="brokerURL" value="tcp://localhost:61616" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Spring's jms connection factory --&gt;<br /> &lt;bean id="cachingConnectionFactory"<br />  class="org.springframework.jms.connection.CachingConnectionFactory"&gt;<br />  &lt;property name="targetConnectionFactory" ref="activeMQConnectionFactory" /&gt;<br />  &lt;property name="sessionCacheSize" value="10" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- The name of the queue from which we will take the messages --&gt;<br /> &lt;bean id="origin" class="org.apache.activemq.command.ActiveMQTopic"&gt;<br />  &lt;constructor-arg value="${jms.origin}" /&gt;<br /> &lt;/bean&gt;<br /> &lt;!-- The name of the queue to which we will route the messages --&gt;<br /> &lt;bean id="destination" class="org.apache.activemq.command.ActiveMQTopic"&gt;<br />  &lt;constructor-arg value="${jms.destination}" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Configuration of the JmsTemplate together with the connection factory and the message converter --&gt;<br /> &lt;bean id="producerTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;<br />  &lt;property name="connectionFactory" ref="cachingConnectionFactory" /&gt;<br />  &lt;property name="messageConverter" ref="oxmMessageConverter" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Custom message sender sending messages to the initial queue --&gt;<br /> &lt;bean id="originPlayerSender" class="pl.grzejszczak.marcin.camel.manual.jms.PlayerDetailsSenderImpl"&gt;<br />  &lt;property name="destination" ref="origin" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Custom message listener - listens to the destination queue  --&gt;<br /> &lt;bean id="destinationListenerImpl" class="pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl"/&gt;<br /><br /> <br /> &lt;!-- Spring's jms message listener container - specified the connection factory, the queue to be listened to and the component that listens to the queue --&gt;<br /> &lt;bean id="jmsDestinationContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;<br />  &lt;property name="connectionFactory" ref="cachingConnectionFactory" /&gt;<br />  &lt;property name="destination" ref="destination" /&gt;<br />  &lt;property name="messageListener" ref="destinationListenerImpl" /&gt;<br /> &lt;/bean&gt;<br /> <br /> &lt;!-- Message converter - automatically marshalls and unmarshalls messages using the provided marshaller / unmarshaller--&gt;<br /> &lt;bean id="oxmMessageConverter" class="org.springframework.jms.support.converter.MarshallingMessageConverter"&gt;<br />          &lt;property name="marshaller" ref="marshaller" /&gt;<br />          &lt;property name="unmarshaller" ref="marshaller" /&gt;<br />     &lt;/bean&gt;<br /><br /> &lt;bean id="enrichingService" class="pl.grzejszczak.marcin.camel.service.EnrichingServiceImpl"/&gt;<br /><br /> &lt;!-- Spring's JAXB implementation of marshaller - provided a class the JAXB generated class --&gt;<br />     &lt;oxm:jaxb2-marshaller id="marshaller"&gt;<br />          &lt;oxm:class-to-be-bound name="pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails" /&gt;<br />     &lt;/oxm:jaxb2-marshaller&gt;<br /><br />&lt;/beans&gt;<br /><br /></pre>Once we have already initialized our camel context, what we need to do is to send a message to the <i>Initial.Topic</i>. We are doing it by means of our modified <span style="font-family: Courier New, Courier, monospace;">ActiveMQRouter</span> class.<br /><br /><b>ActiveMQRouter.java</b><br /><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel.manual;<br /><br />import java.io.File;<br />import java.util.Scanner;<br /><br />import javax.jms.JMSException;<br /><br />import org.springframework.context.ApplicationContext;<br />import org.springframework.context.support.ClassPathXmlApplicationContext;<br />import org.springframework.core.io.ClassPathResource;<br />import org.springframework.core.io.Resource;<br /><br />import pl.grzejszczak.marcin.camel.jaxb.PlayerDetailsConverter;<br />import pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails;<br />import pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl;<br />import pl.grzejszczak.marcin.camel.manual.jms.Sender;<br /><br />public class ActiveMQRouter {<br /><br /> /**<br />  * @param args<br />  * @throws JMSException<br />  */<br /> public static void main(String[] args) throws Exception {<br />  ApplicationContext context = new ClassPathXmlApplicationContext("/camel/jmsApplicationContext.xml");<br />  @SuppressWarnings("unchecked")<br />  Sender&lt;PlayerDetails&gt; sender = (Sender&lt;PlayerDetails&gt;) context.getBean("originPlayerSender");<br /><br />  Resource resource = new ClassPathResource("/camel/RobertLewandowski.xml");<br /><br />  Scanner scanner = new Scanner(new File(resource.getURI())).useDelimiter("\\Z");<br />  String contents = scanner.next();<br /><br />  PlayerDetailsConverter converter = context.getBean(PlayerDetailsConverter.class);<br /><br />  FinalListenerImpl listener = (FinalListenerImpl) context.getBean("finalListenerImpl");<br /><br />  sender.sendMessage(converter.unmarshal(contents));<br /> }<br />}<br /><br /></pre>The class is reading the file and sending it to the initial topic. We also initialize a FinalListenerImpl - a class that will listen to the messages coming to the final topic - to prove that everything is working correctly.<br /><br />That's it! Now let's check out the logs. Logs of CamelRouter:<br /><br /><br /><pre class="brush:xml">2012-11-22 22:51:39,429 INFO  [main] org.apache.camel.main.MainSupport:300 Apache Camel 2.9.2 starting<br />2012-11-22 22:51:40,028 INFO  [main] org.springframework.context.support.ClassPathXmlApplicationContext:495 Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@4c5e176f: startup date [Thu Nov 22 22:51:40 CET 2012]; root of context hierarchy<br />2012-11-22 22:51:40,213 INFO  [main] org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [camel/camelContext.xml]<br />2012-11-22 22:51:40,746 INFO  [main] org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [camel/jmsApplicationContext.xml]<br />2012-11-22 22:51:41,120 INFO  [main] org.springframework.context.annotation.ClassPathBeanDefinitionScanner:210 JSR-330 'javax.inject.Named' annotation found and supported for component scanning<br />2012-11-22 22:51:43,219 INFO  [main] org.springframework.beans.factory.config.PropertyPlaceholderConfigurer:177 Loading properties file from class path resource [camel/jms.properties]<br />2012-11-22 22:51:43,233 INFO  [main] org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor:139 JSR-330 'javax.inject.Inject' annotation found and supported for autowiring<br />2012-11-22 22:51:43,274 INFO  [main] org.springframework.beans.factory.support.DefaultListableBeanFactory:557 Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@19d03a4e: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,AgeEnricher,ClubEnricher,PlayerDetailsConverter,finalListenerImpl,playerDetailsSenderImpl,org.springframework.beans.factory.config.PropertyPlaceholderConfigurer#0,activeMQConnectionFactory,cachingConnectionFactory,origin,destination,producerTemplate,originPlayerSender,destinationListenerImpl,jmsDestinationContainer,oxmMessageConverter,enrichingService,marshaller,template,consumerTemplate,camel:beanPostProcessor,camel,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy<br />2012-11-22 22:51:43,424 INFO  [main] org.springframework.oxm.jaxb.Jaxb2Marshaller:436 Creating JAXBContext with classes to be bound [class pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails]<br />2012-11-22 22:51:44,521 INFO  [main] org.springframework.context.support.DefaultLifecycleProcessor:334 Starting beans in phase 2147483647<br />2012-11-22 22:51:45,061 INFO  [main] org.springframework.jms.connection.CachingConnectionFactory:291 Established shared JMS Connection: ActiveMQConnection {id=ID:marcin-SR700-47684-1353621104666-1:1,clientId=null,started=false}<br />2012-11-22 22:51:45,608 INFO  [main] org.apache.camel.spring.SpringCamelContext:1374 Apache Camel 2.9.2 (CamelContext: camel) is starting<br />2012-11-22 22:51:45,611 INFO  [main] org.apache.camel.management.ManagementStrategyFactory:38 JMX enabled. Using ManagedManagementStrategy.<br />2012-11-22 22:51:45,850 INFO  [main] org.apache.camel.management.DefaultManagementLifecycleStrategy:790 StatisticsLevel at All so enabling load performance statistics<br />2012-11-22 22:51:45,961 INFO  [main] org.apache.camel.impl.converter.AnnotationTypeConverterLoader:119 Found 3 packages with 15 @Converter classes to load<br />2012-11-22 22:51:45,995 INFO  [main] org.apache.camel.impl.converter.DefaultTypeConverter:405 Loaded 170 core type converters (total 170 type converters)<br />2012-11-22 22:51:46,002 INFO  [main] org.apache.camel.impl.converter.AnnotationTypeConverterLoader:109 Loaded 2 @Converter classes<br />2012-11-22 22:51:46,023 INFO  [main] org.apache.camel.impl.converter.AnnotationTypeConverterLoader:119 Found 1 packages with 1 @Converter classes to load<br />2012-11-22 22:51:46,024 WARN  [main] org.apache.camel.impl.converter.DefaultTypeConverter:257 Overriding type converter from: StaticMethodTypeConverter: public static org.apache.activemq.command.ActiveMQDestination org.apache.camel.component.activemq.ActiveMQConverter.toDestination(java.lang.String) to: StaticMethodTypeConverter: public static org.apache.activemq.command.ActiveMQDestination org.apache.activemq.camel.converter.ActiveMQConverter.toDestination(java.lang.String)<br />2012-11-22 22:51:46,043 INFO  [main] org.apache.camel.impl.converter.DefaultTypeConverter:431 Loaded additional 3 type converters (total 173 type converters) in 0.041 seconds<br />2012-11-22 22:51:46,360 INFO  [main] org.apache.camel.converter.jaxb.JaxbDataFormat:277 Creating JAXBContext with contextPath: pl.grzejszczak.marcin.camel.jaxb.generated and ApplicationContextClassLoader: sun.misc.Launcher$AppClassLoader@35a16869<br />2012-11-22 22:51:46,500 INFO  [main] org.apache.camel.spring.SpringCamelContext:1980 Route: route1 started and consuming from: Endpoint[activemq://topic:Initial.Topic]<br />2012-11-22 22:51:46,509 INFO  [main] org.apache.camel.spring.SpringCamelContext:1409 Total 1 routes, of which 1 is started.<br />2012-11-22 22:51:46,510 INFO  [main] org.apache.camel.spring.SpringCamelContext:1410 Apache Camel 2.9.2 (CamelContext: camel) started in 0.901 seconds<br />2012-11-22 22:51:46,519 INFO  [main] org.springframework.context.support.DefaultLifecycleProcessor:334 Starting beans in phase 2147483647<br />2012-11-22 22:52:08,375 DEBUG [Camel (camel) thread #1 - JmsConsumer[Initial.Topic]] pl.grzejszczak.marcin.camel.service.EnrichingServiceImpl:21 Enriching player details<br />2012-11-22 22:52:08,377 DEBUG [Camel (camel) thread #1 - JmsConsumer[Initial.Topic]] pl.grzejszczak.marcin.camel.enricher.AgeEnricher:17 Enriching player [Lewandowski] with age data<br />2012-11-22 22:52:10,379 DEBUG [Camel (camel) thread #1 - JmsConsumer[Initial.Topic]] pl.grzejszczak.marcin.camel.enricher.ClubEnricher:16 Enriching player [Lewandowski] with club data<br />2012-11-22 22:52:12,462 DEBUG [jmsDestinationContainer-1] pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl:35 Message already enriched! Shutting down the system<br /><br /></pre>We can see that the Camel Context has been initialized and then the bean that we have created in the <span style="font-family: Courier New, Courier, monospace;">jmsApplicationContext.xml</span> that is listening to the final destination is acknowledging that the message has been enriched properly.<br /><br />What about the <span style="font-family: Courier New, Courier, monospace;">ActiveMQRouter.java</span> logs?<br /><br /><br /><pre class="brush:xml">2012-11-22 22:52:06,077 INFO  [main] org.springframework.context.support.ClassPathXmlApplicationContext:495 Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@43462851: startup date [Thu Nov 22 22:52:06 CET 2012]; root of context hierarchy<br />2012-11-22 22:52:06,153 INFO  [main] org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [camel/jmsApplicationContext.xml]<br />2012-11-22 22:52:06,417 INFO  [main] org.springframework.context.annotation.ClassPathBeanDefinitionScanner:210 JSR-330 'javax.inject.Named' annotation found and supported for component scanning<br />2012-11-22 22:52:06,721 INFO  [main] org.springframework.beans.factory.config.PropertyPlaceholderConfigurer:177 Loading properties file from class path resource [camel/jms.properties]<br />2012-11-22 22:52:06,733 INFO  [main] org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor:139 JSR-330 'javax.inject.Inject' annotation found and supported for autowiring<br />2012-11-22 22:52:06,758 INFO  [main] org.springframework.beans.factory.support.DefaultListableBeanFactory:557 Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@362f0d54: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,AgeEnricher,ClubEnricher,PlayerDetailsConverter,finalListenerImpl,playerDetailsSenderImpl,org.springframework.beans.factory.config.PropertyPlaceholderConfigurer#0,activeMQConnectionFactory,cachingConnectionFactory,origin,destination,producerTemplate,originPlayerSender,destinationListenerImpl,jmsDestinationContainer,oxmMessageConverter,enrichingService,marshaller,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy<br />2012-11-22 22:52:07,224 INFO  [main] org.springframework.oxm.jaxb.Jaxb2Marshaller:436 Creating JAXBContext with classes to be bound [class pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails]<br />2012-11-22 22:52:07,628 INFO  [main] org.springframework.context.support.DefaultLifecycleProcessor:334 Starting beans in phase 2147483647<br />2012-11-22 22:52:07,883 INFO  [main] org.springframework.jms.connection.CachingConnectionFactory:291 Established shared JMS Connection: ActiveMQConnection {id=ID:marcin-SR700-53586-1353621127755-1:1,clientId=null,started=false}<br />2012-11-22 22:52:08,093 DEBUG [main] pl.grzejszczak.marcin.camel.manual.jms.PlayerDetailsSenderImpl:26 Sending [pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails@3ea86d12] to topic [topic://Initial.Topic]<br />2012-11-22 22:52:12,463 DEBUG [jmsDestinationContainer-1] pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl:35 Message already enriched! Shutting down the system<br /><br /></pre>First we see that our spring Context has been initialized and then we see that a message has been sent to the <i>Initial.Topic</i>. At the end of the processing we can see that the listener is confirming that the message has been properly enriched - so all the Camel work has been done in a proper way.<br /><br />This example is showing how easy and simple it can be to create a routing / enriching service by means of Spring and Camel (integrated with Spring).<br /><br />The sources are available at <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/26b70bca3b44e37c20c627e0efe4644d28f8d468/Camel%20and%20Spring?at=default">Too Much Coding's repository at bitbucket</a>.<br /><br /></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring JMS, Message Automatic Conversion, JMS Template]]></title>
    <link href="http://toomuchcoding.com/blog/2012/11/04/spring-jms-message-automatic-conversion/"/>
    <updated>2012-11-04T17:29:00-08:00</updated>
    <id>http://toomuchcoding.com/blog/2012/11/04/spring-jms-message-automatic-conversion</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />Hi!<br /><br />In one of my projects I was supposed to create a message router that like all routers was supposed to take the JMS messages from one topic and put it into another one. The message itself was a JMS text message that in fact contained an XML message. What is more after having received it I was supposed to enrich the message with some additional data.<br />
<!--more-->
<br />We were not allowed to use neither Spring nor JAXB nor any other useful library so I decided to check how easy it would be to do it using them. Initially I wanted to use only Spring and JAXB but in the next post I will try to repeat the same scenario by using Apache Camel (that's why you will find the word "camel" in the package name). The JMS communication was present thanks to the ActiveMQ messaging server.<br /><br />Anyway coming back to the code.<br /><br />I used maven to resolve dependencies and these are the dependencies that were mandatory i n terms of JMS and JAXB and message conversion:<br /><br /><b>pom.xml</b><br /><br /><pre class="brush:xml">  &lt;dependency&gt;<br />   &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />   &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;<br />   &lt;version&gt;3.1.1.RELEASE&lt;/version&gt;<br />  &lt;/dependency&gt;<br />  &lt;dependency&gt;<br />   &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt;<br />   &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt;<br />   &lt;version&gt;2.2.6&lt;/version&gt;<br />  &lt;/dependency&gt;<br />  &lt;dependency&gt;<br />   &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />   &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;<br />   &lt;version&gt;3.1.1.RELEASE&lt;/version&gt;<br />  &lt;/dependency&gt;<br /></pre><br /><br />This is how I divided the project (the camel part of the package will make more sense in the next article).<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-iNFJ6Htvx0Q/UJgnuxzQ2hI/AAAAAAAAAIQ/nBmCjDUaKfc/s1600/JMS.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://2.bp.blogspot.com/-iNFJ6Htvx0Q/UJgnuxzQ2hI/AAAAAAAAAIQ/nBmCjDUaKfc/s320/JMS.png" width="195" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><br />In order to have my message converted to objects via JAXB I needed a schema:<br /><br /><b>Player.xsd</b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;<br /><br /> &lt;xsd:element name="PlayerDetails"&gt;<br />  &lt;xsd:complexType&gt;<br />   &lt;xsd:sequence&gt;<br />    &lt;xsd:element name="Name" type="xsd:string" /&gt;<br />    &lt;xsd:element name="Surname" type="xsd:string" /&gt;<br />    &lt;xsd:element name="Position" type="PositionType" /&gt;<br />    &lt;xsd:element name="Age" type="xsd:int" /&gt;<br />    &lt;xsd:element name="TeamName" type="xsd:string" /&gt;<br />   &lt;/xsd:sequence&gt;<br />  &lt;/xsd:complexType&gt;<br /> &lt;/xsd:element&gt;<br /><br /><br /> &lt;xsd:simpleType name="PositionType"&gt;<br />  &lt;xsd:restriction base="xsd:string"&gt;<br />   &lt;xsd:enumeration value="GK" /&gt;<br />   &lt;xsd:enumeration value="DEF" /&gt;<br />   &lt;xsd:enumeration value="MID" /&gt;<br />   &lt;xsd:enumeration value="ATT" /&gt;<br />  &lt;/xsd:restriction&gt;<br /> &lt;/xsd:simpleType&gt;<br /><br />&lt;/xsd:schema&gt;<br /></pre><br />I had to download JAXB binaries and executed the following command to have my objects created:<br /><br /><pre class="brush:xml">./xjc.sh -p pl.grzejszczak.marcin.camel.jaxb.generated ~/PATH/TO/THE/SCHEMA/FILE/Player.xsd</pre><br /><b style="text-decoration: underline;">Note: </b>The same you can achieve by using maven. This approach is not in the blog's repository but believe me - it does work :D<br /><br />Add dependency to pom<br /><br /><pre class="brush:xml">&lt;dependency&gt;<br />    &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;<br />&nbsp; &nbsp; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;<br />&nbsp; &nbsp; &lt;version&gt;2.1&lt;/version&gt;<br />&lt;/dependency&gt;</pre><br /><br />Use the plugin (mind that the schema file needs to be specified or by default is searched for at <span style="font-family: Courier New, Courier, monospace;">src/main/xsd/</span> folder)<br /><br /><br /><pre class="brush:xml">&lt;build&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &lt;pluginManagement&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;plugins&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;plugin&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;version&gt;2.5.1&lt;/version&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/plugin&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/plugins&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &lt;/pluginManagement&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &lt;plugins&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;plugin&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;artifactId&gt;jaxb2-maven-plugin&lt;/artifactId&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;version&gt;1.5&lt;/version&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;executions&gt;<br />  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;execution&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;id&gt;xjc&lt;/id&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;goals&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;goal&gt;xjc&lt;/goal&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/goals&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/execution&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/executions&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;configuration&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;packageName&gt;pl.grzejszczak.marcin.camel.jaxb.generated&lt;/packageName&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/configuration&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/plugin&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &lt;/plugins&gt;<br />&nbsp; &nbsp; &lt;/build&gt;</pre><br />An example of the outcome of this command or maven plugin is the following:<br /><br /><b>PlayerDetails.java</b><br /><br /><pre class="brush:java">//<br />// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.6 <br />// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> <br />// Any modifications to this file will be lost upon recompilation of the source schema. <br />// Generated on: 2012.11.05 at 09:23:22 PM CET <br />//<br /><br /><br />package pl.grzejszczak.marcin.camel.jaxb.generated;<br /><br />import javax.xml.bind.annotation.XmlAccessType;<br />import javax.xml.bind.annotation.XmlAccessorType;<br />import javax.xml.bind.annotation.XmlElement;<br />import javax.xml.bind.annotation.XmlRootElement;<br />import javax.xml.bind.annotation.XmlType;<br /><br /><br />/**<br /> * Java class for anonymous complex type.<br /> * <br /> * <br /><br />The following schema fragment specifies the expected content contained within this class.<br /> * <br /> * <br /><br /><pre> * &lt;complexType&gt;<br /> *   &lt;complexContent&gt;<br /> *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;<br /> *       &lt;sequence&gt;<br /> *         &lt;element name="Name" type="{http://www.w3.org/2001/XMLSchema}string"/&gt;<br /> *         &lt;element name="Surname" type="{http://www.w3.org/2001/XMLSchema}string"/&gt;<br /> *         &lt;element name="Position" type="{}PositionType"/&gt;<br /> *         &lt;element name="Age" type="{http://www.w3.org/2001/XMLSchema}int"/&gt;<br /> *         &lt;element name="TeamName" type="{http://www.w3.org/2001/XMLSchema}string"/&gt;<br /> *       &lt;/sequence&gt;<br /> *     &lt;/restriction&gt;<br /> *   &lt;/complexContent&gt;<br /> * &lt;/complexType&gt;<br /> * </pre>*   *   */ @XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = "", propOrder = {     "name",     "surname",     "position",     "age",     "teamName" }) @XmlRootElement(name = "PlayerDetails") public class PlayerDetails {      @XmlElement(name = "Name", required = true)     protected String name;     @XmlElement(name = "Surname", required = true)     protected String surname;     @XmlElement(name = "Position", required = true)     protected PositionType position;     @XmlElement(name = "Age")     protected int age;     @XmlElement(name = "TeamName", required = true)     protected String teamName;      /**      * Gets the value of the name property.      *       * @return      *     possible object is      *     {@link String }      *           */     public String getName() {         return name;     }      /**      * Sets the value of the name property.      *       * @param value      *     allowed object is      *     {@link String }      *           */     public void setName(String value) {         this.name = value;     }      /**      * Gets the value of the surname property.      *       * @return      *     possible object is      *     {@link String }      *           */     public String getSurname() {         return surname;     }      /**      * Sets the value of the surname property.      *       * @param value      *     allowed object is      *     {@link String }      *           */     public void setSurname(String value) {         this.surname = value;     }      /**      * Gets the value of the position property.      *       * @return      *     possible object is      *     {@link PositionType }      *           */     public PositionType getPosition() {         return position;     }      /**      * Sets the value of the position property.      *       * @param value      *     allowed object is      *     {@link PositionType }      *           */     public void setPosition(PositionType value) {         this.position = value;     }      /**      * Gets the value of the age property.      *       */     public int getAge() {         return age;     }      /**      * Sets the value of the age property.      *       */     public void setAge(int value) {         this.age = value;     }      /**      * Gets the value of the teamName property.      *       * @return      *     possible object is      *     {@link String }      *           */     public String getTeamName() {         return teamName;     }      /**      * Sets the value of the teamName property.      *       * @param value      *     allowed object is      *     {@link String }      *           */     public void setTeamName(String value) {         this.teamName = value;     }  }   </pre>The <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">@XmlRootElement(name = "PlayerDetails")</span> means that this class will output a Root node in the XML file. The <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">@XmlAccessorType(XmlAccessType.FIELD)</span> as the JavaDoc says means that  <i>"Every non static, non transient field in a JAXB-bound class will be automatically bound to XML, unless annotated by XmlTransient."</i> In other words, if you have a field annotated by the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">XmlTransient</span> annotation it won't get serialized. Then we have the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">@XmlType(name = "", propOrder = { "name", "surname", "position", "age", "teamName" })</span>which as JavaDoc sates <i>"</i><span class="Apple-style-span" style="background-color: white;"><i>Maps a class or an enum type to a XML Schema type</i></span><i>"</i>&nbsp;. In other words our class is mapped to the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">PlayerDetails</span>&nbsp;element in the schema. Finally we have the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">@XmlElement(name = "Name", required = true)</span> annotation which is a mapping of the XML node (element) to a field in the class.<br /><br />This is my message to be sent, received, enriched and routed:<br /><br /><b>RobertLewandowski.xml</b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;<br />&lt;PlayerDetails&gt;<br />    &lt;Name&gt;Robert&lt;/Name&gt;<br />    &lt;Surname&gt;Lewandowski&lt;/Surname&gt;<br />    &lt;Position&gt;ATT&lt;/Position&gt;<br />&lt;/PlayerDetails&gt;<br /></pre><br />Now off to my JMS configuration - I have configured the Queues of origin and destination<br /><br /><b>jms.properties</b><br /><br /><pre class="brush:xml">jms.origin=Initial.Queue<br />jms.destination=Routed.Queue<br /></pre><br />This is my Spring configuration (I added comments inside the config that explain the origin of those components):<br /><br /><b>jmsApplicationContext.xml</b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br /> xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"<br /> xmlns:jms="http://www.springframework.org/schema/jms" xmlns:oxm="http://www.springframework.org/schema/oxm"<br /> xsi:schemaLocation="http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-3.0.xsd http://www.springframework.org/schema/oxm http://www.springframework.org/schema/oxm/spring-oxm-3.0.xsd"&gt;<br /><br /> &lt;!-- Spring configuration based on annotations --&gt;<br /> &lt;context:annotation-config /&gt;<br /> &lt;!-- Show Spring where to search for the beans (in which packages) --&gt;<br /> &lt;context:component-scan base-package="pl.grzejszczak.marcin.camel" /&gt;<br /> <br /> &lt;!-- Show Spring where to search for the properties files --&gt;<br /> &lt;context:property-placeholder location="classpath:/camel/jms.properties" /&gt;<br /><br /> &lt;!-- The ActiveMQ connection factory with specification of the server URL --&gt;<br /> &lt;bean id="activeMQConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;<br />  &lt;property name="brokerURL" value="tcp://localhost:61616" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Spring's jms connection factory --&gt;<br /> &lt;bean id="cachingConnectionFactory"<br />  class="org.springframework.jms.connection.CachingConnectionFactory"&gt;<br />  &lt;property name="targetConnectionFactory" ref="activeMQConnectionFactory" /&gt;<br />  &lt;property name="sessionCacheSize" value="10" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- The name of the queue from which we will take the messages --&gt;<br /> &lt;bean id="origin" class="org.apache.activemq.command.ActiveMQQueue"&gt;<br />  &lt;constructor-arg value="${jms.origin}" /&gt;<br /> &lt;/bean&gt;<br /> &lt;!-- The name of the queue to which we will route the messages --&gt;<br /> &lt;bean id="destination" class="org.apache.activemq.command.ActiveMQQueue"&gt;<br />  &lt;constructor-arg value="${jms.destination}" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Configuration of the JmsTemplate together with the connection factory and the message converter --&gt;<br /> &lt;bean id="producerTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;<br />  &lt;property name="connectionFactory" ref="cachingConnectionFactory" /&gt;<br />  &lt;property name="messageConverter" ref="oxmMessageConverter" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Custom message sender sending messages to the initial queue --&gt;<br /> &lt;bean id="originPlayerSender" class="pl.grzejszczak.marcin.camel.manual.jms.PlayerDetailsSenderImpl"&gt;<br />  &lt;property name="destination" ref="origin" /&gt;<br /> &lt;/bean&gt;<br /> &lt;!-- Custom message sender sending messages to the destination queue --&gt;<br /> &lt;bean id="destinationPlayerSender" class="pl.grzejszczak.marcin.camel.manual.jms.PlayerDetailsSenderImpl"&gt;<br />  &lt;property name="destination" ref="destination" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Custom message listener - listens to the initial queue  --&gt;<br /> &lt;bean id="originListenerImpl" class="pl.grzejszczak.marcin.camel.manual.jms.ListenerImpl"/&gt;<br /> &lt;!-- Custom message listener - listens to the destination queue  --&gt;<br /> &lt;bean id="destinationListenerImpl" class="pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl"/&gt;<br /><br /> &lt;!-- Spring's jms message listener container - specified the connection factory, the queue to be listened to and the component that listens to the queue --&gt;<br /> &lt;bean id="jmsOriginContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;<br />  &lt;property name="connectionFactory" ref="cachingConnectionFactory" /&gt;<br />  &lt;property name="destination" ref="origin" /&gt;<br />  &lt;property name="messageListener" ref="originListenerImpl" /&gt;<br /> &lt;/bean&gt;<br /> <br /> &lt;!-- Spring's jms message listener container - specified the connection factory, the queue to be listened to and the component that listens to the queue --&gt;<br /> &lt;bean id="jmsDestinationContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;<br />  &lt;property name="connectionFactory" ref="cachingConnectionFactory" /&gt;<br />  &lt;property name="destination" ref="destination" /&gt;<br />  &lt;property name="messageListener" ref="destinationListenerImpl" /&gt;<br /> &lt;/bean&gt;<br /> <br /> &lt;!-- Message converter - automatically marshalls and unmarshalls messages using the provided marshaller / unmarshaller--&gt;<br /> &lt;bean id="oxmMessageConverter" class="org.springframework.jms.support.converter.MarshallingMessageConverter"&gt;<br />          &lt;property name="marshaller" ref="marshaller" /&gt;<br />          &lt;property name="unmarshaller" ref="marshaller" /&gt;<br />     &lt;/bean&gt;<br /><br /> &lt;!-- Spring's JAXB implementation of marshaller - provided a class the JAXB generated class --&gt;<br />     &lt;oxm:jaxb2-marshaller id="marshaller"&gt;<br />          &lt;oxm:class-to-be-bound name="pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails" /&gt;<br />     &lt;/oxm:jaxb2-marshaller&gt;<br /><br />&lt;/beans&gt;<br /><br /></pre>Now let's take a look at the Java code - let's start with the class that has the main function<br /><br /><b>ActiveMQRouter.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel.manual;<br /><br />import java.io.File;<br />import java.util.Scanner;<br /><br />import javax.jms.JMSException;<br /><br />import org.springframework.context.ApplicationContext;<br />import org.springframework.context.support.ClassPathXmlApplicationContext;<br />import org.springframework.core.io.ClassPathResource;<br />import org.springframework.core.io.Resource;<br /><br />import pl.grzejszczak.marcin.camel.jaxb.PlayerDetailsConverter;<br />import pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails;<br />import pl.grzejszczak.marcin.camel.manual.jms.Sender;<br /><br />public class ActiveMQRouter {<br /><br /> /**<br />  * @param args<br />  * @throws JMSException<br />  */<br /> public static void main(String[] args) throws Exception {<br />  ApplicationContext context = new ClassPathXmlApplicationContext("/camel/jmsApplicationContext.xml");<br />  @SuppressWarnings("unchecked")<br />  Sender&lt;PlayerDetails&gt; sender = (Sender&lt;PlayerDetails&gt;) context.getBean("originPlayerSender");<br /><br />  Resource resource = new ClassPathResource("/camel/RobertLewandowski.xml");<br /><br />  Scanner scanner = new Scanner(new File(resource.getURI())).useDelimiter("\\Z");<br />  String contents = scanner.next();<br /><br />  PlayerDetailsConverter converter = context.getBean(PlayerDetailsConverter.class);<br /><br />  sender.sendMessage(converter.unmarshal(contents));<br /> }<br />}</pre><pre class="brush:java"></pre>What we can see here is that we initialize the Spring context from the classpath and retrieve the bean named <span style="font-family: 'Courier New', Courier, monospace;">originPlayerSender</span>. This component is used for sending a message to the initial queue. In order to have a message to send we are retrieving a file <span style="font-family: 'Courier New', Courier, monospace;">RobertLewandowski.xml</span> from the classpath and read it to a String variable through the <span style="font-family: 'Courier New', Courier, monospace;">Scanner</span> class. Next we use our custom <span style="font-family: 'Courier New', Courier, monospace;">PlayerDetailsConverter</span> class to unmarshall the String contents into a <span style="font-family: 'Courier New', Courier, monospace;">PlayerDetails</span> object, which in effect is sent by the <span style="font-family: 'Courier New', Courier, monospace;">originPlayerSender</span> to the origin queue.<br /><br />Now let's take a look at the sender logic:<br /><br /><b>PlayerDetailsSenderImpl.java</b><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel.manual.jms;<br /><br />import javax.jms.Destination;<br />import javax.jms.JMSException;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.jms.core.JmsTemplate;<br />import org.springframework.stereotype.Component;<br /><br />import pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails;<br /><br />@Component<br />public class PlayerDetailsSenderImpl implements Sender&lt;PlayerDetails&gt; {<br /><br /> private static final Logger LOGGER = LoggerFactory.getLogger(PlayerDetailsSenderImpl.class);<br /><br /> private Destination destination;<br /><br /> @Autowired<br /> private JmsTemplate jmsTemplate;<br /><br /> @Override<br /> public void sendMessage(final PlayerDetails object) throws JMSException {<br />  LOGGER.debug("Sending [{}] to topic [{}]", new Object[] { object, destination });<br />  jmsTemplate.convertAndSend(destination, object);<br /> }<br /><br /> public Destination getDestination() {<br />  return destination;<br /> }<br /><br /> public void setDestination(Destination destination) {<br />  this.destination = destination;<br /> }<br /><br />}<br /><br /></pre>This class is implementing my <span style="font-family: 'Courier New', Courier, monospace;">Sender</span> interface that provides the <span style="font-family: 'Courier New', Courier, monospace;">sendMessage</span> function. We are using the <span style="font-family: 'Courier New', Courier, monospace;">JmsTemplate</span> object to convert and send the message to the given <span style="font-family: 'Courier New', Courier, monospace;">destination</span> that is injected via Spring.<br /><br />Ok, now that we've sent the message someone has to retrieve it:<br /><br /><b>ListenerImpl.java</b><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel.manual.jms;<br /><br />import java.util.List;<br /><br />import javax.jms.BytesMessage;<br />import javax.jms.Message;<br />import javax.jms.MessageListener;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.jms.support.converter.MessageConverter;<br />import org.springframework.stereotype.Component;<br /><br />import pl.grzejszczak.marcin.camel.enricher.Enrichable;<br />import pl.grzejszczak.marcin.camel.jaxb.Convertable;<br />import pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails;<br /><br />@Component<br />public class ListenerImpl implements MessageListener {<br /><br /> private static final Logger LOG = LoggerFactory.getLogger(ListenerImpl.class);<br /><br /> @Autowired<br /> private Convertable&lt;PlayerDetails&gt; playerDetailsConverter;<br /><br /> @Autowired<br /> private List&lt;Enrichable&lt;PlayerDetails&gt;&gt; listOfEnrichers;<br /><br /> @Autowired<br /> private MessageConverter messageConverter;<br /><br /> @Autowired<br /> @Qualifier("destinationPlayerSender")<br /> private Sender&lt;PlayerDetails&gt; sender;<br /><br /> @Override<br /> public void onMessage(Message message) {<br />  if (!(message instanceof BytesMessage)) {<br />   LOG.error("Wrong msg!");<br />   return;<br />  }<br /><br />  PlayerDetails playerDetails = null;<br />  try {<br />   playerDetails = (PlayerDetails) messageConverter.fromMessage(message);<br /><br />   LOG.debug("Enriching the input message");<br />   for (Enrichable&lt;PlayerDetails&gt; enrichable : listOfEnrichers) {<br />    enrichable.enrich(playerDetails);<br />   }<br />   LOG.debug("Enriched text message: [{}]", new Object[] { playerDetailsConverter.marshal(playerDetails) });<br />   sender.sendMessage(playerDetails);<br />  } catch (Exception e) {<br />   LOG.error("Exception occured", e);<br />  }<br /><br /> }<br /><br />}<br /><br /></pre>This class has the list of all the classes implementing the <span style="font-family: 'Courier New', Courier, monospace;">Enrichable</span> interface thanks to which it will provide the enrichment of the message without the necessity of knowing the amount of enrichers in the system. There is also the <span style="font-family: 'Courier New', Courier, monospace;">PlayerDetailsConverter</span> class that helps with marshalling and unmarshalling <span style="font-family: 'Courier New', Courier, monospace;">PlayerDetails</span>. Once the message is enriched it is sent to the destination queue through the bean that implements the <span style="font-family: 'Courier New', Courier, monospace;">Sender</span> interface and has the id of <span style="font-family: 'Courier New', Courier, monospace;">destinationPlayerSender</span>. It is important to remember that what we receive from the queue is a <span style="font-family: 'Courier New', Courier, monospace;">BytesMessage</span> thus that's why we are doing the initial check.<br /><br />Let's take a look at one of the enrichers (the other one is a setting another field in the <span style="font-family: 'Courier New', Courier, monospace;">PlayerDetails</span> object)<br /><br /><b>ClubEnricher.java</b><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel.enricher;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.stereotype.Component;<br /><br />import pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails;<br /><br />@Component("ClubEnricher")<br />public class ClubEnricher implements Enrichable&lt;PlayerDetails&gt; {<br /><br /> private static final Logger LOGGER = LoggerFactory.getLogger(ClubEnricher.class);<br /><br /> @Override<br /> public void enrich(PlayerDetails inputObject) {<br />  LOGGER.debug("Enriching player [{}] with club data", new Object[] { inputObject.getSurname() });<br />  // Simulating accessing DB or some other service<br />  try {<br />   Thread.sleep(2000);<br />  } catch (InterruptedException e) {<br />   LOGGER.error("Exception while sleeping occured", e);<br />  }<br />  inputObject.setTeamName("Borussia Dortmund");<br /> }<br /><br />}<br /><br /></pre>As you can see the class is just simulating some access to the DB or any other service and afterwards is setting the team name in the input <span style="font-family: 'Courier New', Courier, monospace;">PlayerDetails </span>object.<br /><br />Let's now take a look a the conversion mechanism:<br /><br /><b>PlayerDetailsConverter.java</b><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel.jaxb;<br /><br />import java.io.ByteArrayOutputStream;<br />import java.io.OutputStream;<br /><br />import javax.xml.bind.JAXBContext;<br />import javax.xml.bind.JAXBException;<br />import javax.xml.bind.Marshaller;<br />import javax.xml.bind.Unmarshaller;<br /><br />import org.apache.activemq.util.ByteArrayInputStream;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.stereotype.Component;<br /><br />import pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails;<br /><br />@Component("PlayerDetailsConverter")<br />public class PlayerDetailsConverter implements Convertable&lt;PlayerDetails&gt; {<br /> private static final Logger LOGGER = LoggerFactory.getLogger(PlayerDetailsConverter.class);<br /><br /> private final JAXBContext jaxbContext;<br /> private final Marshaller jaxbMarshaller;<br /> private final Unmarshaller jaxbUnmarshaller;<br /><br /> public PlayerDetailsConverter() throws JAXBException {<br />  jaxbContext = JAXBContext.newInstance(PlayerDetails.class);<br />  jaxbMarshaller = jaxbContext.createMarshaller();<br />  jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);<br />  jaxbUnmarshaller = jaxbContext.createUnmarshaller();<br /> }<br /><br /> @Override<br /> public String marshal(PlayerDetails object) {<br />  OutputStream stream = new ByteArrayOutputStream();<br />  try {<br />   jaxbMarshaller.marshal(object, stream);<br />  } catch (JAXBException e) {<br />   LOGGER.error("Exception occured while marshalling", e);<br />  }<br />  return stream.toString();<br /> }<br /><br /> @Override<br /> public PlayerDetails unmarshal(String objectAsString) {<br />  try {<br />   return (PlayerDetails) jaxbUnmarshaller.unmarshal(new ByteArrayInputStream(objectAsString.getBytes()));<br />  } catch (JAXBException e) {<br />   LOGGER.error("Exception occured while marshalling", e);<br />  }<br />  return null;<br /> }<br /><br />}<br /><br /></pre>In the constructor we are setting some <span style="font-family: 'Courier New', Courier, monospace;">JAXB</span> components - the <span style="font-family: 'Courier New', Courier, monospace;">JAXBContext</span>,&nbsp;JAXB&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">Marshaller</span> and&nbsp;JAXB&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">Unmarshaller&nbsp;</span>that&nbsp;have the necessary marshal and unmarshal methods.<br /><br />Last but not least is the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">FinalListenerImpl</span> that is listening to the inbound message from the destination queue and shuts the application.<br /><br /><b>FinalListenerImpl.java</b><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel.manual.jms;<br /><br />import javax.jms.BytesMessage;<br />import javax.jms.Message;<br />import javax.jms.MessageListener;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.jms.support.converter.MessageConverter;<br />import org.springframework.stereotype.Component;<br /><br />import pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails;<br /><br />@Component<br />public class FinalListenerImpl implements MessageListener {<br /><br /> private static final Logger LOG = LoggerFactory.getLogger(FinalListenerImpl.class);<br /><br /> @Autowired<br /> private MessageConverter messageConverter;<br /><br /> @Override<br /> public void onMessage(Message message) {<br />  if (!(message instanceof BytesMessage)) {<br />   LOG.error("Wrong msg!");<br />   return;<br />  }<br /><br />  PlayerDetails playerDetails = null;<br />  try {<br />   playerDetails = (PlayerDetails) messageConverter.fromMessage(message);<br /><br />   if (playerDetails.getTeamName() != null) {<br />    LOG.debug("Message already enriched! Shutting down the system");<br />    System.exit(0);<br />   } else {<br />    LOG.debug("The message should have been enriched but wasn't");<br />    System.exit(1);<br />   }<br /><br />  } catch (Exception e) {<br />   LOG.error("Exception occured", e);<br />  }<br /><br /> }<br /><br />}<br /><br /></pre>By using the <span style="font-family: Courier New, Courier, monospace;">MessageConverter</span>, after having verified if the message is of proper type, we check if the team name has already been filled in - if that is the case we are terminating the application.<br /><br />And the logs are as follows:<br /><br /><pre class="brush:xml">2012-11-05 [main] org.springframework.context.support.ClassPathXmlApplicationContext:495 Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@34fbb7cb: startup date [Mon Nov 05 21:47:00 CET 2012]; root of context hierarchy<br />2012-11-05 [main] org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [camel/jmsApplicationContext.xml]<br />2012-11-05 [main] org.springframework.beans.factory.config.PropertyPlaceholderConfigurer:177 Loading properties file from class path resource [camel/jms.properties]<br />2012-11-05 [main] org.springframework.beans.factory.support.DefaultListableBeanFactory:557 Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@3313beb5: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.internalPersistenceAnnotationProcessor,myRoute,AgeEnricher,ClubEnricher,PlayerDetailsConverter,finalListenerImpl,listenerImpl,playerDetailsSenderImpl,org.springframework.beans.factory.config.PropertyPlaceholderConfigurer#0,activeMQConnectionFactory,cachingConnectionFactory,origin,destination,producerTemplate,originPlayerSender,destinationPlayerSender,originListenerImpl,destinationListenerImpl,jmsOriginContainer,jmsDestinationContainer,oxmMessageConverter,marshaller,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy<br />2012-11-05 [main] org.springframework.oxm.jaxb.Jaxb2Marshaller:436 Creating JAXBContext with classes to be bound [class pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails]<br />2012-11-05 [main] org.springframework.context.support.DefaultLifecycleProcessor:334 Starting beans in phase 2147483647<br />2012-11-05 [main] org.springframework.jms.connection.CachingConnectionFactory:291 Established shared JMS Connection: ActiveMQConnection {id=ID:marcin-SR700-38535-1352148424687-1:1,clientId=null,started=false}<br />2012-11-05 [main] pl.grzejszczak.marcin.camel.manual.jms.PlayerDetailsSenderImpl:26 Sending [pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails@6ae2d0b2] to topic [queue://Initial.Queue]<br />2012-11-05 [jmsOriginContainer-1] pl.grzejszczak.marcin.camel.manual.jms.ListenerImpl:49 Enriching the input message<br />2012-11-05 [jmsOriginContainer-1] pl.grzejszczak.marcin.camel.enricher.AgeEnricher:17 Enriching player [Lewandowski] with age data<br />2012-11-05 [jmsOriginContainer-1] pl.grzejszczak.marcin.camel.enricher.ClubEnricher:16 Enriching player [Lewandowski] with club data<br />2012-11-05 [jmsOriginContainer-1] pl.grzejszczak.marcin.camel.manual.jms.ListenerImpl:53 Enriched text message: [&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;<br />&lt;PlayerDetails&gt;<br />    &lt;Name&gt;Robert&lt;/Name&gt;<br />    &lt;Surname&gt;Lewandowski&lt;/Surname&gt;<br />    &lt;Position&gt;ATT&lt;/Position&gt;<br />    &lt;Age&gt;19&lt;/Age&gt;<br />    &lt;TeamName&gt;Borussia Dortmund&lt;/TeamName&gt;<br />&lt;/PlayerDetails&gt;<br />]<br />2012-11-05 [jmsOriginContainer-1] pl.grzejszczak.marcin.camel.manual.jms.PlayerDetailsSenderImpl:26 Sending [pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails@3dca1588] to topic [queue://Routed.Queue]<br />2012-11-05 [jmsDestinationContainer-1] pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl:35 Message already enriched! Shutting down the system<br /><br /></pre><br /><br />This is how thanks to the Spring JMS module and the JAXB library you can easilly create JMS listeners, senders and message convertors for the XML messages.<br /><br /></div>

]]></content>
  </entry>
  
</feed>
