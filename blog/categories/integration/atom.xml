<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Integration | TOO MUCH CODING]]></title>
  <link href="http://toomuchcoding.com/blog/categories/integration/atom.xml" rel="self"/>
  <link href="http://toomuchcoding.com/"/>
  <updated>2019-03-29T13:21:37+01:00</updated>
  <id>http://toomuchcoding.com/</id>
  <author>
    <name><![CDATA[Marcin Grzejszczak]]></name>
    <email><![CDATA[blog@toomuchcoding.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Execution of Groovy Scripts From Java - XmlSlurper and MarkupBuilder in Mapping Issues]]></title>
    <link href="http://toomuchcoding.com/blog/2013/03/30/execution-of-groovy-scripts-from-java/"/>
    <updated>2013-03-30T15:09:00-07:00</updated>
    <id>http://toomuchcoding.com/blog/2013/03/30/execution-of-groovy-scripts-from-java</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><h2>Problem with mappings</h2><br />In our project we came across a really big problem related to mapping. Having two systems that initially were defined by the BA to be somehwat simillar we have chosen the simple XSLT (done through Altova Mapforce) of the input message to the output one.<br />
<!--more-->
<br />Afterwards it turned out that the functions required to perform a mapping are becoming enormous. An example of such a mapping is:<br /><blockquote class="tr_bq">From the input message take a list of Cars iterate over it and find a Car whose field "prodcutionDate" is the lowest and the attribute "make" is equal to "Honda" and as the output return the "saleDate"</blockquote>So in order to map it we decided to move to JBoss Drools. The <a href="http://toomuchcoding.blogspot.com/2013/02/drools-decision-tables-with-camel-and.html">decision tables</a> were out of question since the logic was to complex and customized to be placed in the spreadsheet so we coded everything in the DRL files. Soon the rules got really big and some of our developers were forced to spend plenty of time on constant recreation of rules stated by the BA.<br /><br />Out of frustration and after having seen all the amazing things at the&nbsp;<a href="http://2013.33degree.org/">33rd degree conference</a> I decided to start finding solutions to my problems which were:<br /><br /><a name='more'></a><br /><ol><li>The DRL files are big and started to become unmaintainable (for a single field we had for example 4 rules)</li><li>Since the BA has never coded a single Drools rule / XSLT &nbsp;in his life adding a simple if... else... statement for him is not a problem</li><li>The BA has to wait for the mapping implementation by the devs until he can test it</li><li>The devs are spending far too much time on coding the mapping rules instead of developing other features</li></ol><div>After stating these problems a research regarding mapping frameworks took place and one of the concepts that I began working on was trying to create the mapping in Groovy. Since Groovy (thanks to for example PropertyMissing and MethodMissing) is a perfect language for creating a DSL I decided to start right away. The only two things I had to remember about were:</div><div><ol><li>The current application is written purely in Java</li><li>The mapping code (in order to perform fast testing) has to be detached from the application as such - it can't be compiled during deployment because we want to have the possibility of frequent substitutions of the mappings</li></ol><div><h2>Project structure&nbsp;</h2><br />Having defined the language, the constraints I created the following solution:</div></div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-LUqaZQkqom4/UVdMZkiW7RI/AAAAAAAABDc/f3sRJ9fF6AM/s1600/Project+structure.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://2.bp.blogspot.com/-LUqaZQkqom4/UVdMZkiW7RI/AAAAAAAABDc/f3sRJ9fF6AM/s320/Project+structure.png" width="255" /></a></div><div><br /></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;">The project structure</div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: left;">As you can see the project structure is very simple. To begin with it is built in <b>Gradle</b>. The main function can be found in the <b>XmlTransformer.java</b>. The flow is such that the <b>TransformerFactory</b>&nbsp;creates a <b>Transformer</b>&nbsp;basing on the Groovy script that came out of the <b>ScriptFactory </b>(in our project for different types of products that we distinguish by a field in the XML file, we have different DRL files). The Groovy scripts are residing in the classpath in the <b>/groovy/</b> folder (of course at the end of the day those scripts should be placed outside any jars).&nbsp;</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">In the <b>build.gradle</b>&nbsp;</div><div class="separator" style="clear: both; text-align: left;"><br /></div><pre class="brush:groovy">apply plugin: 'java'<br /><br />group = 'com.blogspot.toomuchcoding'<br />version = '1.0'<br /><br />repositories {<br />    mavenCentral()<br />}<br /><br />dependencies {<br />    compile 'org.codehaus.groovy:groovy-all:2.0.5'<br />    compile 'org.slf4j:slf4j-log4j12:1.7.2'<br />    compile 'log4j:log4j:1.2.16'<br />    compile 'com.google.guava:guava:14.0'<br /><br />    testCompile group: 'junit', name: 'junit', version: '4.+'<br />}<br /><br />task(executeMain, dependsOn: 'classes', type: JavaExec) {<br />    main = 'com.blogspot.toomuchcoding.XmlTransformer'<br />    classpath = sourceSets.main.runtimeClasspath<br />}<br /></pre><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">we can see that there is no groovy plugin -&nbsp;it has been done deliberately since we don't want our scripts to be compiled. Now let's take a look at the logic behind the TransformerFactory that compiles the Groovy script. What is really important is the fact that our Groovy class implements an interface created in our Java project - we want from the Java point of view to have no problems with execution of the Groovy code.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;"><b>TransformerFactoryImpl.java</b></div><div class="separator" style="clear: both; text-align: left;"><br /></div><pre class="brush:java">package com.blogspot.toomuchcoding.factory;<br /><br />import com.blogspot.toomuchcoding.transformer.Transformer;<br />import com.google.common.io.Resources;<br />import groovy.util.GroovyScriptEngine;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br /><br />import java.io.File;<br />import java.net.URL;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 22.03.13<br /> * Time: 23:54<br /> */<br />public class TransformerFactoryImpl implements TransformerFactory&lt;String, String&gt; {<br />    private static final String GROOVY_SCRIPTS_CLASSPATH = "groovy/";<br />    private static Logger LOGGER = LoggerFactory.getLogger(TransformerFactoryImpl.class);<br /><br />    private ScriptFactory scriptFactory;<br />    private GroovyScriptEngine groovyScriptEngine;<br /><br />    public TransformerFactoryImpl(ScriptFactory scriptFactory) {<br />        this.scriptFactory = scriptFactory;<br />        try {<br />            groovyScriptEngine = new GroovyScriptEngine(GROOVY_SCRIPTS_CLASSPATH);<br />        } catch (IOException e) {<br />            LOGGER.error("Exception occurred while trying to create the Groovy script engine", e);<br />            throw new RuntimeException(e);<br />        }<br />    }<br /><br />    @Override<br />    public Transformer&lt;String, String&gt; createTransformer() {<br />        Transformer&lt;String, String&gt; transformerFromScript = null;<br />        try {<br />            File scriptFile = scriptFactory.createScript();<br />            URL scriptAsAClasspathResource = Resources.getResource(GROOVY_SCRIPTS_CLASSPATH + scriptFile.getName());<br />            Class classFromScript = groovyScriptEngine.loadScriptByName(scriptAsAClasspathResource.getFile());<br />            transformerFromScript = (Transformer&lt;String, String&gt;) classFromScript.newInstance();<br />        } catch (Exception e) {<br />            LOGGER.error("Exception occurred while trying to execute Groovy script", e);<br />        }<br />        return transformerFromScript;<br />    }<br /><br />}<br /><br /></pre><div class="separator" style="clear: both; text-align: left;">A <b>GroovyScriptEngine</b>&nbsp;is used to load a script by name. I chose the <a href="http://docs.codehaus.org/display/GROOVY/Embedding+Groovy">GroovyScriptEngine</a> (hopefully I used it in a good way ;) ) &nbsp;because:</div><blockquote class="tr_bq"><span style="background-color: white; font-family: Arial, Helvetica, FreeSans, sans-serif; font-size: 13px; line-height: 17.328125px;">The most complete solution for people who want to embed groovy scripts into their servers and have them reloaded on modification is the GroovyScriptEngine. You initialize the GroovyScriptEngine with a set of CLASSPATH like roots that can be URLs or directory names. You can then execute any Groovy script within those roots. The GSE will also track dependencies between scripts so that if any dependent script is modified the whole tree will be recompiled and reloaded.</span></blockquote><div class="separator" style="clear: both; text-align: left;">I wanted to have some way of caching the compiled classes in order not to have any issues with PermGen.</div><div class="separator" style="clear: both; text-align: left;">Anyway you can see that I am doing some conversions to have the URL of the classpath Groovy script resource. At the end we are extracting a class from the Groovy script and we are casting it to the Transformer.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;"><b>AbstractGroovyXmlTransformer.groovy</b></div><div class="separator" style="clear: both; text-align: left;"><br /></div><pre class="brush:groovy">package groovy<br /><br />import com.blogspot.toomuchcoding.transformer.Transformer<br />import groovy.util.slurpersupport.NodeChildren<br />import groovy.xml.MarkupBuilder<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 23.03.13<br /> * Time: 02:16<br /> */<br />abstract class AbstractGroovyXmlTransformer implements Transformer&lt;String, String&gt; {<br /><br />    static Map&lt;String, Object&gt; MISSING_PROPERTIES = ["convertDate": new DateConverter(), "map": new Mapper()]<br /><br />    @Override<br />    String transform(String input) {<br />        def inputXml = new XmlSlurper().parseText input<br />        def writer = new StringWriter()<br />        def outputXml = new MarkupBuilder(writer)<br />        doTransform inputXml, outputXml<br />        writer.toString()<br />    }<br /><br />    abstract void doTransform(inputXml, outputXml)<br /><br />    def propertyMissing(String name) {<br />        Object property = MISSING_PROPERTIES[name]<br />        assert property != null, "There is no function like [$name]. The ones that are supported are ${MISSING_PROPERTIES.keySet()}"<br />        property<br />    }<br /><br /><br /><br />    protected static class Mapper {<br />        private Map&lt;String, String&gt; inputParameters<br /><br />        Mapper given(Map inputParameters) {<br />            this.inputParameters = inputParameters<br />            this<br />        }<br /><br />        String from(NodeChildren nodeChildren) {<br />            assert inputParameters != null, "The mapping can't be null!"<br />            assert nodeChildren != null, "Node can't be null!"<br />            String nodeText = nodeChildren.text()<br />            String mappedValue = inputParameters[nodeText]<br />            mappedValue ?: inputParameters.default<br />        }<br /><br />        static Mapper map(Map&lt;String, String&gt; inputParameters) {<br />            return new Mapper(inputParameters)<br />        }<br />    }<br /><br />    protected static class DateConverter {<br />        private String inputDate<br />        private String inputDateFormat<br /><br />        DateConverter from(NodeChildren nodeChildren) {<br />            this.inputDate = nodeChildren.text()<br />            this<br />        }<br /><br />        DateConverter havingDateFormat(String inputDateFormat) {<br />            this.inputDateFormat = inputDateFormat<br />            this<br />        }<br /><br />        String toOutputDateFormat(String outputDateFormat) {<br />            assert inputDate != null, "The input date for which you are trying to do the conversion can't be null"<br />            assert inputDateFormat != null, "The input date format for which you are trying to do the conversion can't be null"<br />            assert outputDateFormat != null, "The output date format for which you are trying to do the conversion can't be null"<br />            Date.parse(inputDateFormat, inputDate).format(outputDateFormat)<br />        }<br /><br />        static DateConverter convertDate() {<br />            new DateConverter()<br />        }<br />    }<br />}</pre><pre class="brush:groovy"></pre><div class="separator" style="clear: both; text-align: left;">In this abstract Groovy class I decided to place all the logic that could blur the image for the BA. In addition to that I created some helper classes and methods. In order to fully use the Groovy's DSL capabilities I used the propertyMissing method to map the words <b>"map"</b> and <b>"convertDate"</b>&nbsp;to create the instances of the helper classes which are used in the <b>Builder</b> design pattern way:</div><div class="separator" style="clear: both; text-align: left;"><br /></div><pre class="brush:groovy">convertDate.from(inputXml.InputSystemContext.InputDate).havingDateFormat("dd/MM/yyyy").toOutputDateFormat("yy/MM/dd")<br /><br />or<br /><br />map.given("Some_action" : "Some_output_action", "default" : "something else").from(inputXml.AdditionalData.TypeOfAction)<br /></pre><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">If there is no such "function" (for example a BA makes a typo or sth) then an assertion error is being thrown and a list of supported "function" (which in reality are properties - but they are functions from the BA's perspective) is being printed.&nbsp;</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">Now let's move to the script that would be used by the BA.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;"><b>GroovyXmlTransformer.groovy</b></div><div class="separator" style="clear: both; text-align: left;"><br /></div><pre class="brush:groovy">package groovy<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 22.03.13<br /> * Time: 23:59<br /> *<br /> * additional functions:<br /> *<br /> * convertDate.from(Node).havingDateFormat("DateFormat").toOutputDateFormat("AnotherDateFormat")<br /> * map.given("Value to be mapped from" : "Value to be mapped to", "default" : "default value").from(Node)<br /> *<br /> */<br />class GroovyXmlTransformer extends AbstractGroovyXmlTransformer {<br /><br />    @Override<br />    void doTransform(inputXml, outputXml) {<br />        outputXml.OutputSystemEnvelope() {<br />            OutputSystemContext {<br />                ResponseID(inputXml.InputSystemContext.RequestID.text().reverse())<br />                OutputSource('OUTPUT_SYSTEM')<br />                OutputDate(convertDate.from(inputXml.InputSystemContext.InputDate).havingDateFormat("dd/MM/yyyy").toOutputDateFormat("yy/MM/dd"))<br />            }<br />            OutputAdditionalData {<br />                OutputReferenceNo("SOME_PREFIX_${inputXml.AdditionalData.ReferenceNo.text()}_SOME_SUFIX")<br />                OutputTypeOfAction(map.given("Some_action" : "Some_output_action", "default" : "something else").from(inputXml.AdditionalData.TypeOfAction))<br />                OutputTransactions {<br />                    inputXml.AdditionalData.Transactions.Transaction.each {<br />                        OutputTransaction(Client: it.Client, ProductType: it.ProductType, 'Done')<br />                    }<br />                }<br />                OutputProducts {<br />                    def minProduct = inputXml.AdditionalData.Products.Product.list().min { it.Value.text() }<br />                    def maxProduct = inputXml.AdditionalData.Products.Product.list().max { it.Value.text() }<br />                    MinProduct(name: minProduct.Name.text(), minProduct.Value.text())<br />                    MaxProduct(name: maxProduct.Name.text(), maxProduct.Value.text())<br />                }<br />            }<br />        }<br />    }<br />}<br /></pre><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">This piece of code does the following mapping (You can check the <b>/xml/SampleXml.xml</b> ):</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="datagrid"><table><thead><tr><th>Mapped from</th><th>Mapped to</th></tr></thead><tbody><tr><td>InputSystemEnvelope</td><td>OutputSystemEnvelope</td></tr><tr class="alt"><td>InputSystemContex</td><td>OutputSystemContex</td></tr><tr><td>RequestId</td><td>ResponseId (the Id should be reverted)</td></tr><tr class="alt"><td>InputSource</td><td>OutputSoutce (constant "UTPUT_SYSTEM")</td></tr><tr><td>InputDate</td><td>OutputDate (converted from dd/MM/yyyy to yy/MM/dd) </td></tr><tr class="alt"><td>InputAdditionalData</td><td>OutputAdditionalData</td></tr><tr><td>InputReferenceNo</td><td>OutputReferenceNo ( "SOME_PREFIX_" + value from InputReferenceNo + "_SOME_SUFIX") </td></tr><tr class="alt"><td>InputTypeOfAction</td><td>OutputTypeOfAction (mapped in such a way that if InputTypeOfAction is equal to "Some_action" then we will have "Some_output_action". Otherwise we get "something else")</td></tr><tr><td>Transactions</td><td>OutputTransactions</td></tr><tr class="alt"><td>Transaction</td><td>OutputTransaction ( Attribute Client from Transaction.Client, Attribute ProductType from Transaction.ProductType, and the value "Done")</td></tr><tr><td>Products</td><td>OutputProducts</td></tr><tr class="alt"><td>Product having min value</td><td>MinProduct</td></tr><tr><td>Product having max value</td><td>MaxProduct</td></tr></tbody></table></div><div class="separator" style="clear: both; text-align: left;"><br /></div><h2>The output</h2><div class="separator" style="clear: both; text-align: left;"><br /></div><pre class="brush:xml">Converted from [&lt;InputSystemEnvelope&gt;<br />    &lt;InputSystemContext&gt;<br />        &lt;RequestID&gt;1234567890&lt;/RequestID&gt;<br />        &lt;InputSource&gt;INPUT_SYSTEM&lt;/InputSource&gt;<br />        &lt;InputDate&gt;22/03/2013&lt;/InputDate&gt;<br />    &lt;/InputSystemContext&gt;<br />    &lt;AdditionalData&gt;<br />        &lt;ReferenceNo&gt;Ref1234567&lt;/ReferenceNo&gt;<br />        &lt;TypeOfAction&gt;Some_action&lt;/TypeOfAction&gt;<br />        &lt;Transactions&gt;<br />            &lt;Transaction&gt;<br />                &lt;Client&gt;ACME&lt;/Client&gt;<br />                &lt;ProductType&gt;IRS&lt;/ProductType&gt;<br />            &lt;/Transaction&gt;<br />            &lt;Transaction&gt;<br />                &lt;Client&gt;Oracle&lt;/Client&gt;<br />                &lt;ProductType&gt;DB&lt;/ProductType&gt;<br />            &lt;/Transaction&gt;<br />        &lt;/Transactions&gt;<br />        &lt;Products&gt;<br />            &lt;Product&gt;<br />                &lt;Name&gt;Book&lt;/Name&gt;<br />                &lt;Value&gt;1&lt;/Value&gt;<br />            &lt;/Product&gt;<br />            &lt;Product&gt;<br />                &lt;Name&gt;Car&lt;/Name&gt;<br />                &lt;Value&gt;10000&lt;/Value&gt;<br />            &lt;/Product&gt;<br />            &lt;Product&gt;<br />                &lt;Name&gt;Boat&lt;/Name&gt;<br />                &lt;Value&gt;100000000&lt;/Value&gt;<br />            &lt;/Product&gt;<br />            &lt;Product&gt;<br />                &lt;Name&gt;Spaceship&lt;/Name&gt;<br />                &lt;Value&gt;1000000000000000000&lt;/Value&gt;<br />            &lt;/Product&gt;<br />        &lt;/Products&gt;<br />    &lt;/AdditionalData&gt;<br />&lt;/InputSystemEnvelope&gt;]<br /><br /> to<br /><br />[&lt;OutputSystemEnvelope&gt;<br />  &lt;OutputSystemContext&gt;<br />    &lt;ResponseID&gt;0987654321&lt;/ResponseID&gt;<br />    &lt;OutputSource&gt;OUTPUT_SYSTEM&lt;/OutputSource&gt;<br />    &lt;OutputDate&gt;13/03/22&lt;/OutputDate&gt;<br />  &lt;/OutputSystemContext&gt;<br />  &lt;OutputAdditionalData&gt;<br />    &lt;OutputReferenceNo&gt;SOME_PREFIX_Ref1234567_SOME_SUFIX&lt;/OutputReferenceNo&gt;<br />    &lt;OutputTypeOfAction&gt;Some_output_action&lt;/OutputTypeOfAction&gt;<br />    &lt;OutputTransactions&gt;<br />      &lt;OutputTransaction Client='ACME' ProductType='IRS'&gt;Done&lt;/OutputTransaction&gt;<br />      &lt;OutputTransaction Client='Oracle' ProductType='DB'&gt;Done&lt;/OutputTransaction&gt;<br />    &lt;/OutputTransactions&gt;<br />    &lt;OutputProducts&gt;<br />      &lt;MinProduct name='Book'&gt;1&lt;/MinProduct&gt;<br />      &lt;MaxProduct name='Spaceship'&gt;1000000000000000000&lt;/MaxProduct&gt;<br />    &lt;/OutputProducts&gt;<br />  &lt;/OutputAdditionalData&gt;<br />&lt;/OutputSystemEnvelope&gt;]<br /></pre><div><h2>Pros and cons</h2>The pros and cons of this approach are as follows:<br /><br />Pros:<br /><ul><li>The mapping is done sequentialy - field by field (it is easier to debug the problem)</li><li>The mapping consists of vocabulary understandable by the BA</li><li>Most of mappings could be done by the BA</li><li>The majority of non-mapping grammar is hidden in the abstraction</li><li>The compilation of the Groovy script is faster than creation of KnowledgeBases and compilation of Drools scripts</li><li>Independence on the XML schema (each change of the schema would require the recompilation of the JAXB classes)</li></ul><div>Cons:</div><div><ul><li>The BA would have to have some knowledge from the domain of computer science</li><li>No parallel mapping</li><li>The mapping might get less readable due to the fact that it is highly probable that the BA (out of lack of time) won't create a single function - all the logic will end up in the closures for a given Node.</li><li>There might be some memory issues with parsing and recompilation of the Groovy scripts</li><li>No XML schema may lead to improper output / input XML path setting</li></ul><h2>Summary</h2></div><div>The problem with mapping that we encountered in our project turned out to be a very interesting issue to deal with. The example shown in this post is only a proposition of solving the issue and hopefully could be a starting point to a further discussion on the topic. If you have any ideas or opinions on this topic please leave a comment under <a href="http://toomuchcoding.blogspot.com/2013/03/execution-of-groovy-scripts-from-java.html">this article</a>.</div><div><br /></div><div>The sources can be found on the <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/69f4b59e4452e630670c71150d125e7ea86170aa/Groovy/Mappings?at=default">Too Much Coding BitBucket repository</a> and on <a href="https://github.com/marcingrzejszczak/too-much-coding/tree/master/Groovy/Mappings">GitHub</a>.</div></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apache Camel With Spring, Routing With Enrichment Service]]></title>
    <link href="http://toomuchcoding.com/blog/2012/11/22/apache-camel-with-spring-routing-with/"/>
    <updated>2012-11-22T14:13:00-08:00</updated>
    <id>http://toomuchcoding.com/blog/2012/11/22/apache-camel-with-spring-routing-with</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />Sorry for not having posted anything in some time but I had plenty of work. Anyway today I will continue the example with JMS that I've shown you some time ago.<br />
<!--more-->
<br />The idea of the previous example was to simplify the work that we had to do in a manual way - we've sed JmsTemplate and Spring listener containers. The routing as such unfortunately was still done by us. In order to facilitate this process we can use <a href="http://camel.apache.org/">Apache Camel</a>.<br /><br />The following example bases on the one that we've seen in this post&nbsp;<a href="http://toomuchcoding.blogspot.com/2012/11/spring-jms-message-automatic-conversion.html">Spring JMS, message automatic conversion, JMS template</a>&nbsp;but with slight modifications:<br /><br /><b>CamelRouter.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel;<br /><br />import org.apache.camel.spring.Main;<br /><br />public class CamelRouter {<br /><br /> /**<br />  * @param args<br />  * @throws Exception<br />  */<br /> public static void main(String[] args) throws Exception {<br />  Main main = new Main();<br />  main.setApplicationContextUri("/camel/camelContext.xml");<br />  main.run(args);<br /> }<br /><br />}<br /><br /><br /></pre>What we can see here is the usage of the Camel's <span style="font-family: Courier New, Courier, monospace;">Main</span> class which you can reuse to more easily boot up Camel and keep it running until the JVM terminate. <br /><br />Then we have a new file <span style="font-family: Courier New, Courier, monospace;">camelContext.xml</span> in which we have the Camel context in the Spring configuration file.<br /><br /><b>camelContext.xml</b><br /><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans" <br /> xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br /> xsi:schemaLocation="http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd "&gt;<br /> <br /> &lt;import resource="classpath:/camel/jmsApplicationContext.xml" /&gt;<br /> <br /> &lt;camel:camelContext id="camel" xmlns:camel="http://camel.apache.org/schema/spring"&gt;<br />  &lt;camel:dataFormats&gt;<br />   &lt;camel:jaxb id="jaxb" prettyPrint="true" contextPath="pl.grzejszczak.marcin.camel.jaxb.generated" /&gt;<br />  &lt;/camel:dataFormats&gt;<br /><br />  &lt;camel:route&gt;<br />   &lt;camel:from uri="activemq:topic:Initial.Topic" /&gt;<br />   &lt;camel:unmarshal ref="jaxb" /&gt;<br />   &lt;camel:bean ref="enrichingService" /&gt;<br />   &lt;camel:marshal ref="jaxb" /&gt;<br />   &lt;camel:to uri="activemq:topic:Routed.Topic" /&gt;<br />  &lt;/camel:route&gt;<br /><br /> &lt;/camel:camelContext&gt;<br />&lt;/beans&gt;<br /></pre><br />We are defining in this file in order to create a Camel Route - from the activemq topic called <i>Initial.Topic</i> to the one called <i>Routed.Topic</i>. In the meantime we are doing some unmarshalling and marshalling by means of Jaxb.<br /><br />In the jmsApplicationContext we no longer define the sender to the final topic: <i>Routed.Topic</i>.<br /><br /><b>jmsApplicationContext.java</b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br /> xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"<br /> xmlns:jms="http://www.springframework.org/schema/jms" xmlns:oxm="http://www.springframework.org/schema/oxm"<br /> xsi:schemaLocation="http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-3.0.xsd http://www.springframework.org/schema/oxm http://www.springframework.org/schema/oxm/spring-oxm-3.0.xsd"&gt;<br /><br /> &lt;!-- Spring configuration based on annotations --&gt;<br /> &lt;context:annotation-config /&gt;<br /> &lt;!-- Show Spring where to search for the beans (in which packages) --&gt;<br /> &lt;context:component-scan base-package="pl.grzejszczak.marcin.camel" /&gt;<br /> <br /> &lt;!-- Show Spring where to search for the properties files --&gt;<br /> &lt;context:property-placeholder location="classpath:/camel/jms.properties" /&gt;<br /><br /> &lt;!-- The ActiveMQ connection factory with specification of the server URL --&gt;<br /> &lt;bean id="activeMQConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;<br />  &lt;property name="brokerURL" value="tcp://localhost:61616" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Spring's jms connection factory --&gt;<br /> &lt;bean id="cachingConnectionFactory"<br />  class="org.springframework.jms.connection.CachingConnectionFactory"&gt;<br />  &lt;property name="targetConnectionFactory" ref="activeMQConnectionFactory" /&gt;<br />  &lt;property name="sessionCacheSize" value="10" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- The name of the queue from which we will take the messages --&gt;<br /> &lt;bean id="origin" class="org.apache.activemq.command.ActiveMQTopic"&gt;<br />  &lt;constructor-arg value="${jms.origin}" /&gt;<br /> &lt;/bean&gt;<br /> &lt;!-- The name of the queue to which we will route the messages --&gt;<br /> &lt;bean id="destination" class="org.apache.activemq.command.ActiveMQTopic"&gt;<br />  &lt;constructor-arg value="${jms.destination}" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Configuration of the JmsTemplate together with the connection factory and the message converter --&gt;<br /> &lt;bean id="producerTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;<br />  &lt;property name="connectionFactory" ref="cachingConnectionFactory" /&gt;<br />  &lt;property name="messageConverter" ref="oxmMessageConverter" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Custom message sender sending messages to the initial queue --&gt;<br /> &lt;bean id="originPlayerSender" class="pl.grzejszczak.marcin.camel.manual.jms.PlayerDetailsSenderImpl"&gt;<br />  &lt;property name="destination" ref="origin" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Custom message listener - listens to the destination queue  --&gt;<br /> &lt;bean id="destinationListenerImpl" class="pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl"/&gt;<br /><br /> <br /> &lt;!-- Spring's jms message listener container - specified the connection factory, the queue to be listened to and the component that listens to the queue --&gt;<br /> &lt;bean id="jmsDestinationContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;<br />  &lt;property name="connectionFactory" ref="cachingConnectionFactory" /&gt;<br />  &lt;property name="destination" ref="destination" /&gt;<br />  &lt;property name="messageListener" ref="destinationListenerImpl" /&gt;<br /> &lt;/bean&gt;<br /> <br /> &lt;!-- Message converter - automatically marshalls and unmarshalls messages using the provided marshaller / unmarshaller--&gt;<br /> &lt;bean id="oxmMessageConverter" class="org.springframework.jms.support.converter.MarshallingMessageConverter"&gt;<br />          &lt;property name="marshaller" ref="marshaller" /&gt;<br />          &lt;property name="unmarshaller" ref="marshaller" /&gt;<br />     &lt;/bean&gt;<br /><br /> &lt;bean id="enrichingService" class="pl.grzejszczak.marcin.camel.service.EnrichingServiceImpl"/&gt;<br /><br /> &lt;!-- Spring's JAXB implementation of marshaller - provided a class the JAXB generated class --&gt;<br />     &lt;oxm:jaxb2-marshaller id="marshaller"&gt;<br />          &lt;oxm:class-to-be-bound name="pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails" /&gt;<br />     &lt;/oxm:jaxb2-marshaller&gt;<br /><br />&lt;/beans&gt;<br /><br /></pre>Once we have already initialized our camel context, what we need to do is to send a message to the <i>Initial.Topic</i>. We are doing it by means of our modified <span style="font-family: Courier New, Courier, monospace;">ActiveMQRouter</span> class.<br /><br /><b>ActiveMQRouter.java</b><br /><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel.manual;<br /><br />import java.io.File;<br />import java.util.Scanner;<br /><br />import javax.jms.JMSException;<br /><br />import org.springframework.context.ApplicationContext;<br />import org.springframework.context.support.ClassPathXmlApplicationContext;<br />import org.springframework.core.io.ClassPathResource;<br />import org.springframework.core.io.Resource;<br /><br />import pl.grzejszczak.marcin.camel.jaxb.PlayerDetailsConverter;<br />import pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails;<br />import pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl;<br />import pl.grzejszczak.marcin.camel.manual.jms.Sender;<br /><br />public class ActiveMQRouter {<br /><br /> /**<br />  * @param args<br />  * @throws JMSException<br />  */<br /> public static void main(String[] args) throws Exception {<br />  ApplicationContext context = new ClassPathXmlApplicationContext("/camel/jmsApplicationContext.xml");<br />  @SuppressWarnings("unchecked")<br />  Sender&lt;PlayerDetails&gt; sender = (Sender&lt;PlayerDetails&gt;) context.getBean("originPlayerSender");<br /><br />  Resource resource = new ClassPathResource("/camel/RobertLewandowski.xml");<br /><br />  Scanner scanner = new Scanner(new File(resource.getURI())).useDelimiter("\\Z");<br />  String contents = scanner.next();<br /><br />  PlayerDetailsConverter converter = context.getBean(PlayerDetailsConverter.class);<br /><br />  FinalListenerImpl listener = (FinalListenerImpl) context.getBean("finalListenerImpl");<br /><br />  sender.sendMessage(converter.unmarshal(contents));<br /> }<br />}<br /><br /></pre>The class is reading the file and sending it to the initial topic. We also initialize a FinalListenerImpl - a class that will listen to the messages coming to the final topic - to prove that everything is working correctly.<br /><br />That's it! Now let's check out the logs. Logs of CamelRouter:<br /><br /><br /><pre class="brush:xml">2012-11-22 22:51:39,429 INFO  [main] org.apache.camel.main.MainSupport:300 Apache Camel 2.9.2 starting<br />2012-11-22 22:51:40,028 INFO  [main] org.springframework.context.support.ClassPathXmlApplicationContext:495 Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@4c5e176f: startup date [Thu Nov 22 22:51:40 CET 2012]; root of context hierarchy<br />2012-11-22 22:51:40,213 INFO  [main] org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [camel/camelContext.xml]<br />2012-11-22 22:51:40,746 INFO  [main] org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [camel/jmsApplicationContext.xml]<br />2012-11-22 22:51:41,120 INFO  [main] org.springframework.context.annotation.ClassPathBeanDefinitionScanner:210 JSR-330 'javax.inject.Named' annotation found and supported for component scanning<br />2012-11-22 22:51:43,219 INFO  [main] org.springframework.beans.factory.config.PropertyPlaceholderConfigurer:177 Loading properties file from class path resource [camel/jms.properties]<br />2012-11-22 22:51:43,233 INFO  [main] org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor:139 JSR-330 'javax.inject.Inject' annotation found and supported for autowiring<br />2012-11-22 22:51:43,274 INFO  [main] org.springframework.beans.factory.support.DefaultListableBeanFactory:557 Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@19d03a4e: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,AgeEnricher,ClubEnricher,PlayerDetailsConverter,finalListenerImpl,playerDetailsSenderImpl,org.springframework.beans.factory.config.PropertyPlaceholderConfigurer#0,activeMQConnectionFactory,cachingConnectionFactory,origin,destination,producerTemplate,originPlayerSender,destinationListenerImpl,jmsDestinationContainer,oxmMessageConverter,enrichingService,marshaller,template,consumerTemplate,camel:beanPostProcessor,camel,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy<br />2012-11-22 22:51:43,424 INFO  [main] org.springframework.oxm.jaxb.Jaxb2Marshaller:436 Creating JAXBContext with classes to be bound [class pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails]<br />2012-11-22 22:51:44,521 INFO  [main] org.springframework.context.support.DefaultLifecycleProcessor:334 Starting beans in phase 2147483647<br />2012-11-22 22:51:45,061 INFO  [main] org.springframework.jms.connection.CachingConnectionFactory:291 Established shared JMS Connection: ActiveMQConnection {id=ID:marcin-SR700-47684-1353621104666-1:1,clientId=null,started=false}<br />2012-11-22 22:51:45,608 INFO  [main] org.apache.camel.spring.SpringCamelContext:1374 Apache Camel 2.9.2 (CamelContext: camel) is starting<br />2012-11-22 22:51:45,611 INFO  [main] org.apache.camel.management.ManagementStrategyFactory:38 JMX enabled. Using ManagedManagementStrategy.<br />2012-11-22 22:51:45,850 INFO  [main] org.apache.camel.management.DefaultManagementLifecycleStrategy:790 StatisticsLevel at All so enabling load performance statistics<br />2012-11-22 22:51:45,961 INFO  [main] org.apache.camel.impl.converter.AnnotationTypeConverterLoader:119 Found 3 packages with 15 @Converter classes to load<br />2012-11-22 22:51:45,995 INFO  [main] org.apache.camel.impl.converter.DefaultTypeConverter:405 Loaded 170 core type converters (total 170 type converters)<br />2012-11-22 22:51:46,002 INFO  [main] org.apache.camel.impl.converter.AnnotationTypeConverterLoader:109 Loaded 2 @Converter classes<br />2012-11-22 22:51:46,023 INFO  [main] org.apache.camel.impl.converter.AnnotationTypeConverterLoader:119 Found 1 packages with 1 @Converter classes to load<br />2012-11-22 22:51:46,024 WARN  [main] org.apache.camel.impl.converter.DefaultTypeConverter:257 Overriding type converter from: StaticMethodTypeConverter: public static org.apache.activemq.command.ActiveMQDestination org.apache.camel.component.activemq.ActiveMQConverter.toDestination(java.lang.String) to: StaticMethodTypeConverter: public static org.apache.activemq.command.ActiveMQDestination org.apache.activemq.camel.converter.ActiveMQConverter.toDestination(java.lang.String)<br />2012-11-22 22:51:46,043 INFO  [main] org.apache.camel.impl.converter.DefaultTypeConverter:431 Loaded additional 3 type converters (total 173 type converters) in 0.041 seconds<br />2012-11-22 22:51:46,360 INFO  [main] org.apache.camel.converter.jaxb.JaxbDataFormat:277 Creating JAXBContext with contextPath: pl.grzejszczak.marcin.camel.jaxb.generated and ApplicationContextClassLoader: sun.misc.Launcher$AppClassLoader@35a16869<br />2012-11-22 22:51:46,500 INFO  [main] org.apache.camel.spring.SpringCamelContext:1980 Route: route1 started and consuming from: Endpoint[activemq://topic:Initial.Topic]<br />2012-11-22 22:51:46,509 INFO  [main] org.apache.camel.spring.SpringCamelContext:1409 Total 1 routes, of which 1 is started.<br />2012-11-22 22:51:46,510 INFO  [main] org.apache.camel.spring.SpringCamelContext:1410 Apache Camel 2.9.2 (CamelContext: camel) started in 0.901 seconds<br />2012-11-22 22:51:46,519 INFO  [main] org.springframework.context.support.DefaultLifecycleProcessor:334 Starting beans in phase 2147483647<br />2012-11-22 22:52:08,375 DEBUG [Camel (camel) thread #1 - JmsConsumer[Initial.Topic]] pl.grzejszczak.marcin.camel.service.EnrichingServiceImpl:21 Enriching player details<br />2012-11-22 22:52:08,377 DEBUG [Camel (camel) thread #1 - JmsConsumer[Initial.Topic]] pl.grzejszczak.marcin.camel.enricher.AgeEnricher:17 Enriching player [Lewandowski] with age data<br />2012-11-22 22:52:10,379 DEBUG [Camel (camel) thread #1 - JmsConsumer[Initial.Topic]] pl.grzejszczak.marcin.camel.enricher.ClubEnricher:16 Enriching player [Lewandowski] with club data<br />2012-11-22 22:52:12,462 DEBUG [jmsDestinationContainer-1] pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl:35 Message already enriched! Shutting down the system<br /><br /></pre>We can see that the Camel Context has been initialized and then the bean that we have created in the <span style="font-family: Courier New, Courier, monospace;">jmsApplicationContext.xml</span> that is listening to the final destination is acknowledging that the message has been enriched properly.<br /><br />What about the <span style="font-family: Courier New, Courier, monospace;">ActiveMQRouter.java</span> logs?<br /><br /><br /><pre class="brush:xml">2012-11-22 22:52:06,077 INFO  [main] org.springframework.context.support.ClassPathXmlApplicationContext:495 Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@43462851: startup date [Thu Nov 22 22:52:06 CET 2012]; root of context hierarchy<br />2012-11-22 22:52:06,153 INFO  [main] org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [camel/jmsApplicationContext.xml]<br />2012-11-22 22:52:06,417 INFO  [main] org.springframework.context.annotation.ClassPathBeanDefinitionScanner:210 JSR-330 'javax.inject.Named' annotation found and supported for component scanning<br />2012-11-22 22:52:06,721 INFO  [main] org.springframework.beans.factory.config.PropertyPlaceholderConfigurer:177 Loading properties file from class path resource [camel/jms.properties]<br />2012-11-22 22:52:06,733 INFO  [main] org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor:139 JSR-330 'javax.inject.Inject' annotation found and supported for autowiring<br />2012-11-22 22:52:06,758 INFO  [main] org.springframework.beans.factory.support.DefaultListableBeanFactory:557 Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@362f0d54: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,AgeEnricher,ClubEnricher,PlayerDetailsConverter,finalListenerImpl,playerDetailsSenderImpl,org.springframework.beans.factory.config.PropertyPlaceholderConfigurer#0,activeMQConnectionFactory,cachingConnectionFactory,origin,destination,producerTemplate,originPlayerSender,destinationListenerImpl,jmsDestinationContainer,oxmMessageConverter,enrichingService,marshaller,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy<br />2012-11-22 22:52:07,224 INFO  [main] org.springframework.oxm.jaxb.Jaxb2Marshaller:436 Creating JAXBContext with classes to be bound [class pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails]<br />2012-11-22 22:52:07,628 INFO  [main] org.springframework.context.support.DefaultLifecycleProcessor:334 Starting beans in phase 2147483647<br />2012-11-22 22:52:07,883 INFO  [main] org.springframework.jms.connection.CachingConnectionFactory:291 Established shared JMS Connection: ActiveMQConnection {id=ID:marcin-SR700-53586-1353621127755-1:1,clientId=null,started=false}<br />2012-11-22 22:52:08,093 DEBUG [main] pl.grzejszczak.marcin.camel.manual.jms.PlayerDetailsSenderImpl:26 Sending [pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails@3ea86d12] to topic [topic://Initial.Topic]<br />2012-11-22 22:52:12,463 DEBUG [jmsDestinationContainer-1] pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl:35 Message already enriched! Shutting down the system<br /><br /></pre>First we see that our spring Context has been initialized and then we see that a message has been sent to the <i>Initial.Topic</i>. At the end of the processing we can see that the listener is confirming that the message has been properly enriched - so all the Camel work has been done in a proper way.<br /><br />This example is showing how easy and simple it can be to create a routing / enriching service by means of Spring and Camel (integrated with Spring).<br /><br />The sources are available at <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/26b70bca3b44e37c20c627e0efe4644d28f8d468/Camel%20and%20Spring?at=default">Too Much Coding's repository at bitbucket</a>.<br /><br /></div>

]]></content>
  </entry>
  
</feed>
