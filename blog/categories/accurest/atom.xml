<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Accurest | TOO MUCH CODING]]></title>
  <link href="https://toomuchcoding.com/blog/categories/accurest/atom.xml" rel="self"/>
  <link href="https://toomuchcoding.com/"/>
  <updated>2020-08-13T15:39:09+02:00</updated>
  <id>https://toomuchcoding.com/</id>
  <author>
    <name><![CDATA[Marcin Grzejszczak]]></name>
    <email><![CDATA[blog@toomuchcoding.com]]></email>
  </author>
  <generator uri="https://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring Cloud Contract Podcast]]></title>
    <link href="https://toomuchcoding.com/blog/2016/10/07/spring-cloud-contract-podcast/"/>
    <updated>2016-10-07T23:14:36+02:00</updated>
    <id>https://toomuchcoding.com/blog/2016/10/07/spring-cloud-contract-podcast</id>
    <content type="html"><![CDATA[<p>A podcast with Michael Cote and me about Spring Cloud Contract was just published. <a href="https://soundcloud.com/pivotalconversations/037-microservices-governance-with-spring-cloud-contract-guest-marcin-grzejszczak">You can check it out here!</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Cloud Contract 1.0.0.RELEASE Available!]]></title>
    <link href="https://toomuchcoding.com/blog/2016/09/24/spring-cloud-contract-1-dot-0-0-dot-release-available/"/>
    <updated>2016-09-24T20:39:25+02:00</updated>
    <id>https://toomuchcoding.com/blog/2016/09/24/spring-cloud-contract-1-dot-0-0-dot-release-available</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve just published an article at the Spring blog about <a href="https://spring.io/blog/2016/09/23/spring-cloud-contract-1-0-0-release-is-available">Spring Cloud Contract 1.0.0.RELEASE is available</a>.</p>

<p>I&rsquo;m really happy that the project is GA. Even though as the Accurest project we had already done a GA release, it really feels that a lot of effort was put in order to release the GA version under the Pivotal&rsquo;s Spring Cloud branding. Let&rsquo;s look at some numbers:</p>

<ul>
<li>first commit almost 2 years ago: <a href="https://github.com/spring-cloud/spring-cloud-contract/commit/dfaddaa98d645b818ba3947c9267ef7ac8ed9ba4">2014-12-06 18:20:29 by Jakub Kubrynski</a> - thanks to <a href="https://codearte.eu">Codearte</a> the authors of <a href="https://devskiller.com">DevSkiller</a> for their support!!!</li>
<li><a href="https://github.com/spring-cloud/spring-cloud-contract/commits/master">1.152 commits</a></li>
<li><a href="https://github.com/spring-cloud/spring-cloud-contract/graphs/contributors">20 contributors</a></li>
</ul>


<p>That&rsquo;s quite a lot of work! But there we are, with a library that has already been battle-proven on production by many companies, even before being GA as Spring Cloud Contract.</p>

<!-- more -->


<h2>What&rsquo;s new in comparison to Accurest?</h2>

<p>Like I mentioned, Accurest was already GA. So what are the main difference apart from rebranding and bug fixes?</p>

<ul>
<li>we&rsquo;ve moved from Grapes to Aether to download stubs</li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_what_is_this_value_consumer_producer">we generate fake data when you provide either consumer or producer in the DSL</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_common_repo_with_contracts">Consumer Contract approach is there</a></li>
<li>Spring Cloud Contract is available on <a href="https://start.spring.io">start.spring.io</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_different_base_classes_for_contracts_2">you can have more than one base class for your tests</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_additional_configuration">Spring Cloud Stub Runner Boot can register stubs in Eureka / Consul / Zookeeper using Spring Cloud</a></li>
<li>the whole build was moved from Gradle to the standard Spring Cloud Maven setup</li>
</ul>


<p>These are the Spring Cloud Contract Verifier changes. Apart from that Spring Cloud Contract consists of <a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_spring_cloud_contract_wiremock">Spring Cloud Contract WireMock support</a> and <a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_generating_stubs_using_restdocs">Spring Cloud Contract RestDocs</a>. Thanks to the first one the integration with <a href="https://wiremock.org">WireMock</a> is much more efficient and thanks to the latter you don&rsquo;t have to use the Groovy DSL - you can define your stubs by yourself by attaching them to an existing RestDocs test.</p>

<p>As far as Spring Cloud Contract Verifier is concerned the biggest two changes are the <a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_common_repo_with_contracts">Consumer Contract support</a> and that <a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_different_base_classes_for_contracts_2">you can have more than one base class for your tests</a>. Let&rsquo;s take a closer look what&rsquo;s there in the docs about them&hellip;</p>

<h3>Consumer Contract support</h3>

<p>Another way of storing contracts other than having them with the producer is keeping them in a common place. It can be related to security issues where the consumers can’t clone the producer’s code. Also if you keep contracts in a single place then you, as a producer, will know how many consumers you have and which consumer will you break with your local changes.</p>

<h4>Repo structure</h4>

<p>Let’s assume that we have a producer with coordinates com.example:server and 3 consumers: client1, client2, client3. Then in the repository with common contracts you would have the following setup (which you can checkout here:</p>

<pre><code>├── com
│   └── example
│       └── server
│           ├── client1
│           │   └── expectation.groovy
│           ├── client2
│           │   └── expectation.groovy
│           ├── client3
│           │   └── expectation.groovy
│           └── pom.xml
├── mvnw
├── mvnw.cmd
├── pom.xml
└── src
    └── assembly
        └── contracts.xml
</code></pre>

<p>As you can see the under the slash-delimited groupid / artifact id folder (<code>com/example/server</code>) you have expectations of the 3 consumers (<code>client1</code>, <code>client2</code> and <code>client3</code>). Expectations are the standard Groovy DSL contract files as described throughout this documentation. This repository has to produce a JAR file that maps one to one to the contents of the repo.</p>

<p>Example of a <code>pom.xml</code> inside the <code>server</code> folder.</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="https://maven.apache.org/POM/4.0.0" xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;server&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

    &lt;name&gt;Server Stubs&lt;/name&gt;
    &lt;description&gt;POM used to install locally stubs for consumer side&lt;/description&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;1.4.0.BUILD-SNAPSHOT&lt;/version&gt;
        &lt;relativePath /&gt;
    &lt;/parent&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;spring-cloud-contract.version&gt;1.0.1.BUILD-SNAPSHOT&lt;/spring-cloud-contract.version&gt;
        &lt;spring-cloud-dependencies.version&gt;Camden.BUILD-SNAPSHOT&lt;/spring-cloud-dependencies.version&gt;
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${spring-cloud-dependencies.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;${spring-cloud-contract.version}&lt;/version&gt;
                &lt;extensions&gt;true&lt;/extensions&gt;
                &lt;configuration&gt;
                    &lt;!-- By default it would search under src/test/resources/ --&gt;
                    &lt;contractsDirectory&gt;${project.basedir}&lt;/contractsDirectory&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;spring-snapshots&lt;/id&gt;
            &lt;name&gt;Spring Snapshots&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;true&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/repository&gt;
        &lt;repository&gt;
            &lt;id&gt;spring-milestones&lt;/id&gt;
            &lt;name&gt;Spring Milestones&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;false&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/repository&gt;
        &lt;repository&gt;
            &lt;id&gt;spring-releases&lt;/id&gt;
            &lt;name&gt;Spring Releases&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;false&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;pluginRepositories&gt;
        &lt;pluginRepository&gt;
            &lt;id&gt;spring-snapshots&lt;/id&gt;
            &lt;name&gt;Spring Snapshots&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;true&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/pluginRepository&gt;
        &lt;pluginRepository&gt;
            &lt;id&gt;spring-milestones&lt;/id&gt;
            &lt;name&gt;Spring Milestones&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;false&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/pluginRepository&gt;
        &lt;pluginRepository&gt;
            &lt;id&gt;spring-releases&lt;/id&gt;
            &lt;name&gt;Spring Releases&lt;/name&gt;
            &lt;url&gt;https://repo.spring.io/release&lt;/url&gt;
            &lt;snapshots&gt;
                &lt;enabled&gt;false&lt;/enabled&gt;
            &lt;/snapshots&gt;
        &lt;/pluginRepository&gt;
    &lt;/pluginRepositories&gt;

&lt;/project&gt;
</code></pre>

<p>As you can see there are no dependencies other than the Spring Cloud Contract Verifier Maven plugin. Those poms are necessary for the consumer side to run <code>mvn clean install -DskipTests</code> to locally install stubs of the producer project.</p>

<p>The <code>pom.xml</code> in the root folder can look like this:</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="https://maven.apache.org/POM/4.0.0" xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.example.standalone&lt;/groupId&gt;
    &lt;artifactId&gt;contracts&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

    &lt;name&gt;Contracts&lt;/name&gt;
    &lt;description&gt;Contains all the Spring Cloud Contracts, well, contracts. JAR used by the producers to generate tests and stubs&lt;/description&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;contracts&lt;/id&gt;
                        &lt;phase&gt;prepare-package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;single&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;attach&gt;true&lt;/attach&gt;
                            &lt;descriptor&gt;${basedir}/src/assembly/contracts.xml&lt;/descriptor&gt;
                            &lt;!-- If you want an explicit classifier remove the following line --&gt;
                            &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>

<p>It’s using the assembly plugin in order to build the JAR with all the contracts. Example of such setup is here:</p>

<pre><code>&lt;assembly xmlns="https://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3"
          xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="https://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 https://maven.apache.org/xsd/assembly-1.1.3.xsd"&gt;
    &lt;id&gt;project&lt;/id&gt;
    &lt;formats&gt;
        &lt;format&gt;jar&lt;/format&gt;
    &lt;/formats&gt;
    &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
    &lt;fileSets&gt;
        &lt;fileSet&gt;
            &lt;directory&gt;${project.basedir}&lt;/directory&gt;
            &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
            &lt;useDefaultExcludes&gt;true&lt;/useDefaultExcludes&gt;
            &lt;excludes&gt;
                &lt;exclude&gt;**/${project.build.directory}/**&lt;/exclude&gt;
                &lt;exclude&gt;mvnw&lt;/exclude&gt;
                &lt;exclude&gt;mvnw.cmd&lt;/exclude&gt;
                &lt;exclude&gt;.mvn/**&lt;/exclude&gt;
                &lt;exclude&gt;src/**&lt;/exclude&gt;
            &lt;/excludes&gt;
        &lt;/fileSet&gt;
    &lt;/fileSets&gt;
&lt;/assembly&gt;
</code></pre>

<h4>Workflow</h4>

<p>The workflow would look similar to the one presented in the <a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_step_by_step_guide_to_cdc">Step by step guide to CDC</a>. The only difference is that the producer doesn’t own the contracts anymore. So the consumer and the producer have to work on common contracts in a common repository.</p>

<h4>Consumer</h4>

<p>When the consumer wants to work on the contracts offline, instead of cloning the producer code, the consumer team clones the common repository, goes to the required producer’s folder (e.g. <code>com/example/server</code>) and runs <code>mvn clean install -DskipTests</code> to install locally the stubs converted from the contracts.</p>

<p><strong>REMEMBER! You need to have Maven installed locally</strong></p>

<h4>Producer</h4>

<p>As a producer it’s enough to alter the Spring Cloud Contract Verifier to provide the URL and the dependency of the JAR containing the contracts:</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;contractsRepositoryUrl&gt;https://link/to/your/nexus/or/artifactory/or/sth&lt;/contractsRepositoryUrl&gt;
        &lt;contractDependency&gt;
            &lt;groupId&gt;com.example.standalone&lt;/groupId&gt;
            &lt;artifactId&gt;contracts&lt;/artifactId&gt;
        &lt;/contractDependency&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>

<p>With this setup the JAR with groupid <code>com.example.standalone</code> and artifactid contracts will be downloaded from <code>https://link/to/your/nexus/or/artifactory/or/sth</code>. It will be then unpacked in a local temporary folder and contracts present under the <code>com/example/server</code> will be picked as the ones used to generate the tests and the stubs. Due to this convention the producer team will know which consumer teams will be broken when some incompatible changes are done.</p>

<p>The rest of the flow looks the same.</p>

<h3>More than one base class</h3>

<p>That was quite a problem when providing one single base class for all the tests. After some time the mock configurations were enormous! That&rsquo;s why we&rsquo;ve added a possibility to map a contract to its test base class.</p>

<h4>Gradle</h4>

<p>If your base classes differ between contracts you can tell the Spring Cloud Contract plugin which class should get extended by the autogenerated tests. You have two options:</p>

<ul>
<li>follow a convention by providing the <code>packageWithBaseClasses</code></li>
<li>provide explicit mapping via <code>baseClassMappings</code></li>
</ul>


<h5>Convention</h5>

<p>The convention is such that if you have a contract under e.g. <code>src/test/resources/contract/foo/bar/baz/</code> and provide the value of the <code>packageWithBaseClasses</code> property to <code>com.example.base</code> then we will assume that there is a <code>BarBazBase</code> class under <code>com.example.base</code> package. In other words we take last two parts of package if they exist and form a class with a <code>Base</code> suffix. Takes precedence over <code>baseClassForTests</code>. Example of usage in the contracts closure:</p>

<pre><code>packageWithBaseClasses = 'com.example.base'
</code></pre>

<h5>Mapping</h5>

<p>You can manually map a regular expression of the contract’s <em>package</em> (package, not folder) to fully qualified name of the base class for the matched contract. Let’s take a look at the following example:</p>

<pre><code>baseClassForTests = "com.example.FooBase"
baseClassMappings {
    baseClassMapping('.*com.*', 'com.example.ComBase')
    baseClassMapping('.*bar.*':'com.example.BarBase')
}
</code></pre>

<p>Let’s assume that you have contracts under</p>

<ul>
<li><code>src/test/resources/contract/com/</code></li>
<li><code>src/test/resources/contract/foo/</code></li>
</ul>


<p>By providing the <code>baseClassForTests</code> we have a fallback in case mapping didn’t succeed (you could also provide the <code>packageWithBaseClasses</code> as fallback). That way the tests generated from <code>src/test/resources/contract/com/</code> contracts will be extending the <code>com.example.ComBase</code> whereas the rest of tests will extend <code>com.example.FooBase</code> cause they don&rsquo;t match the base class mapping for <code>bar</code> folder.</p>

<h4>Maven</h4>

<p>Let&rsquo;s now look how it looks like for Maven.</p>

<h5>Convention</h5>

<p>To accomplish the same result as the one presented for Gradle you&rsquo;d have to set your configuration like this:</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;packageWithBaseClasses&gt;com.example.base&lt;/packageWithBaseClasses&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>

<h5>Mapping</h5>

<p>You can manually map a regular expression of the contract’s package to fully qualified name of the base class for the matched contract. You have to provide a list <code>baseClassMappings</code> of <code>baseClassMapping</code> that takes a <code>contractPackageRegex</code> to <code>baseClassFQN</code> mapping. Let’s take a look at the following example:</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;baseClassForTests&gt;com.example.FooBase&lt;/baseClassForTests&gt;
        &lt;baseClassMappings&gt;
            &lt;baseClassMapping&gt;
                &lt;contractPackageRegex&gt;.*com.*&lt;/contractPackageRegex&gt;
                &lt;baseClassFQN&gt;com.example.ComBase&lt;/baseClassFQN&gt;
            &lt;/baseClassMapping&gt;
            &lt;baseClassMapping&gt;
                &lt;contractPackageRegex&gt;.*bar.*&lt;/contractPackageRegex&gt;
                &lt;baseClassFQN&gt;com.example.BarBase&lt;/baseClassFQN&gt;
            &lt;/baseClassMapping&gt;
        &lt;/baseClassMappings&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>

<h2>Summary</h2>

<p>In this blog post we&rsquo;ve checked what are the new and shiny features in the GA of Spring Cloud Contract. We&rsquo;ve also checked some history around Accurest to Spring Cloud Contract migration.</p>

<h2>Links</h2>

<p>Here you can find interesting links related to Spring Cloud Contract Verifier:</p>

<ul>
<li><a href="https://github.com/spring-cloud/spring-cloud-contract/">Spring Cloud Contract Github Repository</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/">Spring Cloud Contract Main project page</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html">Spring Cloud Contract Documentation</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract.html#_spring_cloud_contract_stub_runner">Spring Cloud Contract Stub Runner Documentation</a></li>
<li><a href="https://gitter.im/spring-cloud/spring-cloud-contract">Spring Cloud Contract Gitter</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-contract/spring-cloud-contract-maven-plugin/">Spring Cloud Contract Maven Plugin Documentation</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Cloud Contract 1.0.0.M1 Released]]></title>
    <link href="https://toomuchcoding.com/blog/2016/07/25/spring-cloud-contract-1-dot-0-0-dot-m1-released/"/>
    <updated>2016-07-25T17:07:39+02:00</updated>
    <id>https://toomuchcoding.com/blog/2016/07/25/spring-cloud-contract-1-dot-0-0-dot-m1-released</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve just published an article at the Spring blog about <a href="https://spring.io/blog/2016/07/25/spring-cloud-contract-1-0-0-m1-released">Spring Cloud Contract 1.0.0.M1 Release</a>. Check out the new project formerly known as Accurest!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Accurest Becomes Part of the Spring Cloud Contract]]></title>
    <link href="https://toomuchcoding.com/blog/2016/06/24/accurest-becomes-part-of-the-spring-cloud-contract/"/>
    <updated>2016-06-24T18:43:07+02:00</updated>
    <id>https://toomuchcoding.com/blog/2016/06/24/accurest-becomes-part-of-the-spring-cloud-contract</id>
    <content type="html"><![CDATA[<p>I&rsquo;m extremely happy to announce that we have successfully rebranded the <a href="https://codearte.github.io/accurest">Accurest project</a>. It&rsquo;s officially become part of the <a href="https://github.com/spring-cloud/spring-cloud-contract">Spring Cloud Contract</a> initiative. Ladies and Gentlemen please welcome the new projects:</p>

<ul>
<li><a href="https://codearte.github.io/accurest/">Spring Cloud Contract Verifier</a></li>
<li><a href="https://codearte.github.io/accurest/#spring-cloud-contract-stub-runner">Spring Cloud Contract Stub Runner</a></li>
</ul>


<!-- more -->


<h2>A little bit of history</h2>

<p>Accurest was created because of lack of an easy-to-use tool for doing <a href="https://martinfowler.com/articles/consumerDrivenContracts.html">Consumer Driven Contracts</a>. From our production experience the biggest problem was lack of verification that the defined contract actually does what it says it does. We wanted to ensure that from the contract automatically tests are generated so that we can have a proof that the stubs are reliable. Since there was no such tool the first commit of Accurest took place on 12/2014. The very idea and its implementation was initially set by <a href="https://www.kubrynski.com/">Jakub Kubrynski</a> and me. The last available version of Accurest was 1.1.0 released on 06/2016 (the docs for the old version are <a href="https://codearte.github.io/accurest/deprecated/">available here</a>). During these 19 months a lot of feedback has been gathered. The tool has received a lot of very good reception and that made us want to work even harder. Many times we have decided to decrease the time required for sleeping so as to fix a bug or develop a new feature in Accurest.</p>

<h2>Notable features</h2>

<p>Speaking of features, especially quite a few of them definitely makes Accurest stand out on the &ldquo;market&rdquo; of Consumer Driven Contract (CDC) tooling. Out of many the most interesting are:</p>

<ul>
<li>Possibility to do CDC with messaging</li>
<li>Clear and easy to use, statically typed DSL</li>
<li>Possibility to copy paste your current JSON file to the contract and only edit its elements</li>
<li>Automatic generation of tests from the defined Contract</li>
<li>Stub Runner functionality - the stubs are automatically downloaded at runtime from Nexus / Artifactory</li>
<li>Spring Cloud integration - no discovery service is needed for integration tests</li>
</ul>


<p>For more information check out my posts about <a href="https://toomuchcoding.com/blog/2016/04/06/accurest-stubrunner-released/">Stub Runner</a>, <a href="https://toomuchcoding.com/blog/2016/04/30/accurest-and-stub-runner-1-dot-1-0-dot-m3/">Accurest Messaging</a> or <a href="https://codearte.github.io/accurest/">just read the docs</a>.</p>

<h2>Spring Cloud Contract</h2>

<p>In Pivotal we came to the conclusion that Accurest could become an interesting addition to our Spring Cloud tooling. Due to the increased interest of the community in the Consumer Driven Contracts approach we&rsquo;ve decided to start the <a href="https://github.com/spring-cloud/spring-cloud-contract">Spring Cloud Contract</a> initiative.</p>

<p>Accurest became <em>Spring Cloud Contract Verifier</em> (note: the name might change in the future) but for the time being will remain in the <a href="https://github.com/Codearte">Codearte repository</a>. It&rsquo;s becoming the part of Spring Cloud tooling as a mature tool with a growing community around it. Some arguments for that are that it has:</p>

<ul>
<li><a href="https://codearte.github.io/accurest/">a nice AsciiDoc documentation that was completely rewritten following users' feedback</a></li>
<li><a href="https://gitter.im/Codearte/accurest">active Gitter channel where we try to immediately answer any support questions</a></li>
<li><a href="https://github.com/Codearte/accurest/stargazers">Over 80 stars on Github and counting ;)</a></li>
</ul>


<p>Since we believe very much in the Consumer Driven Contract approach we also want to do the library in a Client Driven way. That means that we (server side) are very open to your feedback (consumer side) and want you be the main driver of changes in the library.</p>

<h2>Credits</h2>

<p>The Accurest project would never come to life without the hard work of the <a href="https://codearte.io">Codearte</a> developers (the order is random):</p>

<ul>
<li><a href="https://twitter.com/olga_maciaszek">Olga Maciaszek-Sharma</a></li>
<li><a href="https://www.kubrynski.com">Jakub Kubrynski</a></li>
<li><a href="https://solidsoft.wordpress.com/">Marcin Zajaczkowski</a></li>
<li><a href="https://github.com/mariuszs">Mariusz Smykula</a></li>
</ul>


<p>and obviously everybody who has <a href="https://github.com/Codearte/accurest/graphs/contributors">ever commited something to the project</a>.</p>

<h2>Links</h2>

<p>If you want to read more about <em>Spring Cloud Contract Verifier</em> just check out the following links.</p>

<ul>
<li><a href="https://github.com/Codearte/accurest">Spring Cloud Contract Verifier Github Repository</a></li>
<li><a href="https://codearte.github.io/accurest">Spring Cloud Contract Verifier Documentation</a></li>
<li><a href="https://codearte.github.io/accurest/deprecated">Accurest Legacy Documentation</a></li>
<li><a href="https://codearte.github.io/accurest/#spring-cloud-contract-stub-runner">Spring Cloud Contract Stub Runner Documentation</a></li>
<li><a href="https://codearte.github.io/accurest/#stub-runner-for-messaging">Spring Cloud Contract Stub Runner Messaging Documentation</a></li>
<li><a href="https://gitter.im/Codearte/accurest">Spring Cloud Contract Verifier Gitter</a></li>
<li><a href="https://github.com/Codearte/accurest-maven-plugin">Spring Cloud Contract Verifier Maven Plugin</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Accurest and Stub Runner 1.1.0.M3]]></title>
    <link href="https://toomuchcoding.com/blog/2016/04/30/accurest-and-stub-runner-1-dot-1-0-dot-m3/"/>
    <updated>2016-04-30T13:53:44+02:00</updated>
    <id>https://toomuchcoding.com/blog/2016/04/30/accurest-and-stub-runner-1-dot-1-0-dot-m3</id>
    <content type="html"><![CDATA[<p>Currently at the Spring Team we&rsquo;re polishing our libraries for the upcoming final release of the Brixton train. It should happen soon :) Until then I&rsquo;m spending a lot of my after work, free time on <a href="/blog/2016/04/25/accurest-docs-updated/">Accurest</a> and <a href="https://toomuchcoding.com/blog/2016/04/06/accurest-stubrunner-released/">Stub Runner</a>.</p>

<p>Today&rsquo;s post will be about the new stuff that you will be able to profit from in the upcoming <code>1.1.0</code> release of Accurest. Also you can profit from most of these features in the <code>1.1.0.M3</code> release.</p>

<p>I&rsquo;ll just quickly go through the features but note that you can read about all of them in more depth in our <a href="https://codearte.github.io/accurest">documentation </a>.</p>

<!-- more -->


<h2>Name change</h2>

<p>AccuREST started as a library used to stub HTTP calls. In the upcoming <code>1.1.0</code> release you will be able to stub messaging functionality too. That&rsquo;s why the name changes to Accurest. That&rsquo;s a fantastic name isn&rsquo;t it? ;)</p>

<p>Also since branding is important, now instead of calling <code>io.codearte.accurest.dsl.GroovyDsl</code> you can call <code>io.codearte.accurest.dsl.Accurest</code> :)</p>

<h2>Messaging support</h2>

<p>It took me quite some time to do this but it was worth it :) Several sleepless nights and now you can profit from defining contracts for messaging. In HTTP we had <code>client</code>/<code>stub</code> side and <code>server</code>/<code>test</code> side. For messaging we added methods to help discern the differences:</p>

<ul>
<li><code>publisher</code> the side for which the tests will be generated</li>
<li><code>consumer</code> the side for which the messaging endpoints will be stubbed</li>
</ul>


<h3>Contract</h3>

<p>There are 3 use cases from the message <code>Producer</code>&rsquo;s point of view.</p>

<ul>
<li>something happens in my application and I&rsquo;m producing an output message</li>
<li>someone sends a message to destination (queue/topic), I&rsquo;m listening to that message and will produce an output message somewhere else</li>
<li>someone sends a message to destination (queue/topic), I&rsquo;m listening to that message and will consume it without any message sending</li>
</ul>


<p>Here you can see examples of contracts for those three situations (you can read more about it in the  <a href="https://codearte.github.io/accurest/#messaging-top-level-elements">docs</a> ):</p>

<h4>Output triggered by a method</h4>

<p>The output message can be triggered by calling a method (e.g. a Scheduler was started and a message was sent)</p>

<pre><code class="groovy">def dsl = Accurest.make {
        // Human readable description
        description 'Some description'
        // Label by means of which the output message can be triggered
        label 'some_label'
        // input to the contract
        input {
                // the contract will be triggered by a method
                triggeredBy('bookReturnedTriggered()')
        }
        // output message of the contract
        outputMessage {
                // destination to which the output message will be sent
                sentTo('output')
                // the body of the output message
                body('''{ "bookName" : "foo" }''')
                // the headers of the output message
                headers {
                        header('BOOK-NAME', 'foo')
                }
        }
}
</code></pre>

<h4>Output triggered by a message</h4>

<p>The output message can be triggered by receiving a message.</p>

<pre><code class="groovy">def dsl = GroovyDsl.make {
        description 'Some Description'
        label 'some_label'
        // input is a message
        input {
                // the message was received from this destination
                messageFrom('input')
                // has the following body
                messageBody([
                        bookName: 'foo'
                ])
                // and the following headers
                messageHeaders {
                        header('sample', 'header')
                }
        }
        outputMessage {
                sentTo('output')
                body([
                        bookName: 'foo'
                ])
                headers {
                        header('BOOK-NAME', 'foo')
                }
        }
}
</code></pre>

<h4>No output, only input</h4>

<p>There can be only input without any output</p>

<pre><code class="groovy">def dsl = GroovyDsl.make {
        description 'Some Description'
        label 'some_label'
        // input is a message
        input {
                // the message was received from this destination
                messageFrom('input')
                // has the following body
                messageBody([
                        bookName: 'foo'
                ])
                // and the following headers
                messageHeaders {
                        header('sample', 'header')
                }
        }
}
</code></pre>

<h3>Producer side</h3>

<p>Here you can see an example of a JUnit generated test for the producer for the input / output scenario:</p>

<pre><code>// given:
 AccurestMessage inputMessage = accurestMessaging.create(
  "{\\"bookName\\":\\"foo\\"}"
, headers()
  .header("sample", "header"));

// when:
 accurestMessaging.send(inputMessage, "input");

// then:
 AccurestMessage response = accurestMessaging.receiveMessage("output");
 assertThat(response).isNotNull();
 assertThat(response.getHeader("BOOK-NAME")).isEqualTo("foo");
// and:
 DocumentContext parsedJson = JsonPath.parse(accurestObjectMapper.writeValueAsString(response.getPayload()));
 assertThatJson(parsedJson).field("bookName").isEqualTo("foo");
</code></pre>

<p>We&rsquo;re sending a message to a destination called <code>input</code>. next we&rsquo;re checking if there&rsquo;s a message at the <code>output</code> destination. If that&rsquo;s the case
we&rsquo;re checking if that message has proper headers and body.</p>

<h3>Consumer side</h3>

<p>It&rsquo;s enough to provide the dependency to proper Stub Runner module (check the next section for more information) and tell it which stubs should be downloaded. Yup, that&rsquo;s it! <a href="https://codearte.github.io/accurest/#stub-runner-for-messaging">Stub Runner will download the stubs and prepare stubbed routes</a>.</p>

<p>Sometimes you&rsquo;ll need to trigger a message somehow in your tests. That&rsquo;s why we&rsquo;ve provided the <code>StubTrigger</code> interface that you can inject! If you&rsquo;re already familiar with Stub Runner Spring then you could use the <code>StubFinder</code> bean to find the URL of your dependency. Now <code>StubFinder</code> also extends the <code>StubTrigger</code> interface thus you don&rsquo;t have to inject any additional beans in your tests.</p>

<p>There are multiple ways in which you can trigger a message:</p>

<h4>Trigger by label</h4>

<pre><code>stubFinder.trigger('return_book_1')
</code></pre>

<h4>Trigger by group and artifact ids</h4>

<pre><code>stubFinder.trigger('io.codearte.accurest.stubs:camelService', 'return_book_1')
</code></pre>

<h4>Trigger by artifact id</h4>

<pre><code>stubFinder.trigger('camelService', 'return_book_1')
</code></pre>

<h4>Trigger all messages</h4>

<pre><code>stubFinder.trigger()
</code></pre>

<h3>Integrations</h3>

<p>We provide the following out of the box integrations:</p>

<ul>
<li>Spring Integration</li>
<li>Spring Cloud Stream</li>
<li>Apache Camel</li>
</ul>


<p>Also we provide all the building blocks to provide a custom integration.</p>

<p>Just by providing the proper dependency</p>

<pre><code>// for Apache Camel
testCompile "io.codearte.accurest:accurest-messaging-camel:${accurestVersion}"
// for Spring Integration
testCompile "io.codearte.accurest:accurest-messaging-integration:${accurestVersion}"
// for Spring Cloud Stream
testCompile "io.codearte.accurest:accurest-messaging-stream:${accurestVersion}"
</code></pre>

<p>Your generated tests should just work.</p>

<h2>Stub Runner Boot</h2>

<p>I&rsquo;ve added a new module of <a href="https://codearte.github.io/accurest/#stub-runner-boot">Stub Runner</a> that operates on Spring Boot. Assuming that you&rsquo;re using Spring Cloud Stream you can create a project that has 2 dependencies:</p>

<pre><code>compile "io.codearte.accurest:stub-runner-boot:${accurestVersion}"
compile "io.codearte.accurest:stub-runner-messaging-stream:${accurestVersion}"
</code></pre>

<p>Now if you pass the proper <a href="https://codearte.github.io/accurest/#common-properties-for-junit-and-spring">Stub Runner Spring configuration</a> e.g.:</p>

<pre><code>stubrunner.stubs.ids: io.codearte.accurest.stubs:streamService
</code></pre>

<p>You will have a running app that exposes HTTP endpoints to</p>

<ul>
<li>trigger messages</li>
<li>check the URLs of the registered WireMock stubs</li>
</ul>


<h2>Accurest Maven Plugin</h2>

<p>Mariusz Smykuła has done a fantastic job by adding the <a href="https://codearte.github.io/accurest-maven-plugin/">Accurest Maven Plugin</a>. Now you can add Accurest to your project that runs with Maven. But that&rsquo;s not all since the Maven Plugin allows you to run the Accurest stubs using the <code>accurest:run</code> command!</p>

<p>Read the <a href="https://codearte.github.io/accurest-maven-plugin/">docs</a> to know more!</p>

<h2>Stub Runner changes</h2>

<h3>Messaging</h3>

<p>With messaging coming as a feature I&rsquo;ve added a bunch of messaging modules. You can read more about the <a href="https://codearte.github.io/accurest/#stub-runner-for-messaging">Stub Runner messaging modules here</a></p>

<h3>Fixed ports and versions of stubs</h3>

<p>Another feature that was missing and is really valuable is that now you can explicitly say that you want a particular dependency to be started at a given port. This feature is available since version <code>1.0.7</code> but the stub id has been changed in <code>1.1.0.M4</code> so be warned ;)</p>

<p>The ids have changed because now you can provide the desired version of the stub that you want to download.</p>

<h4>Via properties</h4>

<p>Now you can provide the id of a stub like this:</p>

<pre><code>groupId:artifactId:version:classifier:port
</code></pre>

<p>where version, classifier and port are optional.</p>

<ul>
<li>If you don’t provide the port then a random one will be picked</li>
<li>If you don’t provide the classifier then the default one will be taken.</li>
<li>If you don’t provide the version then the + will be passed and the latest one will be downloaded</li>
</ul>


<p>Where port means the port of the WireMock server.</p>

<p>So if you provide your dependency like this:</p>

<pre><code>stubrunner.stubs.ids: io.codearte.accurest.stubs:streamService:0.0.1-SNAPSHOT:stubs:9090,io.codearte.accurest.stubs:anotherService:+:9095
</code></pre>

<p>It will make Stub Runner:</p>

<ul>
<li>download a stub with groupId: <code>io.codearte.accurest.stubs</code>, artifactId: <code>streamService</code>, version: <code>0.0.1-SNAPSHOT</code>, classifier: <code>stubs</code> and register it at port 9090</li>
<li>download a stub with groupId: <code>io.codearte.accurest.stubs</code>, artifactId: <code>anotherService</code>, latest version, default classifier (<code>stubs</code>) and register it at port 9095</li>
</ul>


<h4>Via fluent API</h4>

<p>When using the AccurestRule you can add a stub to download and then pass the port for the last downloaded stub.</p>

<pre><code>@ClassRule public static AccurestRule rule = new AccurestRule()
                .repoRoot(repoRoot())
                .downloadStub("io.codearte.accurest.stubs", "loanIssuance")
                .withPort(12345)
                .downloadStub("io.codearte.accurest.stubs:fraudDetectionServer:12346");
</code></pre>

<p>You can see that for this example the following test is valid:</p>

<pre><code>then(rule.findStubUrl("loanIssuance")).isEqualTo(URI.create("https://localhost:12345").toURL());
then(rule.findStubUrl("fraudDetectionServer")).isEqualTo(URI.create("https://localhost:12346").toURL());
</code></pre>

<h2>Technical changes</h2>

<p>Apart from features we&rsquo;ve done some technical refactoring.</p>

<h3>Grape -> Aether</h3>

<p>I&rsquo;ve migrated the mechanism used to download dependencies from Groovy Grape to Aether. We had a lot of issues with Grape and Aether works very well for now. That&rsquo;s a backwards incompatible change so if you had some custom Grape configuration then you&rsquo;ll have to port it to Aether.</p>

<h3>Dependencies fixed</h3>

<p>We had some problems with explicit and transitive dependencies that got fixed. The Accurest jars should be smaller.</p>

<h3>Summary</h3>

<ul>
<li>A lot work was done around Accurest and CDC</li>
<li>Quite soon we&rsquo;ll release the 1.1.0 version</li>
<li>You can use stubs of your dependencies that communicate over messaging</li>
<li>You can use fixed ports and versions for your dependencies</li>
<li>If you like the project star it on <a href="https://github.com/Codearte/accurest">Github</a> :) That will give us additional boost of energy to spend on coding instead of sleeping ;)</li>
</ul>


<h3>Links</h3>

<ul>
<li><a href="https://github.com/Codearte/accurest">Accurest Github Repository</a></li>
<li><a href="https://codearte.github.io/accurest">Accurest Documentation</a></li>
<li><a href="https://codearte.github.io/accurest/#stub-runner">Stub Runner Documentation</a></li>
<li><a href="https://codearte.github.io/accurest/#stub-runner-for-messaging">Stub Runner Messaging Documentation</a></li>
<li><a href="https://gitter.im/Codearte/accurest">Accurest Gitter</a></li>
<li><a href="https://github.com/Codearte/accurest-maven-plugin">Accurest Maven Plugin</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
