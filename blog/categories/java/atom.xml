<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | TOO MUCH CODING]]></title>
  <link href="http://toomuchcoding.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://toomuchcoding.com/"/>
  <updated>2018-11-15T15:05:11+01:00</updated>
  <id>http://toomuchcoding.com/</id>
  <author>
    <name><![CDATA[Marcin Grzejszczak]]></name>
    <email><![CDATA[blog@toomuchcoding.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Concurrency in Web Applications]]></title>
    <link href="http://toomuchcoding.com/blog/2013/01/28/concurrency-in-web-applications/"/>
    <updated>2013-01-28T01:20:00-08:00</updated>
    <id>http://toomuchcoding.com/blog/2013/01/28/concurrency-in-web-applications</id>
    <content type="html"><![CDATA[<div class='post'>
Nice article about <a href="http://blog.atena.pl/zrownoleglenie-operacji-w-aplikacji-webowej-2">concurrency in web applications (in Polish)</a></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Drools Integration With Spring vs Manual Rules Creation]]></title>
    <link href="http://toomuchcoding.com/blog/2013/01/15/drools-integration-with-spring-vs/"/>
    <updated>2013-01-15T08:04:00-08:00</updated>
    <id>http://toomuchcoding.com/blog/2013/01/15/drools-integration-with-spring-vs</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />Hi!<br /><br />&nbsp;Often in your work you can come across with issues related to business logic. Let us assume that you have dozens of rules (for the time being in our project we have more than 50 and I used to work on a project where we had hundreds of those rules) that you have to implement, divide into some classes, subclasses, abstractions and of course unit test. This can be difficult and timeconsuming to both write and support. There are many ways of dealing with this problem and I will show you one of them - JBoss Drools.<br />
<!--more-->
<br />Drools is a library specifically created for such purposes like implementing rules. As presented in Wikipedia:<br /><blockquote class="tr_bq">"Drools is a rule engine implementaion based on Charles Forgy's Rete Algorithm tailored for the Java language."&nbsp;</blockquote>It contains a rule engine that can process rules wirtten using the Drools language (you can also provide rules in Excel spreadsheets! - perfect for Business side to support and maintain).<br /><br />In the following example we will take a look at the way one can integrate JBoss Drools with Spring and an example of solving a similar problem without Drools.<br /><br /><br /><a name='more'></a><br /><br />Let us assume that we hava a POJO - a product that can represent either a Medical or Electronic product.&nbsp; <br /><br /><b>Product.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.model;<br /><br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />public class Product {<br />    private final TypeEnum typeEnum;<br />    private String productName;<br /><br />    public Product(TypeEnum typeEnum) {<br />        this.typeEnum = typeEnum;<br />        productName = typeEnum.getSomeOutputString();<br />    }<br /><br />    public TypeEnum getTypeEnum() {<br />        return typeEnum;<br />    }<br /><br />    public String getProductName() {<br />        return productName;<br />    }<br /><br />    public void setProductName(String productName) {<br />        this.productName = productName;<br />    }<br />}<br /><br /></pre>What defines the type of a product is the TypeEnum. It also has an outputString - let's assume that it defines a brand of a product (or whatever you want ;) )<br /><br /><b>TypeEnum.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.enums;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />public enum TypeEnum {<br />    MEDICAL("medical", "aaabbbccc"), ELECTRONIC("electronic", "cccbbbaaa");<br /><br /><br />    private final String type;<br />    private final String someOutputString;<br /><br />    private TypeEnum(String type, String someOutputString) {<br />        this.type = type;<br />        this.someOutputString = someOutputString;<br />    }<br /><br />    public String getType() {<br />        return type;<br />    }<br /><br />    public String getSomeOutputString() {<br />        return someOutputString;<br />    }<br />}<br /></pre><br />Let's say that the logic behind our rools is such that depending on the type of the enum we want to have some processing done (in our case we will have the same type of processing - converting each 'a' to 'b' in the output string).<br /><br /><b>NoRulesProductServiceImpl.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.nondrools;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br />import pl.grzejszczak.marcin.drools.springintegration.service.ProductService;<br /><br />import java.util.List;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("NoRulesProductServiceImpl")<br />public class NoRulesProductServiceImpl implements ProductService {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(NoRulesProductServiceImpl.class);<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingService")<br />    private Processor&lt;List&lt;Product&gt;&gt; productProcessingService;<br /><br />    @Override<br />    public void runProductLogic() {<br />        LOGGER.debug("Running product logic without Drools");<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        LOGGER.debug("Running rules for products...");<br />        productProcessingService.process(newArrayList(medicalProduct, electronicProduct));<br />        LOGGER.debug("...finished running products.");<br />    }<br />}<br /></pre><br />The ProductProcessingService is itterating over the given products, finds a producer for them and processes them.<br /><br /><b>ProductProcessingService.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.nondrools;<br /><br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br /><br />import java.util.List;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("ProductProcessingService")<br />public class ProductProcessingService implements Processor&lt;List&lt;Product&gt;&gt; {<br /><br />    @Autowired<br />    @Qualifier("NoRulesProcessingFactory")<br />    private ProcessingFactory&lt;Processor, Product&gt; processingFactory;<br /><br />    @Override<br />    public void process(List&lt;Product&gt; input) {<br />        for(Product product : input){<br />            Processor&lt;Product&gt; processor = processingFactory.createProcessingObject(product);<br />            processor.process(product);<br />        }<br />    }<br />}<br /></pre><br />The ProcessingFactory is an interface that basing on the given input (Product) produces an ouput (Processor) that afterwards does further processing. In our case we have a factory that instead of using a bunch of ifs (imagine that we have more than just two types of products) is using a map that matches a type of product with an implementation of a processor. As you can see we change a sequence of ifs into a single get.<br /><br /><b>NoRulesProcessingFactory.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.factory.nondrools;<br /><br />import com.google.common.collect.ImmutableMap;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.nondrools.ElectronicProductProcessingService;<br />import pl.grzejszczak.marcin.drools.springintegration.service.nondrools.MedicalProductProcessingService;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br /><br />import java.util.Map;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("NoRulesProcessingFactory")<br />public class NoRulesProcessingFactory  implements ProcessingFactory&lt;Processor, Product&gt; {<br /><br />    private static final Map&lt;TypeEnum, Processor&gt; PROCESSOR_MAP = new ImmutableMap.Builder&lt;TypeEnum, Processor&gt;().<br />            put(TypeEnum.MEDICAL, new MedicalProductProcessingService()).<br />            put(TypeEnum.ELECTRONIC, new ElectronicProductProcessingService()).<br />            build();<br /><br />    /**<br />     * By using the map we don't have any ifs<br />     * @param inputObject<br />     * @return<br />     */<br />    @Override<br />    public Processor createProcessingObject(Product inputObject) {<br />        return PROCESSOR_MAP.get(inputObject.getTypeEnum());<br />    }<br />}<br /></pre><br />I will present here only one ProcessingService since the other one is exactly the same (I just wanted to show the concept).<br /><br /><b>ElectronicProductProcessingService.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.nondrools;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br />import pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil;<br /><br />import static com.google.common.base.Preconditions.checkArgument;<br />import static java.lang.String.format;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />public class ElectronicProductProcessingService implements Processor&lt;Product&gt; {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ElectronicProductProcessingService.class);<br /><br />    @Override<br />    public void process(Product input) {<br />        checkArgument(TypeEnum.ELECTRONIC.equals(input.getTypeEnum()), "This processing service works only for electronic devices");<br />        checkArgument(!SomeUtil.replaceAWithB(input.getProductName()).equals(input.getProductName()), "The input has already been processed");<br />        LOGGER.debug("Running processing for Electronic Product");<br />        input.setProductName(SomeUtil.replaceAWithB(input.getProductName()));<br />        LOGGER.debug(format("ELECTRONIC rule applied without Drools, product name is now equal to [%s]", input.getProductName()));<br />    }<br />}<br /></pre><br />As you can see there are quite a few things that need to be tested and supported here. Imagine what would happen if we had 100 of types with more sophisticated rules than merely replacing one letter with the other.  So how can we do it with Drools? Let's start with taking a look at the pom.xml.<br /><br /><b>pom.xml  </b><br /><br /><pre class="brush:xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br /> xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br /> &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br /> &lt;groupId&gt;pl.grzejszczak.marcin&lt;/groupId&gt;<br /> &lt;artifactId&gt;drools-spring-integration&lt;/artifactId&gt;<br /> &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br /><br /> &lt;properties&gt;<br />  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;<br />  &lt;maven.compiler.source&gt;1.6&lt;/maven.compiler.source&gt;<br />  &lt;maven.compiler.target&gt;1.6&lt;/maven.compiler.target&gt;<br /><br />  &lt;spring.version&gt;3.1.1.RELEASE&lt;/spring.version&gt;<br /> &lt;/properties&gt;<br /> &lt;repositories&gt;<br />  &lt;repository&gt;<br />   &lt;id&gt;spring-release&lt;/id&gt;<br />   &lt;url&gt;http://maven.springframework.org/release&lt;/url&gt;<br />  &lt;/repository&gt;<br /> &lt;/repositories&gt;<br /><br /> &lt;dependencies&gt;<br />  &lt;!-- Spring --&gt;<br />  &lt;dependency&gt;<br />   &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />   &lt;artifactId&gt;spring-core&lt;/artifactId&gt;<br />   &lt;version&gt;${spring.version}&lt;/version&gt;<br />  &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br />            &lt;version&gt;${spring.version}&lt;/version&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;<br />            &lt;artifactId&gt;guava&lt;/artifactId&gt;<br />            &lt;version&gt;13.0.1&lt;/version&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;<br />            &lt;version&gt;${spring.version}&lt;/version&gt;<br />        &lt;/dependency&gt;<br />  &lt;dependency&gt;<br />            &lt;groupId&gt;org.drools&lt;/groupId&gt;<br />            &lt;artifactId&gt;drools-spring&lt;/artifactId&gt;<br />            &lt;version&gt;5.4.0.Final&lt;/version&gt;<br />        &lt;/dependency&gt;<br />  &lt;dependency&gt;<br />            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br />            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;<br />            &lt;version&gt;1.6.6&lt;/version&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;junit&lt;/groupId&gt;<br />            &lt;artifactId&gt;junit&lt;/artifactId&gt;<br />            &lt;version&gt;4.10&lt;/version&gt;<br />            &lt;scope&gt;test&lt;/scope&gt;<br />        &lt;/dependency&gt;<br /><br />    &lt;/dependencies&gt;<br />&lt;/project&gt;<br /><br /></pre>Let's take a look at the applicationContext.xml and the drools-context.xml. As for the first one what we do in fact is just showing where to scan for classes in terms of Spring and where to import the drools context from.<br /><br /><b>applicationContext.xml  </b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xsi:schemaLocation="http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd<br />                           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;<br /><br />    &lt;import resource="classpath:drools-context.xml"/&gt;<br />    &lt;!-- Show Spring where to search for the beans (in which packages) --&gt;<br />    &lt;context:component-scan base-package="pl.grzejszczak.marcin.drools.springintegration" /&gt;<br /><br />&lt;/beans&gt;<br /></pre><br />The context for drools. Take a look at the aliases for productsKSession. By providing alias we are joining two potential knowledge sessions into a single one. A single knowledge session is defined for a single knowledge base. For the knowledge base we are providing the list (in our case just a single resource) of drl files (we could have provided an excel spreadsheet).<br /><br /><b>drools-context.xml  </b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:drools="http://drools.org/schema/drools-spring"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />  http://drools.org/schema/drools-spring http://drools.org/schema/drools-spring.xsd"&gt;<br /><br />    &lt;!-- KNOWLEDGE BASE FOR A GIVEN TYPE --&gt;<br />    &lt;drools:kbase id="productsKBase"&gt;<br />        &lt;drools:resources&gt;<br />            &lt;drools:resource type="DRL"<br />                             source="classpath:rules/products.drl"/&gt;<br />        &lt;/drools:resources&gt;<br />    &lt;/drools:kbase&gt;<br /><br />    &lt;drools:ksession id="productsKSession" name="productsKSession" type="stateless" kbase="productsKBase"/&gt;<br />    &lt;alias name="productsKSession" alias="electronicKSession"/&gt;<br />    &lt;alias name="productsKSession" alias="medicalKSession"/&gt;<br /><br />&lt;/beans&gt;<br /></pre><br />Let's check the drl file.<br /><br />We define two rules - "MEDICAL rule" and "ELECTRONIC rule". For each case we are checking:<br /><br /><ul><li>whether the input object is of Product type&nbsp;</li><li>whether it has typeEnum equal to either Medical or Electronic&nbsp;</li><li>whether it hasn't already had it's productName changed&nbsp;</li></ul><br />Then we are addressing the product by means of a variable $product. We are modifying the product using the <span style="font-family: Courier New, Courier, monospace;">modify </span>keyword (which means that all the rules are rechecked - try removing the condition 'productName != replaceAWithB($product.typeEnum.someOutputString' and you will have an endless loop) by setting a new productName. Take a look at all the imports and imports of functions. You can execute a static function (pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil.replaceAWithB or org.drools.core.util.StringUtils.isEmpty) by importing it in the drl file.<br />At the end we are logging that a rule has been applied.<br /><br /><b>products.drl  </b><br /><br /><pre class="brush:xml">package pl.grzejszczak.marcin<br /><br />import org.slf4j.LoggerFactory<br />import pl.grzejszczak.marcin.drools.springintegration.DroolsSpring<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum<br /><br />import function pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil.replaceAWithB<br />import function org.drools.core.util.StringUtils.isEmpty<br /><br /><br />rule "MEDICAL rule"<br /> dialect "mvel"<br />when<br />     $product : Product( typeEnum == TypeEnum.MEDICAL, productName != replaceAWithB($product.typeEnum.someOutputString) )<br />then<br />     modify ($product) {productName = replaceAWithB($product.typeEnum.someOutputString)}<br />     LoggerFactory.getLogger(DroolsSpring.class).debug(String.format("MEDICAL rule applied, product name is now equal to [%s]", $product.productName))<br />end<br /><br />rule "ELECTRONIC rule"<br /> dialect "mvel"<br />when<br />     $product : Product( typeEnum == TypeEnum.ELECTRONIC, productName != replaceAWithB($product.typeEnum.someOutputString) )<br />then<br />     modify ($product) {productName = replaceAWithB($product.typeEnum.someOutputString)}<br />     LoggerFactory.getLogger(DroolsSpring.class).debug(String.format("ELECTRONIC rule applied, product name is now equal to [%s]", $product.productName))<br />end<br /></pre><br />We use a factory that is choosing a proper StatelessKnowledgeSession - since we only want to modify an input object. In order to run Drools rules we are running the execute method with a list of input objects.&nbsp; <br /><br /><b>ProductServiceImpl.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.drools;<br /><br />import org.drools.runtime.StatelessKnowledgeSession;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.ProductService;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("ProductServiceImpl")<br />public class ProductServiceImpl implements ProductService {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ProductServiceImpl.class);<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingFactory")<br />    ProcessingFactory&lt;StatelessKnowledgeSession, Product&gt; processingFactory;<br /><br />    @Override<br />    public void runProductLogic() {<br />        LOGGER.debug("Running product logic");<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        StatelessKnowledgeSession statelessKnowledgeSession = processingFactory.createProcessingObject(medicalProduct);<br />        LOGGER.debug("Running rules for products...");<br />        statelessKnowledgeSession.execute(newArrayList(medicalProduct, electronicProduct));<br />        LOGGER.debug("...finished running products.");<br />    }<br />}<br /><br /></pre>Now let's have a look on how the factory is implemented. We are using aliases in the applicationContext.xml<br /><br /><b>ProductProcessingFactory.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.factory.drools;<br /><br />import org.drools.runtime.StatelessKnowledgeSession;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.context.ApplicationContext;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("ProductProcessingFactory")<br />public class ProductProcessingFactory implements ProcessingFactory&lt;StatelessKnowledgeSession, Product&gt; {<br /><br />    @Autowired<br />    private ApplicationContext applicationContext;<br /><br />    @Override<br />    public StatelessKnowledgeSession createProcessingObject(Product inputObject) {<br />        return (StatelessKnowledgeSession)applicationContext.getBean(inputObject.getTypeEnum().getType() + "KSession");<br />    }<br />}<br /></pre>Now how can we test if it works? I have two unit tests that prove it (they are not running in perfect isolation but they functionality of both approaches). Starting with the test for the manual rules creation test. <br /><br /><b>NoRulesProductServiceImplTest.java </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service;<br /><br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil;<br /><br />import java.util.List;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br />import static java.lang.String.format;<br />import static org.junit.Assert.assertEquals;<br />import static org.junit.Assert.assertNotSame;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = {"classpath:applicationContext.xml"})<br />public class NoRulesProductServiceImplTest {<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingService")<br />    private Processor&lt;List&lt;Product&gt;&gt; productProcessingService;<br /><br /><br />    /**<br />     * Test is not run in perfect isolation - the purpose is to show the outcome of processing without Drools<br />     *<br />     * @throws Exception<br />     */<br />    @Test<br />    public void testRunProductLogic() throws Exception {<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        String initialMedicalProductName = medicalProduct.getProductName();<br />        String initialElectronicProduct = electronicProduct.getProductName();<br />        System.out.println(format("Initial productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Initial productName for Electronic [%s]", electronicProduct.getProductName()));<br /><br />        productProcessingService.process(newArrayList(medicalProduct, electronicProduct));<br /><br />        String finalMedicalProduct = medicalProduct.getProductName();<br />        String finalElectronicProduct = electronicProduct.getProductName();<br />        assertNotSame(finalMedicalProduct, initialMedicalProductName);<br />        assertNotSame(finalElectronicProduct, initialElectronicProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialMedicalProductName), finalMedicalProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialElectronicProduct), finalElectronicProduct);<br /><br />        System.out.println(format("Final productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Final productName for Electronic [%s]", electronicProduct.getProductName()));<br />    }<br />}<br /></pre><br />And the unit test for the Drools approach.<br /><br /><b>ProductServiceImplTest.java </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service;<br /><br />import org.drools.runtime.StatelessKnowledgeSession;<br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br />import static java.lang.String.format;<br />import static org.junit.Assert.assertEquals;<br />import static org.junit.Assert.assertNotSame;<br />import static org.junit.Assert.assertTrue;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = {"classpath:applicationContext.xml"})<br />public class ProductServiceImplTest {<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingFactory")<br />    ProcessingFactory&lt;StatelessKnowledgeSession, Product&gt; processingFactory;<br /><br />    /**<br />     * Test is not run in perfect isolation - the purpose is to show the outcome of processing with Drools<br />     * @throws Exception<br />     */<br />    @Test<br />    public void testRunProductLogic() throws Exception {<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        String initialMedicalProductName = medicalProduct.getProductName();<br />        String initialElectronicProduct = electronicProduct.getProductName();<br />        System.out.println(format("Initial productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Initial productName for Electronic [%s]", electronicProduct.getProductName()));<br /><br />        StatelessKnowledgeSession statelessKnowledgeSessionForMedical = processingFactory.createProcessingObject(medicalProduct);<br />        StatelessKnowledgeSession statelessKnowledgeSessionForElectronic = processingFactory.createProcessingObject(electronicProduct);<br />        assertTrue(statelessKnowledgeSessionForMedical == statelessKnowledgeSessionForElectronic);<br />        System.out.println("References for stateless sessions are the same, executing rules...");<br /><br />        statelessKnowledgeSessionForMedical.execute(newArrayList(medicalProduct, electronicProduct));<br /><br />        String finalMedicalProduct = medicalProduct.getProductName();<br />        String finalElectronicProduct = electronicProduct.getProductName();<br />        assertNotSame(finalMedicalProduct, initialMedicalProductName);<br />        assertNotSame(finalElectronicProduct, initialElectronicProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialMedicalProductName), finalMedicalProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialElectronicProduct), finalElectronicProduct);<br /><br />        System.out.println(format("Final productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Final productName for Electronic [%s]", electronicProduct.getProductName()));<br />    }<br />}<br /></pre>Now let's take a look at the logs - take a look that 'Executing some logic' took place 6 times for Drools since when you modify an object the rules are revalidated and rerun:  <br /><br /><pre class="brush:xml">org.springframework.context.support.ClassPathXmlApplicationContext:495 Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@743399: startup date [Tue Jan 15 16:32:30 CET 2013]; root of context hierarchy<br />org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [applicationContext.xml]<br />org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [drools-context.xml]<br />[main] org.springframework.beans.factory.support.DefaultListableBeanFactory:557 Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@3b1d04: defining beans [productsKBase,productsKSession,ProductProcessingFactory,NoRulesProcessingFactory,ProductServiceImpl,NoRulesProductServiceImpl,ProductProcessingService,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy<br />pl.grzejszczak.marcin.drools.springintegration.service.drools.ProductServiceImpl:32 Running product logic<br />pl.grzejszczak.marcin.drools.springintegration.service.drools.ProductServiceImpl:36 Running rules for products...<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.DroolsSpring:? ELECTRONIC rule applied, product name is now equal to [cccbbbbbb]<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.DroolsSpring:? MEDICAL rule applied, product name is now equal to [bbbbbbccc]<br />pl.grzejszczak.marcin.drools.springintegration.service.drools.ProductServiceImpl:38 ...finished running products.<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.NoRulesProductServiceImpl:33 Running product logic without Drools<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.NoRulesProductServiceImpl:36 Running rules for products...<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.MedicalProductProcessingService:26 Running processing for Medical Product<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.MedicalProductProcessingService:28 MEDICAL rule applied without Drools, product name is now equal to [bbbbbbccc]<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.ElectronicProductProcessingService:26 Running processing for Electronic Product<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.ElectronicProductProcessingService:28 ELECTRONIC rule applied without Drools, product name is now equal to [cccbbbbbb]<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.NoRulesProductServiceImpl:38 ...finished running products.<br /></pre><br />Viola! That's how you can write some rules with Drools that can save plenty of time and effort as far as business logic is concerned. You can find the sources here at my <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/3d8a2ef67b5b/Drools/Spring%20integration?at=default">BitBucket repository</a>.</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hamcrest Matchers, Guava Predicate and Builder Design Pattern]]></title>
    <link href="http://toomuchcoding.com/blog/2013/01/03/hamcrest-matchers-guava-predicate-and/"/>
    <updated>2013-01-03T16:35:00-08:00</updated>
    <id>http://toomuchcoding.com/blog/2013/01/03/hamcrest-matchers-guava-predicate-and</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />Hi coding addicts :)<br /><br />Often, while coding we have to deal with some POJO objects that have dozens of fields in them. Many times we initialize those classes through a constructor having dozens of arguments which is terrible in any possibly imaginable way :) Apart from that the functions that use those constructors are hardly testable. Let's take a closer look at using a Builder to change that situation, together with Hamcrest matchers and Guava Predicates to unit test it.<br />
<!--more-->
<br />Let's start off with taking a look at the POJO class.<br /><br /><br /><a name='more'></a><br /><br /><b>SomeBigPojo.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.pojo;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 21:05<br /> */<br />public class SomeBigPojo {<br />    private String stringField0;<br />    private Integer integerField0;<br />    private Boolean booleanField0;<br />    private String stringField1;<br />    private Integer integerField1;<br />    private Boolean booleanField1;<br />    private String stringField2;<br />    private Integer integerField2;<br />    private Boolean booleanField2;<br />    private String stringField3;<br />    private Integer integerField3;<br />    private Boolean booleanField3;<br />    private String stringField4;<br />    private Integer integerField4;<br />    private Boolean booleanField4;<br />    private String stringField5;<br />    private Integer integerField5;<br />    private Boolean booleanField5;<br />    private String stringField6;<br />    private Integer integerField6;<br />    private Boolean booleanField6;<br />    private String stringField7;<br />    private String stringField8;<br />    private String stringField9;<br /><br />    public SomeBigPojo(String stringField0, Integer integerField0, Boolean booleanField0, String stringField1, Integer integerField1, Boolean booleanField1, String stringField2, Integer integerField2, Boolean booleanField2, String stringField3, Integer integerField3, Boolean booleanField3, String stringField4, Integer integerField4, Boolean booleanField4, String stringField5, Integer integerField5, Boolean booleanField5, String stringField6, Integer integerField6, Boolean booleanField6, String stringField7, String stringField8, String stringField9) {<br />        this.stringField0 = stringField0;<br />        this.integerField0 = integerField0;<br />        this.booleanField0 = booleanField0;<br />        this.stringField1 = stringField1;<br />        this.integerField1 = integerField1;<br />        this.booleanField1 = booleanField1;<br />        this.stringField2 = stringField2;<br />        this.integerField2 = integerField2;<br />        this.booleanField2 = booleanField2;<br />        this.stringField3 = stringField3;<br />        this.integerField3 = integerField3;<br />        this.booleanField3 = booleanField3;<br />        this.stringField4 = stringField4;<br />        this.integerField4 = integerField4;<br />        this.booleanField4 = booleanField4;<br />        this.stringField5 = stringField5;<br />        this.integerField5 = integerField5;<br />        this.booleanField5 = booleanField5;<br />        this.stringField6 = stringField6;<br />        this.integerField6 = integerField6;<br />        this.booleanField6 = booleanField6;<br />        this.stringField7 = stringField7;<br />        this.stringField8 = stringField8;<br />        this.stringField9 = stringField9;<br />    }<br /><br />    public String getStringField0() {<br />        return stringField0;<br />    }<br /><br />    public void setStringField0(String stringField0) {<br />        this.stringField0 = stringField0;<br />    }<br /><br />    public Integer getIntegerField0() {<br />        return integerField0;<br />    }<br /><br />    public void setIntegerField0(Integer integerField0) {<br />        this.integerField0 = integerField0;<br />    }<br /><br />    public Boolean getBooleanField0() {<br />        return booleanField0;<br />    }<br /><br />    public void setBooleanField0(Boolean booleanField0) {<br />        this.booleanField0 = booleanField0;<br />    }<br /><br />    public String getStringField1() {<br />        return stringField1;<br />    }<br /><br />    public void setStringField1(String stringField1) {<br />        this.stringField1 = stringField1;<br />    }<br /><br />    public Integer getIntegerField1() {<br />        return integerField1;<br />    }<br /><br />    public void setIntegerField1(Integer integerField1) {<br />        this.integerField1 = integerField1;<br />    }<br /><br />    public Boolean getBooleanField1() {<br />        return booleanField1;<br />    }<br /><br />    public void setBooleanField1(Boolean booleanField1) {<br />        this.booleanField1 = booleanField1;<br />    }<br /><br />    public String getStringField2() {<br />        return stringField2;<br />    }<br /><br />    public void setStringField2(String stringField2) {<br />        this.stringField2 = stringField2;<br />    }<br /><br />    public Integer getIntegerField2() {<br />        return integerField2;<br />    }<br /><br />    public void setIntegerField2(Integer integerField2) {<br />        this.integerField2 = integerField2;<br />    }<br /><br />    public Boolean getBooleanField2() {<br />        return booleanField2;<br />    }<br /><br />    public void setBooleanField2(Boolean booleanField2) {<br />        this.booleanField2 = booleanField2;<br />    }<br /><br />    public String getStringField3() {<br />        return stringField3;<br />    }<br /><br />    public void setStringField3(String stringField3) {<br />        this.stringField3 = stringField3;<br />    }<br /><br />    public Integer getIntegerField3() {<br />        return integerField3;<br />    }<br /><br />    public void setIntegerField3(Integer integerField3) {<br />        this.integerField3 = integerField3;<br />    }<br /><br />    public Boolean getBooleanField3() {<br />        return booleanField3;<br />    }<br /><br />    public void setBooleanField3(Boolean booleanField3) {<br />        this.booleanField3 = booleanField3;<br />    }<br /><br />    public String getStringField4() {<br />        return stringField4;<br />    }<br /><br />    public void setStringField4(String stringField4) {<br />        this.stringField4 = stringField4;<br />    }<br /><br />    public Integer getIntegerField4() {<br />        return integerField4;<br />    }<br /><br />    public void setIntegerField4(Integer integerField4) {<br />        this.integerField4 = integerField4;<br />    }<br /><br />    public Boolean getBooleanField4() {<br />        return booleanField4;<br />    }<br /><br />    public void setBooleanField4(Boolean booleanField4) {<br />        this.booleanField4 = booleanField4;<br />    }<br /><br />    public String getStringField5() {<br />        return stringField5;<br />    }<br /><br />    public void setStringField5(String stringField5) {<br />        this.stringField5 = stringField5;<br />    }<br /><br />    public Integer getIntegerField5() {<br />        return integerField5;<br />    }<br /><br />    public void setIntegerField5(Integer integerField5) {<br />        this.integerField5 = integerField5;<br />    }<br /><br />    public Boolean getBooleanField5() {<br />        return booleanField5;<br />    }<br /><br />    public void setBooleanField5(Boolean booleanField5) {<br />        this.booleanField5 = booleanField5;<br />    }<br /><br />    public String getStringField6() {<br />        return stringField6;<br />    }<br /><br />    public void setStringField6(String stringField6) {<br />        this.stringField6 = stringField6;<br />    }<br /><br />    public Integer getIntegerField6() {<br />        return integerField6;<br />    }<br /><br />    public void setIntegerField6(Integer integerField6) {<br />        this.integerField6 = integerField6;<br />    }<br /><br />    public Boolean getBooleanField6() {<br />        return booleanField6;<br />    }<br /><br />    public void setBooleanField6(Boolean booleanField6) {<br />        this.booleanField6 = booleanField6;<br />    }<br /><br />    public String getStringField7() {<br />        return stringField7;<br />    }<br /><br />    public void setStringField7(String stringField7) {<br />        this.stringField7 = stringField7;<br />    }<br /><br />    public String getStringField8() {<br />        return stringField8;<br />    }<br /><br />    public void setStringField8(String stringField8) {<br />        this.stringField8 = stringField8;<br />    }<br /><br />    public String getStringField9() {<br />        return stringField9;<br />    }<br /><br />    public void setStringField9(String stringField9) {<br />        this.stringField9 = stringField9;<br />    }<br /><br />    @Override<br />    public String toString() {<br />        final StringBuilder sb = new StringBuilder();<br />        sb.append("SomeBigPojo");<br />        sb.append("{stringField0='").append(stringField0).append('\'');<br />        sb.append(", integerField0=").append(integerField0);<br />        sb.append(", booleanField0=").append(booleanField0);<br />        sb.append(", stringField1='").append(stringField1).append('\'');<br />        sb.append(", integerField1=").append(integerField1);<br />        sb.append(", booleanField1=").append(booleanField1);<br />        sb.append(", stringField2='").append(stringField2).append('\'');<br />        sb.append(", integerField2=").append(integerField2);<br />        sb.append(", booleanField2=").append(booleanField2);<br />        sb.append(", stringField3='").append(stringField3).append('\'');<br />        sb.append(", integerField3=").append(integerField3);<br />        sb.append(", booleanField3=").append(booleanField3);<br />        sb.append(", stringField4='").append(stringField4).append('\'');<br />        sb.append(", integerField4=").append(integerField4);<br />        sb.append(", booleanField4=").append(booleanField4);<br />        sb.append(", stringField5='").append(stringField5).append('\'');<br />        sb.append(", integerField5=").append(integerField5);<br />        sb.append(", booleanField5=").append(booleanField5);<br />        sb.append(", stringField6='").append(stringField6).append('\'');<br />        sb.append(", integerField6=").append(integerField6);<br />        sb.append(", booleanField6=").append(booleanField6);<br />        sb.append(", stringField7='").append(stringField7).append('\'');<br />        sb.append(", stringField8='").append(stringField8).append('\'');<br />        sb.append(", stringField9='").append(stringField9).append('\'');<br />        sb.append('}');<br />        return sb.toString();<br />    }<br />}<br /><br /></pre>Now take a look at the builder class that was used in order to get rid of usage of the humongous constructor. What is more you can set whatever you want to without the need to enter nulls for the undesired fields.<br /><br /><b>SomeBigPojoBuilder.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.builder;<br /><br />import pl.grzejszczak.marcin.junit.matchers.pojo.SomeBigPojo;<br /><br />import static com.google.common.base.Preconditions.checkNotNull;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 21:08<br /> */<br />public class SomeBigPojoBuilder {<br />    /** A field with some default value */<br />    private String stringField0 = "defaultValueForString0";<br />    /** A field with some default value */<br />    private Integer integerField0 = 100;<br />    /** A field with some default value */<br />    private Boolean booleanField0 = true;<br />    private String stringField1;<br />    private Integer integerField1;<br />    private Boolean booleanField1;<br />    private String stringField2;<br />    private Integer integerField2;<br />    private Boolean booleanField2;<br />    private String stringField3;<br />    private Integer integerField3;<br />    private Boolean booleanField3;<br />    private String stringField4;<br />    private Integer integerField4;<br />    private Boolean booleanField4;<br />    private String stringField5;<br />    private Integer integerField5;<br />    private Boolean booleanField5;<br />    private String stringField6;<br />    private Integer integerField6;<br />    private Boolean booleanField6;<br />    private String stringField7;<br />    private String stringField8;<br />    private String stringField9;<br /><br />    public SomeBigPojoBuilder setStringField0(String stringField0) {<br />        this.stringField0 = stringField0;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField0(Integer integerField0) {<br />        this.integerField0 = integerField0;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField0(Boolean booleanField0) {<br />        this.booleanField0 = booleanField0;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField1(String stringField1) {<br />        this.stringField1 = stringField1;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField1(Integer integerField1) {<br />        this.integerField1 = integerField1;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField1(Boolean booleanField1) {<br />        this.booleanField1 = booleanField1;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField2(String stringField2) {<br />        this.stringField2 = stringField2;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField2(Integer integerField2) {<br />        this.integerField2 = integerField2;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField2(Boolean booleanField2) {<br />        this.booleanField2 = booleanField2;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField3(String stringField3) {<br />        this.stringField3 = stringField3;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField3(Integer integerField3) {<br />        this.integerField3 = integerField3;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField3(Boolean booleanField3) {<br />        this.booleanField3 = booleanField3;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField4(String stringField4) {<br />        this.stringField4 = stringField4;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField4(Integer integerField4) {<br />        this.integerField4 = integerField4;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField4(Boolean booleanField4) {<br />        this.booleanField4 = booleanField4;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField5(String stringField5) {<br />        this.stringField5 = stringField5;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField5(Integer integerField5) {<br />        this.integerField5 = integerField5;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField5(Boolean booleanField5) {<br />        this.booleanField5 = booleanField5;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField6(String stringField6) {<br />        this.stringField6 = stringField6;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField6(Integer integerField6) {<br />        this.integerField6 = integerField6;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField6(Boolean booleanField6) {<br />        this.booleanField6 = booleanField6;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField7(String stringField7) {<br />        this.stringField7 = stringField7;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField8(String stringField8) {<br />        this.stringField8 = stringField8;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField9(String stringField9) {<br />        this.stringField9 = stringField9;<br />        return this;<br />    }<br /><br />    /**<br />     * Some function checking the state of our POJO<br />     */<br />    private void checkState(){<br />        checkNotNull(stringField1, "StringField1 must not be null!");<br />    }<br /><br />    public SomeBigPojo createSomeBigPojoWithBuilder() {<br />        checkState();<br />        return new SomeBigPojo(stringField0, integerField0, booleanField0, stringField1, integerField1, booleanField1, stringField2, integerField2, booleanField2, stringField3, integerField3, booleanField3, stringField4, integerField4, booleanField4, stringField5, integerField5, booleanField5, stringField6, integerField6, booleanField6, stringField7, stringField8, stringField9);<br />    }<br />}<br /></pre><br />Take a look at the function checkState that verifies whether the object is of a desired state. In this way we may disallow the creation of an object if some conditions where not fullfiled. For that case we are using the Guava's Predicate - checkNotNull method. <br /><br />Note that the concept behind the Builder pattern is to delegate creation of an object to a Builder. In fact in the pure Builder design pattern implementation we would have to have a Director, some abstraction over a Builder and the concrete implementation of the Builder as such. In our case we have a simplification of that pattern - I used the refactoring option of IntelliJ. What can be done to make it look even better is to remove the constructor from the POJO and pass the values only by setters (that's what in fact I did in one of my projects ;) ) <br /><br />Now let's take a look at some usage examples: <br /><b><br /></b><b>SomeServiceImpl.java </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.service;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import pl.grzejszczak.marcin.junit.matchers.builder.SomeBigPojoBuilder;<br />import pl.grzejszczak.marcin.junit.matchers.pojo.SomeBigPojo;<br /><br />import static java.lang.String.format;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 21:25<br /> */<br />public class SomeServiceImpl implements SomeService {<br />    private static final Logger LOGGER = LoggerFactory.getLogger(SomeServiceImpl.class);<br /><br />    /** Could be an abstraction of builders injected by a setter - possible to mock */<br />    private SomeBigPojoBuilder someBigPojoBuilder;<br /><br />    /**<br />     * Hard to unit test<br />     */<br />    @Override<br />    public void someLogicForAPojoWithoutBuilder() {<br />        LOGGER.debug("SomeLogicForAPojoWithoutBuilder executed");<br />        SomeBigPojo someBigPojo = new SomeBigPojo("string", 1, false, "other string", 123, true, "something else", 321, false, "yet another string", 111, true, "something", 2, false, "More", 3, true, "String", 12, false, "some", "value", "ofString");<br />        // Any chance of knowing what is the value of stringField8 basing on the constructor?<br />        LOGGER.debug(format("StringField8 is equal [%s]%n", someBigPojo.getStringField8()));<br />        // Print the object<br />        LOGGER.debug(someBigPojo.toString());<br />    }<br /><br />    @Override<br />    public void someLogicForAPojoWithBuilder() {<br />        LOGGER.debug("SomeLogicForAPojoWithBuilder executed");<br />        SomeBigPojo someBigPojo = someBigPojoBuilder<br />                .setStringField0("string")<br />                .setIntegerField0(1)<br />                .setBooleanField0(false)<br />                .setStringField1("other string")<br />                .setIntegerField1(123)<br />                .setBooleanField1(true)<br />                .setStringField2("something else")<br />                .setIntegerField2(321)<br />                .setBooleanField2(false)<br />                .setStringField3("yet another string")<br />                .setIntegerField3(111)<br />                .setBooleanField3(false)<br />                .setStringField4("something")<br />                .setIntegerField4(2)<br />                .setBooleanField4(false)<br />                .setStringField5("More")<br />                .setIntegerField5(3)<br />                .setBooleanField5(true)<br />                .setStringField6("String")<br />                .setIntegerField6(12)<br />                .setBooleanField6(false)<br />                .setStringField7("some")<br />                .setStringField8("value")<br />                .setStringField9("ofString")<br />                .createSomeBigPojoWithBuilder();<br />        // Looking at the builder now I guess it's obvious what the value of StringField8<br />        LOGGER.debug(format("StringField8 is equal [%s]%n", someBigPojo.getStringField8()));<br />        // Print the object<br />        LOGGER.debug(someBigPojo.toString());<br />    }<br /><br />    @Override<br />    public void someLogicForAPojoWithBuilderBadArgument() {<br />        LOGGER.debug("someLogicForAPojoWithBuilderBadArgument executed");<br />        SomeBigPojo someBigPojo = someBigPojoBuilder<br />                .setStringField0("string")<br />                .setIntegerField0(1)<br />                .setBooleanField0(true)<br />                .setIntegerField1(123)<br />                .setBooleanField1(true)<br />                .setStringField2("something else")<br />                .setIntegerField2(321)<br />                .setBooleanField2(false)<br />                .setStringField3("yet another string")<br />                .setIntegerField3(111).setBooleanField3(false)<br />                .setStringField4("something")<br />                .setIntegerField4(2)<br />                .setBooleanField4(false)<br />                .setStringField5("More")<br />                .setIntegerField5(3)<br />                .setBooleanField5(true)<br />                .setStringField6("String")<br />                .setIntegerField6(12)<br />                .setBooleanField6(false)<br />                .setStringField7("some")<br />                .setStringField8("value")<br />                .setStringField9("ofString")<br />                .createSomeBigPojoWithBuilder();<br />        // Print the object - will we even see an output<br />        LOGGER.debug(someBigPojo.toString());<br />    }<br /><br />    public void setSomeBigPojoBuilder(SomeBigPojoBuilder someBigPojoBuilder) {<br />        this.someBigPojoBuilder = someBigPojoBuilder;<br />    }<br />}<br /><br /><br /></pre><br /><br />Notice how clear it is now to create an object and how easy is to define if a field has been set or not. <br /><br />Let's move on to Hamcrest matchers that will help us in unit testing of our classes. I will not try to do the complete, 100% code coverage - the idea behind this post is to show how Hamcrest Matchers can become an addition to your unit tests. <br /><br />Often unit tests are quite unclear and look like this:<br /><b><br /></b><b>SomeBigPojoBuilderNoMatchersAndNoRefactoringTest.java </b><br /><b><br /></b><br /><pre class="brush:java"></pre><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.builder;<br /><br />import org.junit.Before;<br />import org.junit.Test;<br />import pl.grzejszczak.marcin.junit.matchers.pojo.SomeBigPojo;<br /><br />import static junit.framework.Assert.assertTrue;<br />import static org.apache.commons.lang.StringUtils.isNumeric;<br />import static pl.grzejszczak.marcin.junit.matchers.pojo.SomePojoConstants.*;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 23:02<br /> */<br />public class SomeBigPojoBuilderNoMatchersAndNoRefactoringTest {<br /><br />    private SomeBigPojoBuilder objectUnderTest;<br /><br />    @Before<br />    public void setUp() {<br />        objectUnderTest = new SomeBigPojoBuilder();<br />    }<br /><br />    @Test<br />    public void testCreateSomeBigPojoWithBuilder() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setBooleanField1(true)<br />                .setStringField0("1")<br />                .setStringField1("12")<br />                .setStringField2("123")<br />                .setStringField3("1234")<br />                .setStringField4("12345")<br />                .setStringField5("123456")<br />                .setStringField6("1234567")<br />                .setStringField7("12345678")<br />                .setStringField8("123456789")<br />                .setStringField9("1234567890")<br />                .createSomeBigPojoWithBuilder();<br /><br />        isPojoProperlyBuilt(someBigPojo);<br />    }<br /><br />    @Test(expected = AssertionError.class)<br />    public void testCreateSomeBigPojoWithBuilderWrongFields() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setStringField0("0")<br />                .setStringField1("Too long")<br />                .createSomeBigPojoWithBuilder();<br /><br />        isPojoProperlyBuilt(someBigPojo);<br />    }<br /><br />    private void isPojoProperlyBuilt(SomeBigPojo someBigPojo) {<br />        assertTrue(someBigPojo.getStringField0().length() == STRING_FIELD_0_LENGTH);<br />        assertTrue(isNumeric(someBigPojo.getStringField0()));<br /><br />        assertTrue(someBigPojo.getStringField1().length() == STRING_FIELD_1_LENGTH);<br />        assertTrue(isNumeric(someBigPojo.getStringField0()));<br /><br />        assertTrue(someBigPojo.getStringField2().length() == STRING_FIELD_2_LENGTH);<br />        assertTrue(isNumeric(someBigPojo.getStringField0()));<br /><br />        assertTrue(someBigPojo.getStringField3().length() == STRING_FIELD_3_LENGTH);<br />        assertTrue(isNumeric(someBigPojo.getStringField0()));<br /><br />        assertTrue(someBigPojo.getStringField4().length() == STRING_FIELD_4_LENGTH);<br />        assertTrue(isNumeric(someBigPojo.getStringField0()));<br /><br />        assertTrue(someBigPojo.getStringField5().length() == STRING_FIELD_5_LENGTH);<br /><br />        assertTrue(someBigPojo.getStringField6().length() == STRING_FIELD_6_LENGTH);<br /><br />        assertTrue(someBigPojo.getStringField7().length() == STRING_FIELD_7_LENGTH);<br /><br />        assertTrue(someBigPojo.getStringField8().length() == STRING_FIELD_8_LENGTH);<br /><br />        assertTrue(someBigPojo.getStringField9().length() == STRING_FIELD_9_LENGTH);<br /><br />    }<br />}<br /><br /></pre><br />Simple refactoring can make them look nicer... <br /><br /><b>SomeBigPojoBuilderNoMatchersTest.java </b><br /><b><br /></b><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.builder;<br /><br />import org.junit.Before;<br />import org.junit.Test;<br />import pl.grzejszczak.marcin.junit.matchers.pojo.SomeBigPojo;<br /><br />import static junit.framework.Assert.assertNotNull;<br />import static junit.framework.Assert.assertTrue;<br />import static org.apache.commons.lang.StringUtils.isNumeric;<br />import static pl.grzejszczak.marcin.junit.matchers.pojo.SomePojoConstants.*;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 23:02<br /> */<br />public class SomeBigPojoBuilderNoMatchersTest {<br /><br />    private SomeBigPojoBuilder objectUnderTest;<br /><br />    @Before<br />    public void setUp() {<br />        objectUnderTest = new SomeBigPojoBuilder();<br />    }<br /><br />    @Test<br />    public void testCreateSomeBigPojoWithBuilder() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setBooleanField1(true)<br />                .setStringField0("1")<br />                .setStringField1("12")<br />                .setStringField2("123")<br />                .setStringField3("1234")<br />                .setStringField4("12345")<br />                .setStringField5("123456")<br />                .setStringField6("1234567")<br />                .setStringField7("12345678")<br />                .setStringField8("123456789")<br />                .setStringField9("1234567890")<br />                .createSomeBigPojoWithBuilder();<br /><br />        isPojoProperlyBuilt(someBigPojo);<br />    }<br /><br />    @Test(expected = AssertionError.class)<br />    public void testCreateSomeBigPojoWithBuilderWrongFields() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setStringField0("0")<br />                .setStringField1("too long")<br />                .createSomeBigPojoWithBuilder();<br /><br />        isPojoProperlyBuilt(someBigPojo);<br />    }<br /><br />    private void isPojoProperlyBuilt(SomeBigPojo someBigPojo) {<br />        isOfGivenLength(someBigPojo.getStringField0(), STRING_FIELD_0_LENGTH);<br />        isFieldOfNumericValue(someBigPojo.getStringField0());<br /><br />        isOfGivenLength(someBigPojo.getStringField1(), STRING_FIELD_1_LENGTH);<br />        isFieldOfNumericValue(someBigPojo.getStringField0());<br /><br />        isOfGivenLength(someBigPojo.getStringField2(), STRING_FIELD_2_LENGTH);<br />        isFieldOfNumericValue(someBigPojo.getStringField0());<br /><br />        isOfGivenLength(someBigPojo.getStringField3(), STRING_FIELD_3_LENGTH);<br />        isFieldOfNumericValue(someBigPojo.getStringField0());<br /><br />        isOfGivenLength(someBigPojo.getStringField4(), STRING_FIELD_4_LENGTH);<br />        isFieldOfNumericValue(someBigPojo.getStringField0());<br /><br />        isOfGivenLength(someBigPojo.getStringField5(), STRING_FIELD_5_LENGTH);<br /><br />        isOfGivenLength(someBigPojo.getStringField6(), STRING_FIELD_6_LENGTH);<br /><br />        isOfGivenLength(someBigPojo.getStringField7(), STRING_FIELD_7_LENGTH);<br /><br />        isOfGivenLength(someBigPojo.getStringField8(), STRING_FIELD_8_LENGTH);<br /><br />        isOfGivenLength(someBigPojo.getStringField9(), STRING_FIELD_9_LENGTH);<br /><br />    }<br /><br />    private void isOfGivenLength(String pojo, final Integer expectedLength) {<br />        assertNotNull(pojo);<br />        assertTrue(expectedLength == pojo.length());<br />    }<br /><br />    private void isFieldOfNumericValue(String field) {<br />        assertTrue(isNumeric(field));<br />    }<br />}<br /><br /></pre><br /><br />That looks nice, doesn't it? :) And how about using Matchers instead of functions? <br /><br /><b>SomeBigPojoBuilderTest.kava </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.builder;<br /><br />import org.hamcrest.BaseMatcher;<br />import org.hamcrest.Description;<br />import org.hamcrest.Matcher;<br />import org.junit.Before;<br />import org.junit.Test;<br />import pl.grzejszczak.marcin.junit.matchers.pojo.SomeBigPojo;<br /><br />import static java.lang.String.format;<br />import static junit.framework.Assert.assertTrue;<br />import static org.apache.commons.lang.StringUtils.isNumeric;<br />import static org.junit.Assert.assertThat;<br />import static pl.grzejszczak.marcin.junit.matchers.pojo.SomePojoConstants.*;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 23:02<br /> */<br />public class SomeBigPojoBuilderTest {<br /><br />    private SomeBigPojoBuilder objectUnderTest;<br /><br />    @Before<br />    public void setUp(){<br />        objectUnderTest = new SomeBigPojoBuilder();<br />    }<br /><br />    @Test<br />    public void testCreateSomeBigPojoWithBuilder() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setBooleanField1(true)<br />                .setStringField0("1")<br />                .setStringField1("12")<br />                .setStringField2("123")<br />                .setStringField3("1234")<br />                .setStringField4("12345")<br />                .setStringField5("123456")<br />                .setStringField6("1234567")<br />                .setStringField7("12345678")<br />                .setStringField8("123456789")<br />                .setStringField9("1234567890")<br />                .createSomeBigPojoWithBuilder();<br /><br />        assertThat(someBigPojo, isPojoProperlyBuilt());<br />    }<br /><br />    @Test(expected = AssertionError.class)<br />    public void testCreateSomeBigPojoWithBuilderWrongFields() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setStringField0("0")<br />                .setStringField1("Too long")<br />                .createSomeBigPojoWithBuilder();<br /><br />        assertThat(someBigPojo, isPojoProperlyBuilt());<br />    }<br /><br />    /**<br />     * Let us assume that there is a specific business case that we have to take into consideration regarding some particular field<br />     *<br />     * @return<br />     */<br />    private static Matcher isPojoProperlyBuilt() {<br /><br />        return new BaseMatcher() {<br /><br />            @Override<br />            public boolean matches(Object o) {<br />                assertTrue(o instanceof SomeBigPojo);<br />                SomeBigPojo someBigPojo = (SomeBigPojo) o;<br />                assertThat(someBigPojo.getStringField0(), isOfGivenLength(STRING_FIELD_0_LENGTH));<br />                assertThat(someBigPojo.getStringField0(), isFieldOfNumericValue());<br /><br />                assertThat(someBigPojo.getStringField1(), isOfGivenLength(STRING_FIELD_1_LENGTH));<br />                assertThat(someBigPojo.getStringField1(), isFieldOfNumericValue());<br /><br />                assertThat(someBigPojo.getStringField2(), isOfGivenLength(STRING_FIELD_2_LENGTH));<br />                assertThat(someBigPojo.getStringField2(), isFieldOfNumericValue());<br /><br />                assertThat(someBigPojo.getStringField3(), isOfGivenLength(STRING_FIELD_3_LENGTH));<br />                assertThat(someBigPojo.getStringField3(), isFieldOfNumericValue());<br /><br />                assertThat(someBigPojo.getStringField4(), isOfGivenLength(STRING_FIELD_4_LENGTH));<br />                assertThat(someBigPojo.getStringField4(), isFieldOfNumericValue());<br /><br />                assertThat(someBigPojo.getStringField5(), isOfGivenLength(STRING_FIELD_5_LENGTH));<br /><br />                assertThat(someBigPojo.getStringField6(), isOfGivenLength(STRING_FIELD_6_LENGTH));<br /><br />                assertThat(someBigPojo.getStringField7(), isOfGivenLength(STRING_FIELD_7_LENGTH));<br /><br />                assertThat(someBigPojo.getStringField8(), isOfGivenLength(STRING_FIELD_8_LENGTH));<br /><br />                assertThat(someBigPojo.getStringField9(), isOfGivenLength(STRING_FIELD_9_LENGTH));<br /><br />                return true;<br />            }<br /><br />            @Override<br />            public void describeTo(Description description) {<br />                description.appendText("Lengths of fields are limited and the first 4 fields are numeric");<br />            }<br />        };<br />    }<br /><br />    private static Matcher isOfGivenLength(final Integer expectedLength) {<br /><br />        return new BaseMatcher() {<br /><br />            public boolean matches(Object o) {<br />                assertTrue(o instanceof String);<br />                return expectedLength == String.valueOf(o).length();<br />            }<br /><br />            public void describeTo(Description description) {<br />                description.appendText(format("String's length should be equal to [%d]", expectedLength));<br />            }<br />        };<br />    }<br /><br />    private static Matcher isFieldOfNumericValue() {<br /><br />        return new BaseMatcher() {<br /><br />            public boolean matches(Object o) {<br />                assertTrue(o instanceof String);<br />                return isNumeric(String.valueOf(o));<br />            }<br /><br />            public void describeTo(Description description) {<br />                description.appendText("The value of the field should be numeric");<br />            }<br />        };<br />    }<br />}<br /><br /></pre><br />The following main method executes the functions of the Service:<br /><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers;<br /><br />import pl.grzejszczak.marcin.junit.matchers.builder.SomeBigPojoBuilder;<br />import pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 22:38<br /> */<br />public class MatcherMain {<br />    public static void main(String[] args){<br />        SomeServiceImpl someService = new SomeServiceImpl();<br /><br />        someService.setSomeBigPojoBuilder(new SomeBigPojoBuilder());<br />        someService.someLogicForAPojoWithoutBuilder();<br /><br />        someService.setSomeBigPojoBuilder(new SomeBigPojoBuilder());<br />        someService.someLogicForAPojoWithBuilder();<br /><br />        someService.setSomeBigPojoBuilder(new SomeBigPojoBuilder());<br />        someService.someLogicForAPojoWithBuilderBadArgument();<br />    }<br />}<br /><br /></pre><br />And the logs are:<br /><br /><br /><pre class="brush:xml">pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:27 SomeLogicForAPojoWithoutBuilder executed<br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:30 StringField8 is equal [value]<br /><br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:32 SomeBigPojo{stringField0='string', integerField0=1, booleanField0=false, stringField1='other string', integerField1=123, booleanField1=true, stringField2='something else', integerField2=321, booleanField2=false, stringField3='yet another string', integerField3=111, booleanField3=true, stringField4='something', integerField4=2, booleanField4=false, stringField5='More', integerField5=3, booleanField5=true, stringField6='String', integerField6=12, booleanField6=false, stringField7='some', stringField8='value', stringField9='ofString'}<br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:37 SomeLogicForAPojoWithBuilder executed<br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:65 StringField8 is equal [value]<br /><br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:67 SomeBigPojo{stringField0='string', integerField0=1, booleanField0=false, stringField1='other string', integerField1=123, booleanField1=true, stringField2='something else', integerField2=321, booleanField2=false, stringField3='yet another string', integerField3=111, booleanField3=false, stringField4='something', integerField4=2, booleanField4=false, stringField5='More', integerField5=3, booleanField5=true, stringField6='String', integerField6=12, booleanField6=false, stringField7='some', stringField8='value', stringField9='ofString'}<br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:72 someLogicForAPojoWithBuilderBadArgument executed<br />Exception in thread "main" java.lang.NullPointerException: StringField1 must not be null!<br /> at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:208)<br /> at pl.grzejszczak.marcin.junit.matchers.builder.SomeBigPojoBuilder.checkState(SomeBigPojoBuilder.java:166)<br /> at pl.grzejszczak.marcin.junit.matchers.builder.SomeBigPojoBuilder.createSomeBigPojoWithBuilder(SomeBigPojoBuilder.java:170)<br /> at pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl.someLogicForAPojoWithBuilderBadArgument(SomeServiceImpl.java:73)<br /> at pl.grzejszczak.marcin.junit.matchers.MatcherMain.main(MatcherMain.java:23)<br /> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br /> at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)<br /> at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)<br /> at java.lang.reflect.Method.invoke(Method.java:597)<br /> at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)</pre><br />In my opinion that looks really nice :) And what is yours?<br /><br /><a href="https://bitbucket.org/gregorin1987/too-much-coding/src/36becc07728e/Unit%20Testing%20-%20Matchers?at=default">Sources are available here at Too Much Codings code repository.</a><br /><br /><h2>UPDATE</h2><br />I've made some code changes and cleaning (not much though cause I didn't have too much time) and the code is available at github -&nbsp;<a href="https://github.com/marcingrzejszczak/too-much-coding/tree/master/Unit_Testing_-_Matchers">https://github.com/marcingrzejszczak/too-much-coding/tree/master/Unit_Testing_-_Matchers</a><br /><br /></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Guava Cache With Regular Expression Patterns]]></title>
    <link href="http://toomuchcoding.com/blog/2012/12/24/google-guava-cache-with-regular/"/>
    <updated>2012-12-24T05:54:00-08:00</updated>
    <id>http://toomuchcoding.com/blog/2012/12/24/google-guava-cache-with-regular</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />Hi!  Merry Christmas everyone :)  Quite recently I've seen <a href="http://toomuchcoding.blogspot.com/2012/12/google-guava.html">a nice presentation about Google Guava</a> and we came to the conclusion in our project that it could be really interesting to use the <a href="http://code.google.com/p/guava-libraries/wiki/CachesExplained">its Cache functionallity</a>.  Let us take a look at the regexp Pattern class and its <a href="http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#compile(java.lang.String)">compile function</a>. Quite often in the code we can see that each time a regular expression is being used a programmer is repeatidly calling the aforementioned Pattern.compile() function with the same argument thus compiling the same regular expression over and over again. What could be done however is to cache the result of such compilations - let us take a look at the RegexpUtils utility class:<br /><br />
<!--more-->
<b>RegexpUtils.java </b><br /><b><br /></b><pre class="brush:java">package pl.grzejszczak.marcin.guava.cache.utils;<br /><br />import com.google.common.cache.CacheBuilder;<br />import com.google.common.cache.CacheLoader;<br />import com.google.common.cache.LoadingCache;<br /><br />import java.util.concurrent.ExecutionException;<br />import java.util.regex.Matcher;<br />import java.util.regex.Pattern;<br /><br />import static java.lang.String.format;<br /><br />public final class RegexpUtils {<br /><br />    private RegexpUtils() {<br />        throw new UnsupportedOperationException("RegexpUtils is a utility class - don't instantiate it!");<br />    }<br /><br />    private static final LoadingCache&lt;String, Pattern&gt; COMPILED_PATTERNS =<br />            CacheBuilder.newBuilder().build(new CacheLoader&lt;String, Pattern&gt;() {<br />                @Override<br />                public Pattern load(String regexp) throws Exception {<br />                    return Pattern.compile(regexp);<br />                }<br />            });<br /><br />    public static Pattern getPattern(String regexp) {<br />        try {<br />            return COMPILED_PATTERNS.get(regexp);<br />        } catch (ExecutionException e) {<br />            throw new RuntimeException(format("Error when getting a pattern [%s] from cache", regexp), e);<br />        }<br />    }<br /><br />    public static boolean matches(String stringToCheck, String regexp) {<br />        return doGetMatcher(stringToCheck, regexp).matches();<br />    }<br /><br />    public static Matcher getMatcher(String stringToCheck, String regexp) {<br />        return doGetMatcher(stringToCheck, regexp);<br />    }<br /><br />    private static Matcher doGetMatcher(String stringToCheck, String regexp) {<br />        Pattern pattern = getPattern(regexp);<br />        return pattern.matcher(stringToCheck);<br />    }<br /><br />}<br /><br /></pre>As you can see the Guava's LoadingCache with the CacheBuilder is being used to populate a cache with a new compiled pattern if one is not found. Due to caching the compiled pattern if a compilation has already taken place it will not be repeated ever again (in our case since we dno't have any expiry set).  Now a simple test<br /><br /><b>GuavaCache.java </b><br /><b><br /></b><pre class="brush:java">package pl.grzejszczak.marcin.guava.cache;<br /><br /><br />import com.google.common.base.Stopwatch;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import pl.grzejszczak.marcin.guava.cache.utils.RegexpUtils;<br /><br />import java.util.regex.Pattern;<br /><br />import static java.lang.String.format;<br /><br />public class GuavaCache {<br />    private static final Logger LOGGER = LoggerFactory.getLogger(GuavaCache.class);<br />    public static final String STRING_TO_MATCH = "something";<br /><br />    public static void main(String[] args) {<br />        runTestForManualCompilationAndOneUsingCache(1);<br />        runTestForManualCompilationAndOneUsingCache(10);<br />        runTestForManualCompilationAndOneUsingCache(100);<br />        runTestForManualCompilationAndOneUsingCache(1000);<br />        runTestForManualCompilationAndOneUsingCache(10000);<br />        runTestForManualCompilationAndOneUsingCache(100000);<br />        runTestForManualCompilationAndOneUsingCache(1000000);<br />    }<br /><br />    private static void runTestForManualCompilationAndOneUsingCache(int firstNoOfRepetitions) {<br />        repeatManualCompilation(firstNoOfRepetitions);<br />        repeatCompilationWithCache(firstNoOfRepetitions);<br />    }<br /><br />    private static void repeatManualCompilation(int noOfRepetitions) {<br />        Stopwatch stopwatch = new Stopwatch().start();<br />        compileAndMatchPatternManually(noOfRepetitions);<br />        LOGGER.debug(format("Time needed to compile and check regexp expression [%d] ms, no of iterations [%d]", stopwatch.elapsedMillis(), noOfRepetitions));<br />    }<br /><br />    private static void repeatCompilationWithCache(int noOfRepetitions) {<br />        Stopwatch stopwatch = new Stopwatch().start();<br />        compileAndMatchPatternUsingCache(noOfRepetitions);<br />        LOGGER.debug(format("Time needed to compile and check regexp expression using Cache [%d] ms, no of iterations [%d]", stopwatch.elapsedMillis(), noOfRepetitions));<br />    }<br /><br />    private static void compileAndMatchPatternManually(int limit) {<br />        for (int i = 0; i &lt; limit; i++) {<br />            Pattern.compile("something").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something1").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something2").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something3").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something4").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something5").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something6").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something7").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something8").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something9").matcher(STRING_TO_MATCH).matches();<br />        }<br />    }<br /><br /><br />    private static void compileAndMatchPatternUsingCache(int limit) {<br />        for (int i = 0; i &lt; limit; i++) {<br />            RegexpUtils.matches(STRING_TO_MATCH, "something");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something1");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something2");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something3");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something4");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something5");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something6");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something7");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something8");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something9");<br />        }<br />    }<br /><br />}<br /><br /></pre>We are running a series of tests and checking the time of their execution. Note that the results of these tests are not precise due to the fact that the application is not being run in isolation so numerous conditions can affect the time of the execution. We are interested in showing some degree of the problem rather than showing the precise execution time.  For a given number of iterations (1,10,100,1000,10000,100000,1000000) we are either compiling 10 regular expressions or using a Guava's cache to retrieve the compiled Pattern and then we match them against a string to match.  These are the logs: <br /><br /><pre class="brush:xml">pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [1] ms, no of iterations [1]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [35] ms, no of iterations [1]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [1] ms, no of iterations [10]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [0] ms, no of iterations [10]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [8] ms, no of iterations [100]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [3] ms, no of iterations [100]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [10] ms, no of iterations [1000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [10] ms, no of iterations [1000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [83] ms, no of iterations [10000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [33] ms, no of iterations [10000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [800] ms, no of iterations [100000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [279] ms, no of iterations [100000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [7562] ms, no of iterations [1000000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [3067] ms, no of iterations [1000000]<br /></pre><br />You can find the <a href="https://bitbucket.org/gregorin1987/too-much-coding/src">sources over here</a> under the Guava/Cache directory or go to the url <a href="https://bitbucket.org/gregorin1987/too-much-coding/src">https://bitbucket.org/gregorin1987/too-much-coding/src</a>  </div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Guava]]></title>
    <link href="http://toomuchcoding.com/blog/2012/12/07/google-guava/"/>
    <updated>2012-12-07T04:18:00-08:00</updated>
    <id>http://toomuchcoding.com/blog/2012/12/07/google-guava</id>
    <content type="html"><![CDATA[<div class='post'>
Some interesting link:<br /><br /><a href="http://tomaszdziurko.pl/2012/02/google-guava/">Very nice presentation about Google Guava</a>, <a href="https://github.com/tdziurko/Guava-Lessons">sources</a></div>

]]></content>
  </entry>
  
</feed>
