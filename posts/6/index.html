<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
  <meta charset="utf-8">
  <title>TOO MUCH CODING</title>
  <meta name="author" content="Marcin Grzejszczak">

  
  

  <!-- https://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://toomuchcoding.com/posts/6/">
  <link rel="me" href="https://fosstodon.org/@toomuchcoding">
  <link href="/favicon.png" type="image/png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="TOO MUCH CODING" type="application/atom+xml">

  <!-- https://opengraphprotocol.org/ -->
  <meta name="twitter:card" content="summary_large_image">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://toomuchcoding.com/posts/6/">
  <meta property="og:title" content="TOO MUCH CODING">
  <meta property="og:description" content="A blog for coding addicts about Java, Groovy, Buzzword, Spring, Microservices, Buzzword">

  <script src="/javascripts/libs/jquery/jquery-2.1.3.min.js"></script>

<link href="/assets/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/assets/bootstrap/dist/css/bootstrap-theme.min.css" rel="stylesheet" type="text/css">
<link href="/assets/bootstrap/dist/css/custom.css" rel="stylesheet" type="text/css">




  
  <link href="/stylesheets/screen.css" media="screen, projection, print" rel="stylesheet" type="text/css">

  

</head>

  <body   >
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="wrap">
      <header role="banner">
        <nav class="navbar navbar-default" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" title="toggle navbar" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">TOO MUCH CODING</a>
        </div>

        <div class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li class="active">
                    <a rel="index" href="/">Blog</a>
                </li>
                <li >
                    <a href="/blog/archives">Archives</a>
                </li>
                <li >
                    <a href="/oss">OSS</a>
                </li>
                <li >
                    <a href="/abstracts">Abstracts</a>
                </li>
                <li >
                    <a href="/talks">Talks</a>
                </li>
                <li >
                    <a href="/publications">Publications</a>
                </li>
                <li >
                    <a href="/bio">Bio</a>
                </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a class="subscribe-rss" href="/atom.xml" title="subscribe via RSS">
                        <span class="visible-xs">RSS</span>
                        <img class="hidden-xs" src="/images/rss.png" alt="RSS">
                    </a>
                </li>
                
            </ul>
            
                <form class="navbar-form navbar-right" action="https://www.google.com/search" method="GET">
                    <input type="hidden" name="sitesearch" value="https://toomuchcoding.com">
                    <div class="form-group">
                        <input class="form-control" type="text" name="q" placeholder="Search">
                    </div>
                </form>
            
        </div>
    </div>
</nav>


      </header>
      <div id="main" role="main" class="container">
        <div id="content">
          <div class="row">
  <div class="page-content col-md-9">
    <div class="blog-index" itemscope itemtype="https://schema.org/Blog">
    <meta itemprop="name" content="TOO MUCH CODING" />
    <meta itemprop="description" content="A blog for coding addicts about Java, Groovy, Buzzword, Spring, Microservices, Buzzword" />
    <meta itemprop="url" content="https://toomuchcoding.com" />
      
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        










<span class="glyphicon glyphicon-calendar"></span> <time datetime="2013-01-15T17:04:00+01:00"  data-updated="true" itemprop="datePublished dateCreated">ordinal</time>
        
           | <a href="/articles/2013/01/15/drools-integration-with-spring-vs/#disqus_thread" itemprop="discussionUrl"
             data-disqus-identifier="https://toomuchcoding.com/articles/2013/01/15/drools-integration-with-spring-vs/">Comments</a>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/articles/2013/01/15/drools-integration-with-spring-vs/" itemprop="url">Drools integration with Spring vs manual rules creation</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><div class='post'>
<br /><br />Hi!<br /><br />&nbsp;Often in your work you can come across with issues related to business logic. Let us assume that you have dozens of rules (for the time being in our project we have more than 50 and I used to work on a project where we had hundreds of those rules) that you have to implement, divide into some classes, subclasses, abstractions and of course unit test. This can be difficult and timeconsuming to both write and support. There are many ways of dealing with this problem and I will show you one of them - JBoss Drools.<br />
<!--more-->
<br />Drools is a library specifically created for such purposes like implementing rules. As presented in Wikipedia:<br /><blockquote class="tr_bq">"Drools is a rule engine implementaion based on Charles Forgy's Rete Algorithm tailored for the Java language."&nbsp;</blockquote>It contains a rule engine that can process rules wirtten using the Drools language (you can also provide rules in Excel spreadsheets! - perfect for Business side to support and maintain).<br /><br />In the following example we will take a look at the way one can integrate JBoss Drools with Spring and an example of solving a similar problem without Drools.<br /><br /><br /><a name='more'></a><br /><br />Let us assume that we hava a POJO - a product that can represent either a Medical or Electronic product.&nbsp; <br /><br /><b>Product.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.model;<br /><br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />public class Product {<br />    private final TypeEnum typeEnum;<br />    private String productName;<br /><br />    public Product(TypeEnum typeEnum) {<br />        this.typeEnum = typeEnum;<br />        productName = typeEnum.getSomeOutputString();<br />    }<br /><br />    public TypeEnum getTypeEnum() {<br />        return typeEnum;<br />    }<br /><br />    public String getProductName() {<br />        return productName;<br />    }<br /><br />    public void setProductName(String productName) {<br />        this.productName = productName;<br />    }<br />}<br /><br /></pre>What defines the type of a product is the TypeEnum. It also has an outputString - let's assume that it defines a brand of a product (or whatever you want ;) )<br /><br /><b>TypeEnum.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.enums;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />public enum TypeEnum {<br />    MEDICAL("medical", "aaabbbccc"), ELECTRONIC("electronic", "cccbbbaaa");<br /><br /><br />    private final String type;<br />    private final String someOutputString;<br /><br />    private TypeEnum(String type, String someOutputString) {<br />        this.type = type;<br />        this.someOutputString = someOutputString;<br />    }<br /><br />    public String getType() {<br />        return type;<br />    }<br /><br />    public String getSomeOutputString() {<br />        return someOutputString;<br />    }<br />}<br /></pre><br />Let's say that the logic behind our rools is such that depending on the type of the enum we want to have some processing done (in our case we will have the same type of processing - converting each 'a' to 'b' in the output string).<br /><br /><b>NoRulesProductServiceImpl.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.nondrools;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br />import pl.grzejszczak.marcin.drools.springintegration.service.ProductService;<br /><br />import java.util.List;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("NoRulesProductServiceImpl")<br />public class NoRulesProductServiceImpl implements ProductService {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(NoRulesProductServiceImpl.class);<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingService")<br />    private Processor&lt;List&lt;Product&gt;&gt; productProcessingService;<br /><br />    @Override<br />    public void runProductLogic() {<br />        LOGGER.debug("Running product logic without Drools");<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        LOGGER.debug("Running rules for products...");<br />        productProcessingService.process(newArrayList(medicalProduct, electronicProduct));<br />        LOGGER.debug("...finished running products.");<br />    }<br />}<br /></pre><br />The ProductProcessingService is itterating over the given products, finds a producer for them and processes them.<br /><br /><b>ProductProcessingService.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.nondrools;<br /><br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br /><br />import java.util.List;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("ProductProcessingService")<br />public class ProductProcessingService implements Processor&lt;List&lt;Product&gt;&gt; {<br /><br />    @Autowired<br />    @Qualifier("NoRulesProcessingFactory")<br />    private ProcessingFactory&lt;Processor, Product&gt; processingFactory;<br /><br />    @Override<br />    public void process(List&lt;Product&gt; input) {<br />        for(Product product : input){<br />            Processor&lt;Product&gt; processor = processingFactory.createProcessingObject(product);<br />            processor.process(product);<br />        }<br />    }<br />}<br /></pre><br />The ProcessingFactory is an interface that basing on the given input (Product) produces an ouput (Processor) that afterwards does further processing. In our case we have a factory that instead of using a bunch of ifs (imagine that we have more than just two types of products) is using a map that matches a type of product with an implementation of a processor. As you can see we change a sequence of ifs into a single get.<br /><br /><b>NoRulesProcessingFactory.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.factory.nondrools;<br /><br />import com.google.common.collect.ImmutableMap;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.nondrools.ElectronicProductProcessingService;<br />import pl.grzejszczak.marcin.drools.springintegration.service.nondrools.MedicalProductProcessingService;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br /><br />import java.util.Map;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("NoRulesProcessingFactory")<br />public class NoRulesProcessingFactory  implements ProcessingFactory&lt;Processor, Product&gt; {<br /><br />    private static final Map&lt;TypeEnum, Processor&gt; PROCESSOR_MAP = new ImmutableMap.Builder&lt;TypeEnum, Processor&gt;().<br />            put(TypeEnum.MEDICAL, new MedicalProductProcessingService()).<br />            put(TypeEnum.ELECTRONIC, new ElectronicProductProcessingService()).<br />            build();<br /><br />    /**<br />     * By using the map we don't have any ifs<br />     * @param inputObject<br />     * @return<br />     */<br />    @Override<br />    public Processor createProcessingObject(Product inputObject) {<br />        return PROCESSOR_MAP.get(inputObject.getTypeEnum());<br />    }<br />}<br /></pre><br />I will present here only one ProcessingService since the other one is exactly the same (I just wanted to show the concept).<br /><br /><b>ElectronicProductProcessingService.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.nondrools;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.Processor;<br />import pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil;<br /><br />import static com.google.common.base.Preconditions.checkArgument;<br />import static java.lang.String.format;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />public class ElectronicProductProcessingService implements Processor&lt;Product&gt; {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ElectronicProductProcessingService.class);<br /><br />    @Override<br />    public void process(Product input) {<br />        checkArgument(TypeEnum.ELECTRONIC.equals(input.getTypeEnum()), "This processing service works only for electronic devices");<br />        checkArgument(!SomeUtil.replaceAWithB(input.getProductName()).equals(input.getProductName()), "The input has already been processed");<br />        LOGGER.debug("Running processing for Electronic Product");<br />        input.setProductName(SomeUtil.replaceAWithB(input.getProductName()));<br />        LOGGER.debug(format("ELECTRONIC rule applied without Drools, product name is now equal to [%s]", input.getProductName()));<br />    }<br />}<br /></pre><br />As you can see there are quite a few things that need to be tested and supported here. Imagine what would happen if we had 100 of types with more sophisticated rules than merely replacing one letter with the other.  So how can we do it with Drools? Let's start with taking a look at the pom.xml.<br /><br /><b>pom.xml  </b><br /><br /><pre class="brush:xml">&lt;project xmlns="https://maven.apache.org/POM/4.0.0" xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"<br /> xsi:schemaLocation="https://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br /> &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br /> &lt;groupId&gt;pl.grzejszczak.marcin&lt;/groupId&gt;<br /> &lt;artifactId&gt;drools-spring-integration&lt;/artifactId&gt;<br /> &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br /><br /> &lt;properties&gt;<br />  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;<br />  &lt;maven.compiler.source&gt;1.6&lt;/maven.compiler.source&gt;<br />  &lt;maven.compiler.target&gt;1.6&lt;/maven.compiler.target&gt;<br /><br />  &lt;spring.version&gt;3.1.1.RELEASE&lt;/spring.version&gt;<br /> &lt;/properties&gt;<br /> &lt;repositories&gt;<br />  &lt;repository&gt;<br />   &lt;id&gt;spring-release&lt;/id&gt;<br />   &lt;url&gt;https://maven.springframework.org/release&lt;/url&gt;<br />  &lt;/repository&gt;<br /> &lt;/repositories&gt;<br /><br /> &lt;dependencies&gt;<br />  &lt;!-- Spring --&gt;<br />  &lt;dependency&gt;<br />   &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />   &lt;artifactId&gt;spring-core&lt;/artifactId&gt;<br />   &lt;version&gt;${spring.version}&lt;/version&gt;<br />  &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br />            &lt;version&gt;${spring.version}&lt;/version&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;<br />            &lt;artifactId&gt;guava&lt;/artifactId&gt;<br />            &lt;version&gt;13.0.1&lt;/version&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;<br />            &lt;version&gt;${spring.version}&lt;/version&gt;<br />        &lt;/dependency&gt;<br />  &lt;dependency&gt;<br />            &lt;groupId&gt;org.drools&lt;/groupId&gt;<br />            &lt;artifactId&gt;drools-spring&lt;/artifactId&gt;<br />            &lt;version&gt;5.4.0.Final&lt;/version&gt;<br />        &lt;/dependency&gt;<br />  &lt;dependency&gt;<br />            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br />            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;<br />            &lt;version&gt;1.6.6&lt;/version&gt;<br />        &lt;/dependency&gt;<br />        &lt;dependency&gt;<br />            &lt;groupId&gt;junit&lt;/groupId&gt;<br />            &lt;artifactId&gt;junit&lt;/artifactId&gt;<br />            &lt;version&gt;4.10&lt;/version&gt;<br />            &lt;scope&gt;test&lt;/scope&gt;<br />        &lt;/dependency&gt;<br /><br />    &lt;/dependencies&gt;<br />&lt;/project&gt;<br /><br /></pre>Let's take a look at the applicationContext.xml and the drools-context.xml. As for the first one what we do in fact is just showing where to scan for classes in terms of Spring and where to import the drools context from.<br /><br /><b>applicationContext.xml  </b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="https://www.springframework.org/schema/beans"<br />       xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:context="https://www.springframework.org/schema/context"<br />       xsi:schemaLocation="https://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context-3.0.xsd<br />                           https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;<br /><br />    &lt;import resource="classpath:drools-context.xml"/&gt;<br />    &lt;!-- Show Spring where to search for the beans (in which packages) --&gt;<br />    &lt;context:component-scan base-package="pl.grzejszczak.marcin.drools.springintegration" /&gt;<br /><br />&lt;/beans&gt;<br /></pre><br />The context for drools. Take a look at the aliases for productsKSession. By providing alias we are joining two potential knowledge sessions into a single one. A single knowledge session is defined for a single knowledge base. For the knowledge base we are providing the list (in our case just a single resource) of drl files (we could have provided an excel spreadsheet).<br /><br /><b>drools-context.xml  </b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="https://www.springframework.org/schema/beans"<br />       xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:drools="https://drools.org/schema/drools-spring"<br />       xsi:schemaLocation="https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />  https://drools.org/schema/drools-spring https://drools.org/schema/drools-spring.xsd"&gt;<br /><br />    &lt;!-- KNOWLEDGE BASE FOR A GIVEN TYPE --&gt;<br />    &lt;drools:kbase id="productsKBase"&gt;<br />        &lt;drools:resources&gt;<br />            &lt;drools:resource type="DRL"<br />                             source="classpath:rules/products.drl"/&gt;<br />        &lt;/drools:resources&gt;<br />    &lt;/drools:kbase&gt;<br /><br />    &lt;drools:ksession id="productsKSession" name="productsKSession" type="stateless" kbase="productsKBase"/&gt;<br />    &lt;alias name="productsKSession" alias="electronicKSession"/&gt;<br />    &lt;alias name="productsKSession" alias="medicalKSession"/&gt;<br /><br />&lt;/beans&gt;<br /></pre><br />Let's check the drl file.<br /><br />We define two rules - "MEDICAL rule" and "ELECTRONIC rule". For each case we are checking:<br /><br /><ul><li>whether the input object is of Product type&nbsp;</li><li>whether it has typeEnum equal to either Medical or Electronic&nbsp;</li><li>whether it hasn't already had it's productName changed&nbsp;</li></ul><br />Then we are addressing the product by means of a variable $product. We are modifying the product using the <span style="font-family: Courier New, Courier, monospace;">modify </span>keyword (which means that all the rules are rechecked - try removing the condition 'productName != replaceAWithB($product.typeEnum.someOutputString' and you will have an endless loop) by setting a new productName. Take a look at all the imports and imports of functions. You can execute a static function (pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil.replaceAWithB or org.drools.core.util.StringUtils.isEmpty) by importing it in the drl file.<br />At the end we are logging that a rule has been applied.<br /><br /><b>products.drl  </b><br /><br /><pre class="brush:xml">package pl.grzejszczak.marcin<br /><br />import org.slf4j.LoggerFactory<br />import pl.grzejszczak.marcin.drools.springintegration.DroolsSpring<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum<br /><br />import function pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil.replaceAWithB<br />import function org.drools.core.util.StringUtils.isEmpty<br /><br /><br />rule "MEDICAL rule"<br /> dialect "mvel"<br />when<br />     $product : Product( typeEnum == TypeEnum.MEDICAL, productName != replaceAWithB($product.typeEnum.someOutputString) )<br />then<br />     modify ($product) {productName = replaceAWithB($product.typeEnum.someOutputString)}<br />     LoggerFactory.getLogger(DroolsSpring.class).debug(String.format("MEDICAL rule applied, product name is now equal to [%s]", $product.productName))<br />end<br /><br />rule "ELECTRONIC rule"<br /> dialect "mvel"<br />when<br />     $product : Product( typeEnum == TypeEnum.ELECTRONIC, productName != replaceAWithB($product.typeEnum.someOutputString) )<br />then<br />     modify ($product) {productName = replaceAWithB($product.typeEnum.someOutputString)}<br />     LoggerFactory.getLogger(DroolsSpring.class).debug(String.format("ELECTRONIC rule applied, product name is now equal to [%s]", $product.productName))<br />end<br /></pre><br />We use a factory that is choosing a proper StatelessKnowledgeSession - since we only want to modify an input object. In order to run Drools rules we are running the execute method with a list of input objects.&nbsp; <br /><br /><b>ProductServiceImpl.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service.drools;<br /><br />import org.drools.runtime.StatelessKnowledgeSession;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.service.ProductService;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("ProductServiceImpl")<br />public class ProductServiceImpl implements ProductService {<br /><br />    private static final Logger LOGGER = LoggerFactory.getLogger(ProductServiceImpl.class);<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingFactory")<br />    ProcessingFactory&lt;StatelessKnowledgeSession, Product&gt; processingFactory;<br /><br />    @Override<br />    public void runProductLogic() {<br />        LOGGER.debug("Running product logic");<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        StatelessKnowledgeSession statelessKnowledgeSession = processingFactory.createProcessingObject(medicalProduct);<br />        LOGGER.debug("Running rules for products...");<br />        statelessKnowledgeSession.execute(newArrayList(medicalProduct, electronicProduct));<br />        LOGGER.debug("...finished running products.");<br />    }<br />}<br /><br /></pre>Now let's have a look on how the factory is implemented. We are using aliases in the applicationContext.xml<br /><br /><b>ProductProcessingFactory.java  </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.factory.drools;<br /><br />import org.drools.runtime.StatelessKnowledgeSession;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.context.ApplicationContext;<br />import org.springframework.stereotype.Component;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@Component("ProductProcessingFactory")<br />public class ProductProcessingFactory implements ProcessingFactory&lt;StatelessKnowledgeSession, Product&gt; {<br /><br />    @Autowired<br />    private ApplicationContext applicationContext;<br /><br />    @Override<br />    public StatelessKnowledgeSession createProcessingObject(Product inputObject) {<br />        return (StatelessKnowledgeSession)applicationContext.getBean(inputObject.getTypeEnum().getType() + "KSession");<br />    }<br />}<br /></pre>Now how can we test if it works? I have two unit tests that prove it (they are not running in perfect isolation but they functionality of both approaches). Starting with the test for the manual rules creation test. <br /><br /><b>NoRulesProductServiceImplTest.java </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service;<br /><br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil;<br /><br />import java.util.List;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br />import static java.lang.String.format;<br />import static org.junit.Assert.assertEquals;<br />import static org.junit.Assert.assertNotSame;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = {"classpath:applicationContext.xml"})<br />public class NoRulesProductServiceImplTest {<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingService")<br />    private Processor&lt;List&lt;Product&gt;&gt; productProcessingService;<br /><br /><br />    /**<br />     * Test is not run in perfect isolation - the purpose is to show the outcome of processing without Drools<br />     *<br />     * @throws Exception<br />     */<br />    @Test<br />    public void testRunProductLogic() throws Exception {<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        String initialMedicalProductName = medicalProduct.getProductName();<br />        String initialElectronicProduct = electronicProduct.getProductName();<br />        System.out.println(format("Initial productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Initial productName for Electronic [%s]", electronicProduct.getProductName()));<br /><br />        productProcessingService.process(newArrayList(medicalProduct, electronicProduct));<br /><br />        String finalMedicalProduct = medicalProduct.getProductName();<br />        String finalElectronicProduct = electronicProduct.getProductName();<br />        assertNotSame(finalMedicalProduct, initialMedicalProductName);<br />        assertNotSame(finalElectronicProduct, initialElectronicProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialMedicalProductName), finalMedicalProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialElectronicProduct), finalElectronicProduct);<br /><br />        System.out.println(format("Final productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Final productName for Electronic [%s]", electronicProduct.getProductName()));<br />    }<br />}<br /></pre><br />And the unit test for the Drools approach.<br /><br /><b>ProductServiceImplTest.java </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.drools.springintegration.service;<br /><br />import org.drools.runtime.StatelessKnowledgeSession;<br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br />import pl.grzejszczak.marcin.drools.springintegration.enums.TypeEnum;<br />import pl.grzejszczak.marcin.drools.springintegration.factory.ProcessingFactory;<br />import pl.grzejszczak.marcin.drools.springintegration.model.Product;<br />import pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br />import static java.lang.String.format;<br />import static org.junit.Assert.assertEquals;<br />import static org.junit.Assert.assertNotSame;<br />import static org.junit.Assert.assertTrue;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 14.01.13<br /> */<br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = {"classpath:applicationContext.xml"})<br />public class ProductServiceImplTest {<br /><br />    @Autowired<br />    @Qualifier("ProductProcessingFactory")<br />    ProcessingFactory&lt;StatelessKnowledgeSession, Product&gt; processingFactory;<br /><br />    /**<br />     * Test is not run in perfect isolation - the purpose is to show the outcome of processing with Drools<br />     * @throws Exception<br />     */<br />    @Test<br />    public void testRunProductLogic() throws Exception {<br />        Product medicalProduct = new Product(TypeEnum.MEDICAL);<br />        Product electronicProduct = new Product(TypeEnum.ELECTRONIC);<br />        String initialMedicalProductName = medicalProduct.getProductName();<br />        String initialElectronicProduct = electronicProduct.getProductName();<br />        System.out.println(format("Initial productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Initial productName for Electronic [%s]", electronicProduct.getProductName()));<br /><br />        StatelessKnowledgeSession statelessKnowledgeSessionForMedical = processingFactory.createProcessingObject(medicalProduct);<br />        StatelessKnowledgeSession statelessKnowledgeSessionForElectronic = processingFactory.createProcessingObject(electronicProduct);<br />        assertTrue(statelessKnowledgeSessionForMedical == statelessKnowledgeSessionForElectronic);<br />        System.out.println("References for stateless sessions are the same, executing rules...");<br /><br />        statelessKnowledgeSessionForMedical.execute(newArrayList(medicalProduct, electronicProduct));<br /><br />        String finalMedicalProduct = medicalProduct.getProductName();<br />        String finalElectronicProduct = electronicProduct.getProductName();<br />        assertNotSame(finalMedicalProduct, initialMedicalProductName);<br />        assertNotSame(finalElectronicProduct, initialElectronicProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialMedicalProductName), finalMedicalProduct);<br />        assertEquals(SomeUtil.replaceAWithB(initialElectronicProduct), finalElectronicProduct);<br /><br />        System.out.println(format("Final productName for Medical [%s]", medicalProduct.getProductName()));<br />        System.out.println(format("Final productName for Electronic [%s]", electronicProduct.getProductName()));<br />    }<br />}<br /></pre>Now let's take a look at the logs - take a look that 'Executing some logic' took place 6 times for Drools since when you modify an object the rules are revalidated and rerun:  <br /><br /><pre class="brush:xml">org.springframework.context.support.ClassPathXmlApplicationContext:495 Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@743399: startup date [Tue Jan 15 16:32:30 CET 2013]; root of context hierarchy<br />org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [applicationContext.xml]<br />org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [drools-context.xml]<br />[main] org.springframework.beans.factory.support.DefaultListableBeanFactory:557 Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@3b1d04: defining beans [productsKBase,productsKSession,ProductProcessingFactory,NoRulesProcessingFactory,ProductServiceImpl,NoRulesProductServiceImpl,ProductProcessingService,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy<br />pl.grzejszczak.marcin.drools.springintegration.service.drools.ProductServiceImpl:32 Running product logic<br />pl.grzejszczak.marcin.drools.springintegration.service.drools.ProductServiceImpl:36 Running rules for products...<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.DroolsSpring:? ELECTRONIC rule applied, product name is now equal to [cccbbbbbb]<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.DroolsSpring:? MEDICAL rule applied, product name is now equal to [bbbbbbccc]<br />pl.grzejszczak.marcin.drools.springintegration.service.drools.ProductServiceImpl:38 ...finished running products.<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.NoRulesProductServiceImpl:33 Running product logic without Drools<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.NoRulesProductServiceImpl:36 Running rules for products...<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.MedicalProductProcessingService:26 Running processing for Medical Product<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.MedicalProductProcessingService:28 MEDICAL rule applied without Drools, product name is now equal to [bbbbbbccc]<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.ElectronicProductProcessingService:26 Running processing for Electronic Product<br />pl.grzejszczak.marcin.drools.springintegration.utils.SomeUtil:19 Executing some logic<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.ElectronicProductProcessingService:28 ELECTRONIC rule applied without Drools, product name is now equal to [cccbbbbbb]<br />pl.grzejszczak.marcin.drools.springintegration.service.nondrools.NoRulesProductServiceImpl:38 ...finished running products.<br /></pre><br />Viola! That's how you can write some rules with Drools that can save plenty of time and effort as far as business logic is concerned. You can find the sources here at my <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/3d8a2ef67b5b/Drools/Spring%20integration?at=default">BitBucket repository</a>.</div>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        










<span class="glyphicon glyphicon-calendar"></span> <time datetime="2013-01-07T17:15:00+01:00"  data-updated="true" itemprop="datePublished dateCreated">ordinal</time>
        
           | <a href="/articles/2013/01/07/very-interesting-article-about-xsd/#disqus_thread" itemprop="discussionUrl"
             data-disqus-identifier="https://toomuchcoding.com/articles/2013/01/07/very-interesting-article-about-xsd/">Comments</a>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/articles/2013/01/07/very-interesting-article-about-xsd/" itemprop="url">Very interesting article about XSD</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><div class='post'>
A friend from my project (<strike>that will soon start his own blog ;)</strike> <a href="https://yetanothercoding.blogspot.com/">here is his blog</a> ) has found a very interesting article about XSDs and namespaces.<br /><br />&nbsp;<a href="https://www.liquid-technologies.com/Tutorials/XmlSchemas/XsdTutorial_04.aspx">Tutorial about XSD and namespaces</a></div>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        










<span class="glyphicon glyphicon-calendar"></span> <time datetime="2013-01-04T01:35:00+01:00"  data-updated="true" itemprop="datePublished dateCreated">ordinal</time>
        
           | <a href="/articles/2013/01/04/hamcrest-matchers-guava-predicate-and/#disqus_thread" itemprop="discussionUrl"
             data-disqus-identifier="https://toomuchcoding.com/articles/2013/01/04/hamcrest-matchers-guava-predicate-and/">Comments</a>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/articles/2013/01/04/hamcrest-matchers-guava-predicate-and/" itemprop="url">Hamcrest Matchers, Guava Predicate and Builder design pattern</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><div class='post'>
<br /><br />Hi coding addicts :)<br /><br />Often, while coding we have to deal with some POJO objects that have dozens of fields in them. Many times we initialize those classes through a constructor having dozens of arguments which is terrible in any possibly imaginable way :) Apart from that the functions that use those constructors are hardly testable. Let's take a closer look at using a Builder to change that situation, together with Hamcrest matchers and Guava Predicates to unit test it.<br />
<!--more-->
<br />Let's start off with taking a look at the POJO class.<br /><br /><br /><a name='more'></a><br /><br /><b>SomeBigPojo.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.pojo;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 21:05<br /> */<br />public class SomeBigPojo {<br />    private String stringField0;<br />    private Integer integerField0;<br />    private Boolean booleanField0;<br />    private String stringField1;<br />    private Integer integerField1;<br />    private Boolean booleanField1;<br />    private String stringField2;<br />    private Integer integerField2;<br />    private Boolean booleanField2;<br />    private String stringField3;<br />    private Integer integerField3;<br />    private Boolean booleanField3;<br />    private String stringField4;<br />    private Integer integerField4;<br />    private Boolean booleanField4;<br />    private String stringField5;<br />    private Integer integerField5;<br />    private Boolean booleanField5;<br />    private String stringField6;<br />    private Integer integerField6;<br />    private Boolean booleanField6;<br />    private String stringField7;<br />    private String stringField8;<br />    private String stringField9;<br /><br />    public SomeBigPojo(String stringField0, Integer integerField0, Boolean booleanField0, String stringField1, Integer integerField1, Boolean booleanField1, String stringField2, Integer integerField2, Boolean booleanField2, String stringField3, Integer integerField3, Boolean booleanField3, String stringField4, Integer integerField4, Boolean booleanField4, String stringField5, Integer integerField5, Boolean booleanField5, String stringField6, Integer integerField6, Boolean booleanField6, String stringField7, String stringField8, String stringField9) {<br />        this.stringField0 = stringField0;<br />        this.integerField0 = integerField0;<br />        this.booleanField0 = booleanField0;<br />        this.stringField1 = stringField1;<br />        this.integerField1 = integerField1;<br />        this.booleanField1 = booleanField1;<br />        this.stringField2 = stringField2;<br />        this.integerField2 = integerField2;<br />        this.booleanField2 = booleanField2;<br />        this.stringField3 = stringField3;<br />        this.integerField3 = integerField3;<br />        this.booleanField3 = booleanField3;<br />        this.stringField4 = stringField4;<br />        this.integerField4 = integerField4;<br />        this.booleanField4 = booleanField4;<br />        this.stringField5 = stringField5;<br />        this.integerField5 = integerField5;<br />        this.booleanField5 = booleanField5;<br />        this.stringField6 = stringField6;<br />        this.integerField6 = integerField6;<br />        this.booleanField6 = booleanField6;<br />        this.stringField7 = stringField7;<br />        this.stringField8 = stringField8;<br />        this.stringField9 = stringField9;<br />    }<br /><br />    public String getStringField0() {<br />        return stringField0;<br />    }<br /><br />    public void setStringField0(String stringField0) {<br />        this.stringField0 = stringField0;<br />    }<br /><br />    public Integer getIntegerField0() {<br />        return integerField0;<br />    }<br /><br />    public void setIntegerField0(Integer integerField0) {<br />        this.integerField0 = integerField0;<br />    }<br /><br />    public Boolean getBooleanField0() {<br />        return booleanField0;<br />    }<br /><br />    public void setBooleanField0(Boolean booleanField0) {<br />        this.booleanField0 = booleanField0;<br />    }<br /><br />    public String getStringField1() {<br />        return stringField1;<br />    }<br /><br />    public void setStringField1(String stringField1) {<br />        this.stringField1 = stringField1;<br />    }<br /><br />    public Integer getIntegerField1() {<br />        return integerField1;<br />    }<br /><br />    public void setIntegerField1(Integer integerField1) {<br />        this.integerField1 = integerField1;<br />    }<br /><br />    public Boolean getBooleanField1() {<br />        return booleanField1;<br />    }<br /><br />    public void setBooleanField1(Boolean booleanField1) {<br />        this.booleanField1 = booleanField1;<br />    }<br /><br />    public String getStringField2() {<br />        return stringField2;<br />    }<br /><br />    public void setStringField2(String stringField2) {<br />        this.stringField2 = stringField2;<br />    }<br /><br />    public Integer getIntegerField2() {<br />        return integerField2;<br />    }<br /><br />    public void setIntegerField2(Integer integerField2) {<br />        this.integerField2 = integerField2;<br />    }<br /><br />    public Boolean getBooleanField2() {<br />        return booleanField2;<br />    }<br /><br />    public void setBooleanField2(Boolean booleanField2) {<br />        this.booleanField2 = booleanField2;<br />    }<br /><br />    public String getStringField3() {<br />        return stringField3;<br />    }<br /><br />    public void setStringField3(String stringField3) {<br />        this.stringField3 = stringField3;<br />    }<br /><br />    public Integer getIntegerField3() {<br />        return integerField3;<br />    }<br /><br />    public void setIntegerField3(Integer integerField3) {<br />        this.integerField3 = integerField3;<br />    }<br /><br />    public Boolean getBooleanField3() {<br />        return booleanField3;<br />    }<br /><br />    public void setBooleanField3(Boolean booleanField3) {<br />        this.booleanField3 = booleanField3;<br />    }<br /><br />    public String getStringField4() {<br />        return stringField4;<br />    }<br /><br />    public void setStringField4(String stringField4) {<br />        this.stringField4 = stringField4;<br />    }<br /><br />    public Integer getIntegerField4() {<br />        return integerField4;<br />    }<br /><br />    public void setIntegerField4(Integer integerField4) {<br />        this.integerField4 = integerField4;<br />    }<br /><br />    public Boolean getBooleanField4() {<br />        return booleanField4;<br />    }<br /><br />    public void setBooleanField4(Boolean booleanField4) {<br />        this.booleanField4 = booleanField4;<br />    }<br /><br />    public String getStringField5() {<br />        return stringField5;<br />    }<br /><br />    public void setStringField5(String stringField5) {<br />        this.stringField5 = stringField5;<br />    }<br /><br />    public Integer getIntegerField5() {<br />        return integerField5;<br />    }<br /><br />    public void setIntegerField5(Integer integerField5) {<br />        this.integerField5 = integerField5;<br />    }<br /><br />    public Boolean getBooleanField5() {<br />        return booleanField5;<br />    }<br /><br />    public void setBooleanField5(Boolean booleanField5) {<br />        this.booleanField5 = booleanField5;<br />    }<br /><br />    public String getStringField6() {<br />        return stringField6;<br />    }<br /><br />    public void setStringField6(String stringField6) {<br />        this.stringField6 = stringField6;<br />    }<br /><br />    public Integer getIntegerField6() {<br />        return integerField6;<br />    }<br /><br />    public void setIntegerField6(Integer integerField6) {<br />        this.integerField6 = integerField6;<br />    }<br /><br />    public Boolean getBooleanField6() {<br />        return booleanField6;<br />    }<br /><br />    public void setBooleanField6(Boolean booleanField6) {<br />        this.booleanField6 = booleanField6;<br />    }<br /><br />    public String getStringField7() {<br />        return stringField7;<br />    }<br /><br />    public void setStringField7(String stringField7) {<br />        this.stringField7 = stringField7;<br />    }<br /><br />    public String getStringField8() {<br />        return stringField8;<br />    }<br /><br />    public void setStringField8(String stringField8) {<br />        this.stringField8 = stringField8;<br />    }<br /><br />    public String getStringField9() {<br />        return stringField9;<br />    }<br /><br />    public void setStringField9(String stringField9) {<br />        this.stringField9 = stringField9;<br />    }<br /><br />    @Override<br />    public String toString() {<br />        final StringBuilder sb = new StringBuilder();<br />        sb.append("SomeBigPojo");<br />        sb.append("{stringField0='").append(stringField0).append('\'');<br />        sb.append(", integerField0=").append(integerField0);<br />        sb.append(", booleanField0=").append(booleanField0);<br />        sb.append(", stringField1='").append(stringField1).append('\'');<br />        sb.append(", integerField1=").append(integerField1);<br />        sb.append(", booleanField1=").append(booleanField1);<br />        sb.append(", stringField2='").append(stringField2).append('\'');<br />        sb.append(", integerField2=").append(integerField2);<br />        sb.append(", booleanField2=").append(booleanField2);<br />        sb.append(", stringField3='").append(stringField3).append('\'');<br />        sb.append(", integerField3=").append(integerField3);<br />        sb.append(", booleanField3=").append(booleanField3);<br />        sb.append(", stringField4='").append(stringField4).append('\'');<br />        sb.append(", integerField4=").append(integerField4);<br />        sb.append(", booleanField4=").append(booleanField4);<br />        sb.append(", stringField5='").append(stringField5).append('\'');<br />        sb.append(", integerField5=").append(integerField5);<br />        sb.append(", booleanField5=").append(booleanField5);<br />        sb.append(", stringField6='").append(stringField6).append('\'');<br />        sb.append(", integerField6=").append(integerField6);<br />        sb.append(", booleanField6=").append(booleanField6);<br />        sb.append(", stringField7='").append(stringField7).append('\'');<br />        sb.append(", stringField8='").append(stringField8).append('\'');<br />        sb.append(", stringField9='").append(stringField9).append('\'');<br />        sb.append('}');<br />        return sb.toString();<br />    }<br />}<br /><br /></pre>Now take a look at the builder class that was used in order to get rid of usage of the humongous constructor. What is more you can set whatever you want to without the need to enter nulls for the undesired fields.<br /><br /><b>SomeBigPojoBuilder.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.builder;<br /><br />import pl.grzejszczak.marcin.junit.matchers.pojo.SomeBigPojo;<br /><br />import static com.google.common.base.Preconditions.checkNotNull;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 21:08<br /> */<br />public class SomeBigPojoBuilder {<br />    /** A field with some default value */<br />    private String stringField0 = "defaultValueForString0";<br />    /** A field with some default value */<br />    private Integer integerField0 = 100;<br />    /** A field with some default value */<br />    private Boolean booleanField0 = true;<br />    private String stringField1;<br />    private Integer integerField1;<br />    private Boolean booleanField1;<br />    private String stringField2;<br />    private Integer integerField2;<br />    private Boolean booleanField2;<br />    private String stringField3;<br />    private Integer integerField3;<br />    private Boolean booleanField3;<br />    private String stringField4;<br />    private Integer integerField4;<br />    private Boolean booleanField4;<br />    private String stringField5;<br />    private Integer integerField5;<br />    private Boolean booleanField5;<br />    private String stringField6;<br />    private Integer integerField6;<br />    private Boolean booleanField6;<br />    private String stringField7;<br />    private String stringField8;<br />    private String stringField9;<br /><br />    public SomeBigPojoBuilder setStringField0(String stringField0) {<br />        this.stringField0 = stringField0;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField0(Integer integerField0) {<br />        this.integerField0 = integerField0;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField0(Boolean booleanField0) {<br />        this.booleanField0 = booleanField0;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField1(String stringField1) {<br />        this.stringField1 = stringField1;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField1(Integer integerField1) {<br />        this.integerField1 = integerField1;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField1(Boolean booleanField1) {<br />        this.booleanField1 = booleanField1;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField2(String stringField2) {<br />        this.stringField2 = stringField2;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField2(Integer integerField2) {<br />        this.integerField2 = integerField2;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField2(Boolean booleanField2) {<br />        this.booleanField2 = booleanField2;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField3(String stringField3) {<br />        this.stringField3 = stringField3;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField3(Integer integerField3) {<br />        this.integerField3 = integerField3;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField3(Boolean booleanField3) {<br />        this.booleanField3 = booleanField3;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField4(String stringField4) {<br />        this.stringField4 = stringField4;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField4(Integer integerField4) {<br />        this.integerField4 = integerField4;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField4(Boolean booleanField4) {<br />        this.booleanField4 = booleanField4;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField5(String stringField5) {<br />        this.stringField5 = stringField5;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField5(Integer integerField5) {<br />        this.integerField5 = integerField5;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField5(Boolean booleanField5) {<br />        this.booleanField5 = booleanField5;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField6(String stringField6) {<br />        this.stringField6 = stringField6;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setIntegerField6(Integer integerField6) {<br />        this.integerField6 = integerField6;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setBooleanField6(Boolean booleanField6) {<br />        this.booleanField6 = booleanField6;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField7(String stringField7) {<br />        this.stringField7 = stringField7;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField8(String stringField8) {<br />        this.stringField8 = stringField8;<br />        return this;<br />    }<br /><br />    public SomeBigPojoBuilder setStringField9(String stringField9) {<br />        this.stringField9 = stringField9;<br />        return this;<br />    }<br /><br />    /**<br />     * Some function checking the state of our POJO<br />     */<br />    private void checkState(){<br />        checkNotNull(stringField1, "StringField1 must not be null!");<br />    }<br /><br />    public SomeBigPojo createSomeBigPojoWithBuilder() {<br />        checkState();<br />        return new SomeBigPojo(stringField0, integerField0, booleanField0, stringField1, integerField1, booleanField1, stringField2, integerField2, booleanField2, stringField3, integerField3, booleanField3, stringField4, integerField4, booleanField4, stringField5, integerField5, booleanField5, stringField6, integerField6, booleanField6, stringField7, stringField8, stringField9);<br />    }<br />}<br /></pre><br />Take a look at the function checkState that verifies whether the object is of a desired state. In this way we may disallow the creation of an object if some conditions where not fullfiled. For that case we are using the Guava's Predicate - checkNotNull method. <br /><br />Note that the concept behind the Builder pattern is to delegate creation of an object to a Builder. In fact in the pure Builder design pattern implementation we would have to have a Director, some abstraction over a Builder and the concrete implementation of the Builder as such. In our case we have a simplification of that pattern - I used the refactoring option of IntelliJ. What can be done to make it look even better is to remove the constructor from the POJO and pass the values only by setters (that's what in fact I did in one of my projects ;) ) <br /><br />Now let's take a look at some usage examples: <br /><b><br /></b><b>SomeServiceImpl.java </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.service;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import pl.grzejszczak.marcin.junit.matchers.builder.SomeBigPojoBuilder;<br />import pl.grzejszczak.marcin.junit.matchers.pojo.SomeBigPojo;<br /><br />import static java.lang.String.format;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 21:25<br /> */<br />public class SomeServiceImpl implements SomeService {<br />    private static final Logger LOGGER = LoggerFactory.getLogger(SomeServiceImpl.class);<br /><br />    /** Could be an abstraction of builders injected by a setter - possible to mock */<br />    private SomeBigPojoBuilder someBigPojoBuilder;<br /><br />    /**<br />     * Hard to unit test<br />     */<br />    @Override<br />    public void someLogicForAPojoWithoutBuilder() {<br />        LOGGER.debug("SomeLogicForAPojoWithoutBuilder executed");<br />        SomeBigPojo someBigPojo = new SomeBigPojo("string", 1, false, "other string", 123, true, "something else", 321, false, "yet another string", 111, true, "something", 2, false, "More", 3, true, "String", 12, false, "some", "value", "ofString");<br />        // Any chance of knowing what is the value of stringField8 basing on the constructor?<br />        LOGGER.debug(format("StringField8 is equal [%s]%n", someBigPojo.getStringField8()));<br />        // Print the object<br />        LOGGER.debug(someBigPojo.toString());<br />    }<br /><br />    @Override<br />    public void someLogicForAPojoWithBuilder() {<br />        LOGGER.debug("SomeLogicForAPojoWithBuilder executed");<br />        SomeBigPojo someBigPojo = someBigPojoBuilder<br />                .setStringField0("string")<br />                .setIntegerField0(1)<br />                .setBooleanField0(false)<br />                .setStringField1("other string")<br />                .setIntegerField1(123)<br />                .setBooleanField1(true)<br />                .setStringField2("something else")<br />                .setIntegerField2(321)<br />                .setBooleanField2(false)<br />                .setStringField3("yet another string")<br />                .setIntegerField3(111)<br />                .setBooleanField3(false)<br />                .setStringField4("something")<br />                .setIntegerField4(2)<br />                .setBooleanField4(false)<br />                .setStringField5("More")<br />                .setIntegerField5(3)<br />                .setBooleanField5(true)<br />                .setStringField6("String")<br />                .setIntegerField6(12)<br />                .setBooleanField6(false)<br />                .setStringField7("some")<br />                .setStringField8("value")<br />                .setStringField9("ofString")<br />                .createSomeBigPojoWithBuilder();<br />        // Looking at the builder now I guess it's obvious what the value of StringField8<br />        LOGGER.debug(format("StringField8 is equal [%s]%n", someBigPojo.getStringField8()));<br />        // Print the object<br />        LOGGER.debug(someBigPojo.toString());<br />    }<br /><br />    @Override<br />    public void someLogicForAPojoWithBuilderBadArgument() {<br />        LOGGER.debug("someLogicForAPojoWithBuilderBadArgument executed");<br />        SomeBigPojo someBigPojo = someBigPojoBuilder<br />                .setStringField0("string")<br />                .setIntegerField0(1)<br />                .setBooleanField0(true)<br />                .setIntegerField1(123)<br />                .setBooleanField1(true)<br />                .setStringField2("something else")<br />                .setIntegerField2(321)<br />                .setBooleanField2(false)<br />                .setStringField3("yet another string")<br />                .setIntegerField3(111).setBooleanField3(false)<br />                .setStringField4("something")<br />                .setIntegerField4(2)<br />                .setBooleanField4(false)<br />                .setStringField5("More")<br />                .setIntegerField5(3)<br />                .setBooleanField5(true)<br />                .setStringField6("String")<br />                .setIntegerField6(12)<br />                .setBooleanField6(false)<br />                .setStringField7("some")<br />                .setStringField8("value")<br />                .setStringField9("ofString")<br />                .createSomeBigPojoWithBuilder();<br />        // Print the object - will we even see an output<br />        LOGGER.debug(someBigPojo.toString());<br />    }<br /><br />    public void setSomeBigPojoBuilder(SomeBigPojoBuilder someBigPojoBuilder) {<br />        this.someBigPojoBuilder = someBigPojoBuilder;<br />    }<br />}<br /><br /><br /></pre><br /><br />Notice how clear it is now to create an object and how easy is to define if a field has been set or not. <br /><br />Let's move on to Hamcrest matchers that will help us in unit testing of our classes. I will not try to do the complete, 100% code coverage - the idea behind this post is to show how Hamcrest Matchers can become an addition to your unit tests. <br /><br />Often unit tests are quite unclear and look like this:<br /><b><br /></b><b>SomeBigPojoBuilderNoMatchersAndNoRefactoringTest.java </b><br /><b><br /></b><br /><pre class="brush:java"></pre><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.builder;<br /><br />import org.junit.Before;<br />import org.junit.Test;<br />import pl.grzejszczak.marcin.junit.matchers.pojo.SomeBigPojo;<br /><br />import static junit.framework.Assert.assertTrue;<br />import static org.apache.commons.lang.StringUtils.isNumeric;<br />import static pl.grzejszczak.marcin.junit.matchers.pojo.SomePojoConstants.*;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 23:02<br /> */<br />public class SomeBigPojoBuilderNoMatchersAndNoRefactoringTest {<br /><br />    private SomeBigPojoBuilder objectUnderTest;<br /><br />    @Before<br />    public void setUp() {<br />        objectUnderTest = new SomeBigPojoBuilder();<br />    }<br /><br />    @Test<br />    public void testCreateSomeBigPojoWithBuilder() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setBooleanField1(true)<br />                .setStringField0("1")<br />                .setStringField1("12")<br />                .setStringField2("123")<br />                .setStringField3("1234")<br />                .setStringField4("12345")<br />                .setStringField5("123456")<br />                .setStringField6("1234567")<br />                .setStringField7("12345678")<br />                .setStringField8("123456789")<br />                .setStringField9("1234567890")<br />                .createSomeBigPojoWithBuilder();<br /><br />        isPojoProperlyBuilt(someBigPojo);<br />    }<br /><br />    @Test(expected = AssertionError.class)<br />    public void testCreateSomeBigPojoWithBuilderWrongFields() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setStringField0("0")<br />                .setStringField1("Too long")<br />                .createSomeBigPojoWithBuilder();<br /><br />        isPojoProperlyBuilt(someBigPojo);<br />    }<br /><br />    private void isPojoProperlyBuilt(SomeBigPojo someBigPojo) {<br />        assertTrue(someBigPojo.getStringField0().length() == STRING_FIELD_0_LENGTH);<br />        assertTrue(isNumeric(someBigPojo.getStringField0()));<br /><br />        assertTrue(someBigPojo.getStringField1().length() == STRING_FIELD_1_LENGTH);<br />        assertTrue(isNumeric(someBigPojo.getStringField0()));<br /><br />        assertTrue(someBigPojo.getStringField2().length() == STRING_FIELD_2_LENGTH);<br />        assertTrue(isNumeric(someBigPojo.getStringField0()));<br /><br />        assertTrue(someBigPojo.getStringField3().length() == STRING_FIELD_3_LENGTH);<br />        assertTrue(isNumeric(someBigPojo.getStringField0()));<br /><br />        assertTrue(someBigPojo.getStringField4().length() == STRING_FIELD_4_LENGTH);<br />        assertTrue(isNumeric(someBigPojo.getStringField0()));<br /><br />        assertTrue(someBigPojo.getStringField5().length() == STRING_FIELD_5_LENGTH);<br /><br />        assertTrue(someBigPojo.getStringField6().length() == STRING_FIELD_6_LENGTH);<br /><br />        assertTrue(someBigPojo.getStringField7().length() == STRING_FIELD_7_LENGTH);<br /><br />        assertTrue(someBigPojo.getStringField8().length() == STRING_FIELD_8_LENGTH);<br /><br />        assertTrue(someBigPojo.getStringField9().length() == STRING_FIELD_9_LENGTH);<br /><br />    }<br />}<br /><br /></pre><br />Simple refactoring can make them look nicer... <br /><br /><b>SomeBigPojoBuilderNoMatchersTest.java </b><br /><b><br /></b><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.builder;<br /><br />import org.junit.Before;<br />import org.junit.Test;<br />import pl.grzejszczak.marcin.junit.matchers.pojo.SomeBigPojo;<br /><br />import static junit.framework.Assert.assertNotNull;<br />import static junit.framework.Assert.assertTrue;<br />import static org.apache.commons.lang.StringUtils.isNumeric;<br />import static pl.grzejszczak.marcin.junit.matchers.pojo.SomePojoConstants.*;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 23:02<br /> */<br />public class SomeBigPojoBuilderNoMatchersTest {<br /><br />    private SomeBigPojoBuilder objectUnderTest;<br /><br />    @Before<br />    public void setUp() {<br />        objectUnderTest = new SomeBigPojoBuilder();<br />    }<br /><br />    @Test<br />    public void testCreateSomeBigPojoWithBuilder() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setBooleanField1(true)<br />                .setStringField0("1")<br />                .setStringField1("12")<br />                .setStringField2("123")<br />                .setStringField3("1234")<br />                .setStringField4("12345")<br />                .setStringField5("123456")<br />                .setStringField6("1234567")<br />                .setStringField7("12345678")<br />                .setStringField8("123456789")<br />                .setStringField9("1234567890")<br />                .createSomeBigPojoWithBuilder();<br /><br />        isPojoProperlyBuilt(someBigPojo);<br />    }<br /><br />    @Test(expected = AssertionError.class)<br />    public void testCreateSomeBigPojoWithBuilderWrongFields() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setStringField0("0")<br />                .setStringField1("too long")<br />                .createSomeBigPojoWithBuilder();<br /><br />        isPojoProperlyBuilt(someBigPojo);<br />    }<br /><br />    private void isPojoProperlyBuilt(SomeBigPojo someBigPojo) {<br />        isOfGivenLength(someBigPojo.getStringField0(), STRING_FIELD_0_LENGTH);<br />        isFieldOfNumericValue(someBigPojo.getStringField0());<br /><br />        isOfGivenLength(someBigPojo.getStringField1(), STRING_FIELD_1_LENGTH);<br />        isFieldOfNumericValue(someBigPojo.getStringField0());<br /><br />        isOfGivenLength(someBigPojo.getStringField2(), STRING_FIELD_2_LENGTH);<br />        isFieldOfNumericValue(someBigPojo.getStringField0());<br /><br />        isOfGivenLength(someBigPojo.getStringField3(), STRING_FIELD_3_LENGTH);<br />        isFieldOfNumericValue(someBigPojo.getStringField0());<br /><br />        isOfGivenLength(someBigPojo.getStringField4(), STRING_FIELD_4_LENGTH);<br />        isFieldOfNumericValue(someBigPojo.getStringField0());<br /><br />        isOfGivenLength(someBigPojo.getStringField5(), STRING_FIELD_5_LENGTH);<br /><br />        isOfGivenLength(someBigPojo.getStringField6(), STRING_FIELD_6_LENGTH);<br /><br />        isOfGivenLength(someBigPojo.getStringField7(), STRING_FIELD_7_LENGTH);<br /><br />        isOfGivenLength(someBigPojo.getStringField8(), STRING_FIELD_8_LENGTH);<br /><br />        isOfGivenLength(someBigPojo.getStringField9(), STRING_FIELD_9_LENGTH);<br /><br />    }<br /><br />    private void isOfGivenLength(String pojo, final Integer expectedLength) {<br />        assertNotNull(pojo);<br />        assertTrue(expectedLength == pojo.length());<br />    }<br /><br />    private void isFieldOfNumericValue(String field) {<br />        assertTrue(isNumeric(field));<br />    }<br />}<br /><br /></pre><br /><br />That looks nice, doesn't it? :) And how about using Matchers instead of functions? <br /><br /><b>SomeBigPojoBuilderTest.kava </b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers.builder;<br /><br />import org.hamcrest.BaseMatcher;<br />import org.hamcrest.Description;<br />import org.hamcrest.Matcher;<br />import org.junit.Before;<br />import org.junit.Test;<br />import pl.grzejszczak.marcin.junit.matchers.pojo.SomeBigPojo;<br /><br />import static java.lang.String.format;<br />import static junit.framework.Assert.assertTrue;<br />import static org.apache.commons.lang.StringUtils.isNumeric;<br />import static org.junit.Assert.assertThat;<br />import static pl.grzejszczak.marcin.junit.matchers.pojo.SomePojoConstants.*;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 23:02<br /> */<br />public class SomeBigPojoBuilderTest {<br /><br />    private SomeBigPojoBuilder objectUnderTest;<br /><br />    @Before<br />    public void setUp(){<br />        objectUnderTest = new SomeBigPojoBuilder();<br />    }<br /><br />    @Test<br />    public void testCreateSomeBigPojoWithBuilder() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setBooleanField1(true)<br />                .setStringField0("1")<br />                .setStringField1("12")<br />                .setStringField2("123")<br />                .setStringField3("1234")<br />                .setStringField4("12345")<br />                .setStringField5("123456")<br />                .setStringField6("1234567")<br />                .setStringField7("12345678")<br />                .setStringField8("123456789")<br />                .setStringField9("1234567890")<br />                .createSomeBigPojoWithBuilder();<br /><br />        assertThat(someBigPojo, isPojoProperlyBuilt());<br />    }<br /><br />    @Test(expected = AssertionError.class)<br />    public void testCreateSomeBigPojoWithBuilderWrongFields() throws Exception {<br />        SomeBigPojo someBigPojo = objectUnderTest<br />                .setStringField0("0")<br />                .setStringField1("Too long")<br />                .createSomeBigPojoWithBuilder();<br /><br />        assertThat(someBigPojo, isPojoProperlyBuilt());<br />    }<br /><br />    /**<br />     * Let us assume that there is a specific business case that we have to take into consideration regarding some particular field<br />     *<br />     * @return<br />     */<br />    private static Matcher isPojoProperlyBuilt() {<br /><br />        return new BaseMatcher() {<br /><br />            @Override<br />            public boolean matches(Object o) {<br />                assertTrue(o instanceof SomeBigPojo);<br />                SomeBigPojo someBigPojo = (SomeBigPojo) o;<br />                assertThat(someBigPojo.getStringField0(), isOfGivenLength(STRING_FIELD_0_LENGTH));<br />                assertThat(someBigPojo.getStringField0(), isFieldOfNumericValue());<br /><br />                assertThat(someBigPojo.getStringField1(), isOfGivenLength(STRING_FIELD_1_LENGTH));<br />                assertThat(someBigPojo.getStringField1(), isFieldOfNumericValue());<br /><br />                assertThat(someBigPojo.getStringField2(), isOfGivenLength(STRING_FIELD_2_LENGTH));<br />                assertThat(someBigPojo.getStringField2(), isFieldOfNumericValue());<br /><br />                assertThat(someBigPojo.getStringField3(), isOfGivenLength(STRING_FIELD_3_LENGTH));<br />                assertThat(someBigPojo.getStringField3(), isFieldOfNumericValue());<br /><br />                assertThat(someBigPojo.getStringField4(), isOfGivenLength(STRING_FIELD_4_LENGTH));<br />                assertThat(someBigPojo.getStringField4(), isFieldOfNumericValue());<br /><br />                assertThat(someBigPojo.getStringField5(), isOfGivenLength(STRING_FIELD_5_LENGTH));<br /><br />                assertThat(someBigPojo.getStringField6(), isOfGivenLength(STRING_FIELD_6_LENGTH));<br /><br />                assertThat(someBigPojo.getStringField7(), isOfGivenLength(STRING_FIELD_7_LENGTH));<br /><br />                assertThat(someBigPojo.getStringField8(), isOfGivenLength(STRING_FIELD_8_LENGTH));<br /><br />                assertThat(someBigPojo.getStringField9(), isOfGivenLength(STRING_FIELD_9_LENGTH));<br /><br />                return true;<br />            }<br /><br />            @Override<br />            public void describeTo(Description description) {<br />                description.appendText("Lengths of fields are limited and the first 4 fields are numeric");<br />            }<br />        };<br />    }<br /><br />    private static Matcher isOfGivenLength(final Integer expectedLength) {<br /><br />        return new BaseMatcher() {<br /><br />            public boolean matches(Object o) {<br />                assertTrue(o instanceof String);<br />                return expectedLength == String.valueOf(o).length();<br />            }<br /><br />            public void describeTo(Description description) {<br />                description.appendText(format("String's length should be equal to [%d]", expectedLength));<br />            }<br />        };<br />    }<br /><br />    private static Matcher isFieldOfNumericValue() {<br /><br />        return new BaseMatcher() {<br /><br />            public boolean matches(Object o) {<br />                assertTrue(o instanceof String);<br />                return isNumeric(String.valueOf(o));<br />            }<br /><br />            public void describeTo(Description description) {<br />                description.appendText("The value of the field should be numeric");<br />            }<br />        };<br />    }<br />}<br /><br /></pre><br />The following main method executes the functions of the Service:<br /><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.junit.matchers;<br /><br />import pl.grzejszczak.marcin.junit.matchers.builder.SomeBigPojoBuilder;<br />import pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl;<br /><br />/**<br /> * Created with IntelliJ IDEA.<br /> * User: mgrzejszczak<br /> * Date: 03.01.13<br /> * Time: 22:38<br /> */<br />public class MatcherMain {<br />    public static void main(String[] args){<br />        SomeServiceImpl someService = new SomeServiceImpl();<br /><br />        someService.setSomeBigPojoBuilder(new SomeBigPojoBuilder());<br />        someService.someLogicForAPojoWithoutBuilder();<br /><br />        someService.setSomeBigPojoBuilder(new SomeBigPojoBuilder());<br />        someService.someLogicForAPojoWithBuilder();<br /><br />        someService.setSomeBigPojoBuilder(new SomeBigPojoBuilder());<br />        someService.someLogicForAPojoWithBuilderBadArgument();<br />    }<br />}<br /><br /></pre><br />And the logs are:<br /><br /><br /><pre class="brush:xml">pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:27 SomeLogicForAPojoWithoutBuilder executed<br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:30 StringField8 is equal [value]<br /><br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:32 SomeBigPojo{stringField0='string', integerField0=1, booleanField0=false, stringField1='other string', integerField1=123, booleanField1=true, stringField2='something else', integerField2=321, booleanField2=false, stringField3='yet another string', integerField3=111, booleanField3=true, stringField4='something', integerField4=2, booleanField4=false, stringField5='More', integerField5=3, booleanField5=true, stringField6='String', integerField6=12, booleanField6=false, stringField7='some', stringField8='value', stringField9='ofString'}<br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:37 SomeLogicForAPojoWithBuilder executed<br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:65 StringField8 is equal [value]<br /><br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:67 SomeBigPojo{stringField0='string', integerField0=1, booleanField0=false, stringField1='other string', integerField1=123, booleanField1=true, stringField2='something else', integerField2=321, booleanField2=false, stringField3='yet another string', integerField3=111, booleanField3=false, stringField4='something', integerField4=2, booleanField4=false, stringField5='More', integerField5=3, booleanField5=true, stringField6='String', integerField6=12, booleanField6=false, stringField7='some', stringField8='value', stringField9='ofString'}<br />pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl:72 someLogicForAPojoWithBuilderBadArgument executed<br />Exception in thread "main" java.lang.NullPointerException: StringField1 must not be null!<br /> at com.google.common.base.Preconditions.checkNotNull(Preconditions.java:208)<br /> at pl.grzejszczak.marcin.junit.matchers.builder.SomeBigPojoBuilder.checkState(SomeBigPojoBuilder.java:166)<br /> at pl.grzejszczak.marcin.junit.matchers.builder.SomeBigPojoBuilder.createSomeBigPojoWithBuilder(SomeBigPojoBuilder.java:170)<br /> at pl.grzejszczak.marcin.junit.matchers.service.SomeServiceImpl.someLogicForAPojoWithBuilderBadArgument(SomeServiceImpl.java:73)<br /> at pl.grzejszczak.marcin.junit.matchers.MatcherMain.main(MatcherMain.java:23)<br /> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br /> at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)<br /> at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)<br /> at java.lang.reflect.Method.invoke(Method.java:597)<br /> at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)</pre><br />In my opinion that looks really nice :) And what is yours?<br /><br /><a href="https://bitbucket.org/gregorin1987/too-much-coding/src/36becc07728e/Unit%20Testing%20-%20Matchers?at=default">Sources are available here at Too Much Codings code repository.</a><br /><br /><h2>UPDATE</h2><br />I've made some code changes and cleaning (not much though cause I didn't have too much time) and the code is available at github -&nbsp;<a href="https://github.com/marcingrzejszczak/too-much-coding/tree/master/Unit_Testing_-_Matchers">https://github.com/marcingrzejszczak/too-much-coding/tree/master/Unit_Testing_-_Matchers</a><br /><br /></div>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        










<span class="glyphicon glyphicon-calendar"></span> <time datetime="2012-12-24T14:54:00+01:00"  data-updated="true" itemprop="datePublished dateCreated">ordinal</time>
        
           | <a href="/articles/2012/12/24/google-guava-cache-with-regular/#disqus_thread" itemprop="discussionUrl"
             data-disqus-identifier="https://toomuchcoding.com/articles/2012/12/24/google-guava-cache-with-regular/">Comments</a>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/articles/2012/12/24/google-guava-cache-with-regular/" itemprop="url">Google Guava Cache with regular expression patterns</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><div class='post'>
<br /><br />Hi!  Merry Christmas everyone :)  Quite recently I've seen <a href="https://toomuchcoding.blogspot.com/2012/12/google-guava.html">a nice presentation about Google Guava</a> and we came to the conclusion in our project that it could be really interesting to use the <a href="https://code.google.com/p/guava-libraries/wiki/CachesExplained">its Cache functionallity</a>.  Let us take a look at the regexp Pattern class and its <a href="https://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#compile(java.lang.String)">compile function</a>. Quite often in the code we can see that each time a regular expression is being used a programmer is repeatidly calling the aforementioned Pattern.compile() function with the same argument thus compiling the same regular expression over and over again. What could be done however is to cache the result of such compilations - let us take a look at the RegexpUtils utility class:<br /><br />
<!--more-->
<b>RegexpUtils.java </b><br /><b><br /></b><pre class="brush:java">package pl.grzejszczak.marcin.guava.cache.utils;<br /><br />import com.google.common.cache.CacheBuilder;<br />import com.google.common.cache.CacheLoader;<br />import com.google.common.cache.LoadingCache;<br /><br />import java.util.concurrent.ExecutionException;<br />import java.util.regex.Matcher;<br />import java.util.regex.Pattern;<br /><br />import static java.lang.String.format;<br /><br />public final class RegexpUtils {<br /><br />    private RegexpUtils() {<br />        throw new UnsupportedOperationException("RegexpUtils is a utility class - don't instantiate it!");<br />    }<br /><br />    private static final LoadingCache&lt;String, Pattern&gt; COMPILED_PATTERNS =<br />            CacheBuilder.newBuilder().build(new CacheLoader&lt;String, Pattern&gt;() {<br />                @Override<br />                public Pattern load(String regexp) throws Exception {<br />                    return Pattern.compile(regexp);<br />                }<br />            });<br /><br />    public static Pattern getPattern(String regexp) {<br />        try {<br />            return COMPILED_PATTERNS.get(regexp);<br />        } catch (ExecutionException e) {<br />            throw new RuntimeException(format("Error when getting a pattern [%s] from cache", regexp), e);<br />        }<br />    }<br /><br />    public static boolean matches(String stringToCheck, String regexp) {<br />        return doGetMatcher(stringToCheck, regexp).matches();<br />    }<br /><br />    public static Matcher getMatcher(String stringToCheck, String regexp) {<br />        return doGetMatcher(stringToCheck, regexp);<br />    }<br /><br />    private static Matcher doGetMatcher(String stringToCheck, String regexp) {<br />        Pattern pattern = getPattern(regexp);<br />        return pattern.matcher(stringToCheck);<br />    }<br /><br />}<br /><br /></pre>As you can see the Guava's LoadingCache with the CacheBuilder is being used to populate a cache with a new compiled pattern if one is not found. Due to caching the compiled pattern if a compilation has already taken place it will not be repeated ever again (in our case since we dno't have any expiry set).  Now a simple test<br /><br /><b>GuavaCache.java </b><br /><b><br /></b><pre class="brush:java">package pl.grzejszczak.marcin.guava.cache;<br /><br /><br />import com.google.common.base.Stopwatch;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import pl.grzejszczak.marcin.guava.cache.utils.RegexpUtils;<br /><br />import java.util.regex.Pattern;<br /><br />import static java.lang.String.format;<br /><br />public class GuavaCache {<br />    private static final Logger LOGGER = LoggerFactory.getLogger(GuavaCache.class);<br />    public static final String STRING_TO_MATCH = "something";<br /><br />    public static void main(String[] args) {<br />        runTestForManualCompilationAndOneUsingCache(1);<br />        runTestForManualCompilationAndOneUsingCache(10);<br />        runTestForManualCompilationAndOneUsingCache(100);<br />        runTestForManualCompilationAndOneUsingCache(1000);<br />        runTestForManualCompilationAndOneUsingCache(10000);<br />        runTestForManualCompilationAndOneUsingCache(100000);<br />        runTestForManualCompilationAndOneUsingCache(1000000);<br />    }<br /><br />    private static void runTestForManualCompilationAndOneUsingCache(int firstNoOfRepetitions) {<br />        repeatManualCompilation(firstNoOfRepetitions);<br />        repeatCompilationWithCache(firstNoOfRepetitions);<br />    }<br /><br />    private static void repeatManualCompilation(int noOfRepetitions) {<br />        Stopwatch stopwatch = new Stopwatch().start();<br />        compileAndMatchPatternManually(noOfRepetitions);<br />        LOGGER.debug(format("Time needed to compile and check regexp expression [%d] ms, no of iterations [%d]", stopwatch.elapsedMillis(), noOfRepetitions));<br />    }<br /><br />    private static void repeatCompilationWithCache(int noOfRepetitions) {<br />        Stopwatch stopwatch = new Stopwatch().start();<br />        compileAndMatchPatternUsingCache(noOfRepetitions);<br />        LOGGER.debug(format("Time needed to compile and check regexp expression using Cache [%d] ms, no of iterations [%d]", stopwatch.elapsedMillis(), noOfRepetitions));<br />    }<br /><br />    private static void compileAndMatchPatternManually(int limit) {<br />        for (int i = 0; i &lt; limit; i++) {<br />            Pattern.compile("something").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something1").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something2").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something3").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something4").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something5").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something6").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something7").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something8").matcher(STRING_TO_MATCH).matches();<br />            Pattern.compile("something9").matcher(STRING_TO_MATCH).matches();<br />        }<br />    }<br /><br /><br />    private static void compileAndMatchPatternUsingCache(int limit) {<br />        for (int i = 0; i &lt; limit; i++) {<br />            RegexpUtils.matches(STRING_TO_MATCH, "something");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something1");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something2");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something3");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something4");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something5");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something6");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something7");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something8");<br />            RegexpUtils.matches(STRING_TO_MATCH, "something9");<br />        }<br />    }<br /><br />}<br /><br /></pre>We are running a series of tests and checking the time of their execution. Note that the results of these tests are not precise due to the fact that the application is not being run in isolation so numerous conditions can affect the time of the execution. We are interested in showing some degree of the problem rather than showing the precise execution time.  For a given number of iterations (1,10,100,1000,10000,100000,1000000) we are either compiling 10 regular expressions or using a Guava's cache to retrieve the compiled Pattern and then we match them against a string to match.  These are the logs: <br /><br /><pre class="brush:xml">pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [1] ms, no of iterations [1]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [35] ms, no of iterations [1]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [1] ms, no of iterations [10]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [0] ms, no of iterations [10]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [8] ms, no of iterations [100]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [3] ms, no of iterations [100]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [10] ms, no of iterations [1000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [10] ms, no of iterations [1000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [83] ms, no of iterations [10000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [33] ms, no of iterations [10000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [800] ms, no of iterations [100000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [279] ms, no of iterations [100000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:34 Time needed to compile and check regexp expression [7562] ms, no of iterations [1000000]<br />pl.grzejszczak.marcin.guava.cache.GuavaCache:40 Time needed to compile and check regexp expression using Cache [3067] ms, no of iterations [1000000]<br /></pre><br />You can find the <a href="https://bitbucket.org/gregorin1987/too-much-coding/src">sources over here</a> under the Guava/Cache directory or go to the url <a href="https://bitbucket.org/gregorin1987/too-much-coding/src">https://bitbucket.org/gregorin1987/too-much-coding/src</a>  </div>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        










<span class="glyphicon glyphicon-calendar"></span> <time datetime="2012-12-07T13:18:00+01:00"  data-updated="true" itemprop="datePublished dateCreated">ordinal</time>
        
           | <a href="/articles/2012/12/07/google-guava/#disqus_thread" itemprop="discussionUrl"
             data-disqus-identifier="https://toomuchcoding.com/articles/2012/12/07/google-guava/">Comments</a>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/articles/2012/12/07/google-guava/" itemprop="url">Google Guava</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><div class='post'>
Some interesting link:<br /><br /><a href="https://tomaszdziurko.pl/2012/02/google-guava/">Very nice presentation about Google Guava</a>, <a href="https://github.com/tdziurko/Guava-Lessons">sources</a></div>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        










<span class="glyphicon glyphicon-calendar"></span> <time datetime="2012-11-22T23:13:00+01:00"  data-updated="true" itemprop="datePublished dateCreated">ordinal</time>
        
           | <a href="/articles/2012/11/22/apache-camel-with-spring-routing-with/#disqus_thread" itemprop="discussionUrl"
             data-disqus-identifier="https://toomuchcoding.com/articles/2012/11/22/apache-camel-with-spring-routing-with/">Comments</a>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/articles/2012/11/22/apache-camel-with-spring-routing-with/" itemprop="url">Apache Camel with Spring, routing with enrichment service</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><div class='post'>
<br /><br />Sorry for not having posted anything in some time but I had plenty of work. Anyway today I will continue the example with JMS that I've shown you some time ago.<br />
<!--more-->
<br />The idea of the previous example was to simplify the work that we had to do in a manual way - we've sed JmsTemplate and Spring listener containers. The routing as such unfortunately was still done by us. In order to facilitate this process we can use <a href="https://camel.apache.org/">Apache Camel</a>.<br /><br />The following example bases on the one that we've seen in this post&nbsp;<a href="https://toomuchcoding.blogspot.com/2012/11/spring-jms-message-automatic-conversion.html">Spring JMS, message automatic conversion, JMS template</a>&nbsp;but with slight modifications:<br /><br /><b>CamelRouter.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel;<br /><br />import org.apache.camel.spring.Main;<br /><br />public class CamelRouter {<br /><br /> /**<br />  * @param args<br />  * @throws Exception<br />  */<br /> public static void main(String[] args) throws Exception {<br />  Main main = new Main();<br />  main.setApplicationContextUri("/camel/camelContext.xml");<br />  main.run(args);<br /> }<br /><br />}<br /><br /><br /></pre>What we can see here is the usage of the Camel's <span style="font-family: Courier New, Courier, monospace;">Main</span> class which you can reuse to more easily boot up Camel and keep it running until the JVM terminate. <br /><br />Then we have a new file <span style="font-family: Courier New, Courier, monospace;">camelContext.xml</span> in which we have the Camel context in the Spring configuration file.<br /><br /><b>camelContext.xml</b><br /><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="https://www.springframework.org/schema/beans" <br /> xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"<br /> xsi:schemaLocation="https://camel.apache.org/schema/spring https://camel.apache.org/schema/spring/camel-spring.xsd https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd "&gt;<br /> <br /> &lt;import resource="classpath:/camel/jmsApplicationContext.xml" /&gt;<br /> <br /> &lt;camel:camelContext id="camel" xmlns:camel="https://camel.apache.org/schema/spring"&gt;<br />  &lt;camel:dataFormats&gt;<br />   &lt;camel:jaxb id="jaxb" prettyPrint="true" contextPath="pl.grzejszczak.marcin.camel.jaxb.generated" /&gt;<br />  &lt;/camel:dataFormats&gt;<br /><br />  &lt;camel:route&gt;<br />   &lt;camel:from uri="activemq:topic:Initial.Topic" /&gt;<br />   &lt;camel:unmarshal ref="jaxb" /&gt;<br />   &lt;camel:bean ref="enrichingService" /&gt;<br />   &lt;camel:marshal ref="jaxb" /&gt;<br />   &lt;camel:to uri="activemq:topic:Routed.Topic" /&gt;<br />  &lt;/camel:route&gt;<br /><br /> &lt;/camel:camelContext&gt;<br />&lt;/beans&gt;<br /></pre><br />We are defining in this file in order to create a Camel Route - from the activemq topic called <i>Initial.Topic</i> to the one called <i>Routed.Topic</i>. In the meantime we are doing some unmarshalling and marshalling by means of Jaxb.<br /><br />In the jmsApplicationContext we no longer define the sender to the final topic: <i>Routed.Topic</i>.<br /><br /><b>jmsApplicationContext.java</b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="https://www.springframework.org/schema/beans"<br /> xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance" xmlns:context="https://www.springframework.org/schema/context"<br /> xmlns:jms="https://www.springframework.org/schema/jms" xmlns:oxm="https://www.springframework.org/schema/oxm"<br /> xsi:schemaLocation="https://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context-3.0.xsd https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd https://www.springframework.org/schema/jms https://www.springframework.org/schema/jms/spring-jms-3.0.xsd https://www.springframework.org/schema/oxm https://www.springframework.org/schema/oxm/spring-oxm-3.0.xsd"&gt;<br /><br /> &lt;!-- Spring configuration based on annotations --&gt;<br /> &lt;context:annotation-config /&gt;<br /> &lt;!-- Show Spring where to search for the beans (in which packages) --&gt;<br /> &lt;context:component-scan base-package="pl.grzejszczak.marcin.camel" /&gt;<br /> <br /> &lt;!-- Show Spring where to search for the properties files --&gt;<br /> &lt;context:property-placeholder location="classpath:/camel/jms.properties" /&gt;<br /><br /> &lt;!-- The ActiveMQ connection factory with specification of the server URL --&gt;<br /> &lt;bean id="activeMQConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;<br />  &lt;property name="brokerURL" value="tcp://localhost:61616" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Spring's jms connection factory --&gt;<br /> &lt;bean id="cachingConnectionFactory"<br />  class="org.springframework.jms.connection.CachingConnectionFactory"&gt;<br />  &lt;property name="targetConnectionFactory" ref="activeMQConnectionFactory" /&gt;<br />  &lt;property name="sessionCacheSize" value="10" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- The name of the queue from which we will take the messages --&gt;<br /> &lt;bean id="origin" class="org.apache.activemq.command.ActiveMQTopic"&gt;<br />  &lt;constructor-arg value="${jms.origin}" /&gt;<br /> &lt;/bean&gt;<br /> &lt;!-- The name of the queue to which we will route the messages --&gt;<br /> &lt;bean id="destination" class="org.apache.activemq.command.ActiveMQTopic"&gt;<br />  &lt;constructor-arg value="${jms.destination}" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Configuration of the JmsTemplate together with the connection factory and the message converter --&gt;<br /> &lt;bean id="producerTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;<br />  &lt;property name="connectionFactory" ref="cachingConnectionFactory" /&gt;<br />  &lt;property name="messageConverter" ref="oxmMessageConverter" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Custom message sender sending messages to the initial queue --&gt;<br /> &lt;bean id="originPlayerSender" class="pl.grzejszczak.marcin.camel.manual.jms.PlayerDetailsSenderImpl"&gt;<br />  &lt;property name="destination" ref="origin" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Custom message listener - listens to the destination queue  --&gt;<br /> &lt;bean id="destinationListenerImpl" class="pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl"/&gt;<br /><br /> <br /> &lt;!-- Spring's jms message listener container - specified the connection factory, the queue to be listened to and the component that listens to the queue --&gt;<br /> &lt;bean id="jmsDestinationContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;<br />  &lt;property name="connectionFactory" ref="cachingConnectionFactory" /&gt;<br />  &lt;property name="destination" ref="destination" /&gt;<br />  &lt;property name="messageListener" ref="destinationListenerImpl" /&gt;<br /> &lt;/bean&gt;<br /> <br /> &lt;!-- Message converter - automatically marshalls and unmarshalls messages using the provided marshaller / unmarshaller--&gt;<br /> &lt;bean id="oxmMessageConverter" class="org.springframework.jms.support.converter.MarshallingMessageConverter"&gt;<br />          &lt;property name="marshaller" ref="marshaller" /&gt;<br />          &lt;property name="unmarshaller" ref="marshaller" /&gt;<br />     &lt;/bean&gt;<br /><br /> &lt;bean id="enrichingService" class="pl.grzejszczak.marcin.camel.service.EnrichingServiceImpl"/&gt;<br /><br /> &lt;!-- Spring's JAXB implementation of marshaller - provided a class the JAXB generated class --&gt;<br />     &lt;oxm:jaxb2-marshaller id="marshaller"&gt;<br />          &lt;oxm:class-to-be-bound name="pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails" /&gt;<br />     &lt;/oxm:jaxb2-marshaller&gt;<br /><br />&lt;/beans&gt;<br /><br /></pre>Once we have already initialized our camel context, what we need to do is to send a message to the <i>Initial.Topic</i>. We are doing it by means of our modified <span style="font-family: Courier New, Courier, monospace;">ActiveMQRouter</span> class.<br /><br /><b>ActiveMQRouter.java</b><br /><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel.manual;<br /><br />import java.io.File;<br />import java.util.Scanner;<br /><br />import javax.jms.JMSException;<br /><br />import org.springframework.context.ApplicationContext;<br />import org.springframework.context.support.ClassPathXmlApplicationContext;<br />import org.springframework.core.io.ClassPathResource;<br />import org.springframework.core.io.Resource;<br /><br />import pl.grzejszczak.marcin.camel.jaxb.PlayerDetailsConverter;<br />import pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails;<br />import pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl;<br />import pl.grzejszczak.marcin.camel.manual.jms.Sender;<br /><br />public class ActiveMQRouter {<br /><br /> /**<br />  * @param args<br />  * @throws JMSException<br />  */<br /> public static void main(String[] args) throws Exception {<br />  ApplicationContext context = new ClassPathXmlApplicationContext("/camel/jmsApplicationContext.xml");<br />  @SuppressWarnings("unchecked")<br />  Sender&lt;PlayerDetails&gt; sender = (Sender&lt;PlayerDetails&gt;) context.getBean("originPlayerSender");<br /><br />  Resource resource = new ClassPathResource("/camel/RobertLewandowski.xml");<br /><br />  Scanner scanner = new Scanner(new File(resource.getURI())).useDelimiter("\\Z");<br />  String contents = scanner.next();<br /><br />  PlayerDetailsConverter converter = context.getBean(PlayerDetailsConverter.class);<br /><br />  FinalListenerImpl listener = (FinalListenerImpl) context.getBean("finalListenerImpl");<br /><br />  sender.sendMessage(converter.unmarshal(contents));<br /> }<br />}<br /><br /></pre>The class is reading the file and sending it to the initial topic. We also initialize a FinalListenerImpl - a class that will listen to the messages coming to the final topic - to prove that everything is working correctly.<br /><br />That's it! Now let's check out the logs. Logs of CamelRouter:<br /><br /><br /><pre class="brush:xml">2012-11-22 22:51:39,429 INFO  [main] org.apache.camel.main.MainSupport:300 Apache Camel 2.9.2 starting<br />2012-11-22 22:51:40,028 INFO  [main] org.springframework.context.support.ClassPathXmlApplicationContext:495 Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@4c5e176f: startup date [Thu Nov 22 22:51:40 CET 2012]; root of context hierarchy<br />2012-11-22 22:51:40,213 INFO  [main] org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [camel/camelContext.xml]<br />2012-11-22 22:51:40,746 INFO  [main] org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [camel/jmsApplicationContext.xml]<br />2012-11-22 22:51:41,120 INFO  [main] org.springframework.context.annotation.ClassPathBeanDefinitionScanner:210 JSR-330 'javax.inject.Named' annotation found and supported for component scanning<br />2012-11-22 22:51:43,219 INFO  [main] org.springframework.beans.factory.config.PropertyPlaceholderConfigurer:177 Loading properties file from class path resource [camel/jms.properties]<br />2012-11-22 22:51:43,233 INFO  [main] org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor:139 JSR-330 'javax.inject.Inject' annotation found and supported for autowiring<br />2012-11-22 22:51:43,274 INFO  [main] org.springframework.beans.factory.support.DefaultListableBeanFactory:557 Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@19d03a4e: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,AgeEnricher,ClubEnricher,PlayerDetailsConverter,finalListenerImpl,playerDetailsSenderImpl,org.springframework.beans.factory.config.PropertyPlaceholderConfigurer#0,activeMQConnectionFactory,cachingConnectionFactory,origin,destination,producerTemplate,originPlayerSender,destinationListenerImpl,jmsDestinationContainer,oxmMessageConverter,enrichingService,marshaller,template,consumerTemplate,camel:beanPostProcessor,camel,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy<br />2012-11-22 22:51:43,424 INFO  [main] org.springframework.oxm.jaxb.Jaxb2Marshaller:436 Creating JAXBContext with classes to be bound [class pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails]<br />2012-11-22 22:51:44,521 INFO  [main] org.springframework.context.support.DefaultLifecycleProcessor:334 Starting beans in phase 2147483647<br />2012-11-22 22:51:45,061 INFO  [main] org.springframework.jms.connection.CachingConnectionFactory:291 Established shared JMS Connection: ActiveMQConnection {id=ID:marcin-SR700-47684-1353621104666-1:1,clientId=null,started=false}<br />2012-11-22 22:51:45,608 INFO  [main] org.apache.camel.spring.SpringCamelContext:1374 Apache Camel 2.9.2 (CamelContext: camel) is starting<br />2012-11-22 22:51:45,611 INFO  [main] org.apache.camel.management.ManagementStrategyFactory:38 JMX enabled. Using ManagedManagementStrategy.<br />2012-11-22 22:51:45,850 INFO  [main] org.apache.camel.management.DefaultManagementLifecycleStrategy:790 StatisticsLevel at All so enabling load performance statistics<br />2012-11-22 22:51:45,961 INFO  [main] org.apache.camel.impl.converter.AnnotationTypeConverterLoader:119 Found 3 packages with 15 @Converter classes to load<br />2012-11-22 22:51:45,995 INFO  [main] org.apache.camel.impl.converter.DefaultTypeConverter:405 Loaded 170 core type converters (total 170 type converters)<br />2012-11-22 22:51:46,002 INFO  [main] org.apache.camel.impl.converter.AnnotationTypeConverterLoader:109 Loaded 2 @Converter classes<br />2012-11-22 22:51:46,023 INFO  [main] org.apache.camel.impl.converter.AnnotationTypeConverterLoader:119 Found 1 packages with 1 @Converter classes to load<br />2012-11-22 22:51:46,024 WARN  [main] org.apache.camel.impl.converter.DefaultTypeConverter:257 Overriding type converter from: StaticMethodTypeConverter: public static org.apache.activemq.command.ActiveMQDestination org.apache.camel.component.activemq.ActiveMQConverter.toDestination(java.lang.String) to: StaticMethodTypeConverter: public static org.apache.activemq.command.ActiveMQDestination org.apache.activemq.camel.converter.ActiveMQConverter.toDestination(java.lang.String)<br />2012-11-22 22:51:46,043 INFO  [main] org.apache.camel.impl.converter.DefaultTypeConverter:431 Loaded additional 3 type converters (total 173 type converters) in 0.041 seconds<br />2012-11-22 22:51:46,360 INFO  [main] org.apache.camel.converter.jaxb.JaxbDataFormat:277 Creating JAXBContext with contextPath: pl.grzejszczak.marcin.camel.jaxb.generated and ApplicationContextClassLoader: sun.misc.Launcher$AppClassLoader@35a16869<br />2012-11-22 22:51:46,500 INFO  [main] org.apache.camel.spring.SpringCamelContext:1980 Route: route1 started and consuming from: Endpoint[activemq://topic:Initial.Topic]<br />2012-11-22 22:51:46,509 INFO  [main] org.apache.camel.spring.SpringCamelContext:1409 Total 1 routes, of which 1 is started.<br />2012-11-22 22:51:46,510 INFO  [main] org.apache.camel.spring.SpringCamelContext:1410 Apache Camel 2.9.2 (CamelContext: camel) started in 0.901 seconds<br />2012-11-22 22:51:46,519 INFO  [main] org.springframework.context.support.DefaultLifecycleProcessor:334 Starting beans in phase 2147483647<br />2012-11-22 22:52:08,375 DEBUG [Camel (camel) thread #1 - JmsConsumer[Initial.Topic]] pl.grzejszczak.marcin.camel.service.EnrichingServiceImpl:21 Enriching player details<br />2012-11-22 22:52:08,377 DEBUG [Camel (camel) thread #1 - JmsConsumer[Initial.Topic]] pl.grzejszczak.marcin.camel.enricher.AgeEnricher:17 Enriching player [Lewandowski] with age data<br />2012-11-22 22:52:10,379 DEBUG [Camel (camel) thread #1 - JmsConsumer[Initial.Topic]] pl.grzejszczak.marcin.camel.enricher.ClubEnricher:16 Enriching player [Lewandowski] with club data<br />2012-11-22 22:52:12,462 DEBUG [jmsDestinationContainer-1] pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl:35 Message already enriched! Shutting down the system<br /><br /></pre>We can see that the Camel Context has been initialized and then the bean that we have created in the <span style="font-family: Courier New, Courier, monospace;">jmsApplicationContext.xml</span> that is listening to the final destination is acknowledging that the message has been enriched properly.<br /><br />What about the <span style="font-family: Courier New, Courier, monospace;">ActiveMQRouter.java</span> logs?<br /><br /><br /><pre class="brush:xml">2012-11-22 22:52:06,077 INFO  [main] org.springframework.context.support.ClassPathXmlApplicationContext:495 Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@43462851: startup date [Thu Nov 22 22:52:06 CET 2012]; root of context hierarchy<br />2012-11-22 22:52:06,153 INFO  [main] org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [camel/jmsApplicationContext.xml]<br />2012-11-22 22:52:06,417 INFO  [main] org.springframework.context.annotation.ClassPathBeanDefinitionScanner:210 JSR-330 'javax.inject.Named' annotation found and supported for component scanning<br />2012-11-22 22:52:06,721 INFO  [main] org.springframework.beans.factory.config.PropertyPlaceholderConfigurer:177 Loading properties file from class path resource [camel/jms.properties]<br />2012-11-22 22:52:06,733 INFO  [main] org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor:139 JSR-330 'javax.inject.Inject' annotation found and supported for autowiring<br />2012-11-22 22:52:06,758 INFO  [main] org.springframework.beans.factory.support.DefaultListableBeanFactory:557 Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@362f0d54: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,AgeEnricher,ClubEnricher,PlayerDetailsConverter,finalListenerImpl,playerDetailsSenderImpl,org.springframework.beans.factory.config.PropertyPlaceholderConfigurer#0,activeMQConnectionFactory,cachingConnectionFactory,origin,destination,producerTemplate,originPlayerSender,destinationListenerImpl,jmsDestinationContainer,oxmMessageConverter,enrichingService,marshaller,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy<br />2012-11-22 22:52:07,224 INFO  [main] org.springframework.oxm.jaxb.Jaxb2Marshaller:436 Creating JAXBContext with classes to be bound [class pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails]<br />2012-11-22 22:52:07,628 INFO  [main] org.springframework.context.support.DefaultLifecycleProcessor:334 Starting beans in phase 2147483647<br />2012-11-22 22:52:07,883 INFO  [main] org.springframework.jms.connection.CachingConnectionFactory:291 Established shared JMS Connection: ActiveMQConnection {id=ID:marcin-SR700-53586-1353621127755-1:1,clientId=null,started=false}<br />2012-11-22 22:52:08,093 DEBUG [main] pl.grzejszczak.marcin.camel.manual.jms.PlayerDetailsSenderImpl:26 Sending [pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails@3ea86d12] to topic [topic://Initial.Topic]<br />2012-11-22 22:52:12,463 DEBUG [jmsDestinationContainer-1] pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl:35 Message already enriched! Shutting down the system<br /><br /></pre>First we see that our spring Context has been initialized and then we see that a message has been sent to the <i>Initial.Topic</i>. At the end of the processing we can see that the listener is confirming that the message has been properly enriched - so all the Camel work has been done in a proper way.<br /><br />This example is showing how easy and simple it can be to create a routing / enriching service by means of Spring and Camel (integrated with Spring).<br /><br />The sources are available at <a href="https://bitbucket.org/gregorin1987/too-much-coding/src/26b70bca3b44e37c20c627e0efe4644d28f8d468/Camel%20and%20Spring?at=default">Too Much Coding's repository at bitbucket</a>.<br /><br /></div>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        










<span class="glyphicon glyphicon-calendar"></span> <time datetime="2012-11-06T17:58:00+01:00"  data-updated="true" itemprop="datePublished dateCreated">ordinal</time>
        
           | <a href="/articles/2012/11/06/sources-to-blog-posts/#disqus_thread" itemprop="discussionUrl"
             data-disqus-identifier="https://toomuchcoding.com/articles/2012/11/06/sources-to-blog-posts/">Comments</a>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/articles/2012/11/06/sources-to-blog-posts/" itemprop="url">Sources to blog posts</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><div class='post'>
I am happy to announce that I managed to find some time in order to create a repository for the code that I've been presenting here (at least for the most of it). You can find the <a href="https://bitbucket.org/gregorin1987/too-much-coding">Too Much Coding sources by clicking here</a> or type in the address&nbsp;<a href="https://bitbucket.org/gregorin1987/too-much-coding">https://bitbucket.org/gregorin1987/too-much-coding</a>.<br /><br />Enjoy :)</div>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        










<span class="glyphicon glyphicon-calendar"></span> <time datetime="2012-11-05T02:29:00+01:00"  data-updated="true" itemprop="datePublished dateCreated">ordinal</time>
        
           | <a href="/articles/2012/11/05/spring-jms-message-automatic-conversion/#disqus_thread" itemprop="discussionUrl"
             data-disqus-identifier="https://toomuchcoding.com/articles/2012/11/05/spring-jms-message-automatic-conversion/">Comments</a>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/articles/2012/11/05/spring-jms-message-automatic-conversion/" itemprop="url">Spring JMS, message automatic conversion, JMS template</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><div class='post'>
<br /><br />Hi!<br /><br />In one of my projects I was supposed to create a message router that like all routers was supposed to take the JMS messages from one topic and put it into another one. The message itself was a JMS text message that in fact contained an XML message. What is more after having received it I was supposed to enrich the message with some additional data.<br />
<!--more-->
<br />We were not allowed to use neither Spring nor JAXB nor any other useful library so I decided to check how easy it would be to do it using them. Initially I wanted to use only Spring and JAXB but in the next post I will try to repeat the same scenario by using Apache Camel (that's why you will find the word "camel" in the package name). The JMS communication was present thanks to the ActiveMQ messaging server.<br /><br />Anyway coming back to the code.<br /><br />I used maven to resolve dependencies and these are the dependencies that were mandatory i n terms of JMS and JAXB and message conversion:<br /><br /><b>pom.xml</b><br /><br /><pre class="brush:xml">  &lt;dependency&gt;<br />   &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />   &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;<br />   &lt;version&gt;3.1.1.RELEASE&lt;/version&gt;<br />  &lt;/dependency&gt;<br />  &lt;dependency&gt;<br />   &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt;<br />   &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt;<br />   &lt;version&gt;2.2.6&lt;/version&gt;<br />  &lt;/dependency&gt;<br />  &lt;dependency&gt;<br />   &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />   &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;<br />   &lt;version&gt;3.1.1.RELEASE&lt;/version&gt;<br />  &lt;/dependency&gt;<br /></pre><br /><br />This is how I divided the project (the camel part of the package will make more sense in the next article).<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-iNFJ6Htvx0Q/UJgnuxzQ2hI/AAAAAAAAAIQ/nBmCjDUaKfc/s1600/JMS.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="https://2.bp.blogspot.com/-iNFJ6Htvx0Q/UJgnuxzQ2hI/AAAAAAAAAIQ/nBmCjDUaKfc/s320/JMS.png" width="195" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><br />In order to have my message converted to objects via JAXB I needed a schema:<br /><br /><b>Player.xsd</b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;xsd:schema xmlns:xsd="https://www.w3.org/2001/XMLSchema"&gt;<br /><br /> &lt;xsd:element name="PlayerDetails"&gt;<br />  &lt;xsd:complexType&gt;<br />   &lt;xsd:sequence&gt;<br />    &lt;xsd:element name="Name" type="xsd:string" /&gt;<br />    &lt;xsd:element name="Surname" type="xsd:string" /&gt;<br />    &lt;xsd:element name="Position" type="PositionType" /&gt;<br />    &lt;xsd:element name="Age" type="xsd:int" /&gt;<br />    &lt;xsd:element name="TeamName" type="xsd:string" /&gt;<br />   &lt;/xsd:sequence&gt;<br />  &lt;/xsd:complexType&gt;<br /> &lt;/xsd:element&gt;<br /><br /><br /> &lt;xsd:simpleType name="PositionType"&gt;<br />  &lt;xsd:restriction base="xsd:string"&gt;<br />   &lt;xsd:enumeration value="GK" /&gt;<br />   &lt;xsd:enumeration value="DEF" /&gt;<br />   &lt;xsd:enumeration value="MID" /&gt;<br />   &lt;xsd:enumeration value="ATT" /&gt;<br />  &lt;/xsd:restriction&gt;<br /> &lt;/xsd:simpleType&gt;<br /><br />&lt;/xsd:schema&gt;<br /></pre><br />I had to download JAXB binaries and executed the following command to have my objects created:<br /><br /><pre class="brush:xml">./xjc.sh -p pl.grzejszczak.marcin.camel.jaxb.generated ~/PATH/TO/THE/SCHEMA/FILE/Player.xsd</pre><br /><b style="text-decoration: underline;">Note: </b>The same you can achieve by using maven. This approach is not in the blog's repository but believe me - it does work :D<br /><br />Add dependency to pom<br /><br /><pre class="brush:xml">&lt;dependency&gt;<br />    &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;<br />&nbsp; &nbsp; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;<br />&nbsp; &nbsp; &lt;version&gt;2.1&lt;/version&gt;<br />&lt;/dependency&gt;</pre><br /><br />Use the plugin (mind that the schema file needs to be specified or by default is searched for at <span style="font-family: Courier New, Courier, monospace;">src/main/xsd/</span> folder)<br /><br /><br /><pre class="brush:xml">&lt;build&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &lt;pluginManagement&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;plugins&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;plugin&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;version&gt;2.5.1&lt;/version&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/plugin&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/plugins&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &lt;/pluginManagement&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &lt;plugins&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;plugin&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;artifactId&gt;jaxb2-maven-plugin&lt;/artifactId&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;version&gt;1.5&lt;/version&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;executions&gt;<br />  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;execution&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;id&gt;xjc&lt;/id&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;goals&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;goal&gt;xjc&lt;/goal&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/goals&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/execution&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/executions&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;configuration&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;packageName&gt;pl.grzejszczak.marcin.camel.jaxb.generated&lt;/packageName&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/configuration&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;/plugin&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &lt;/plugins&gt;<br />&nbsp; &nbsp; &lt;/build&gt;</pre><br />An example of the outcome of this command or maven plugin is the following:<br /><br /><b>PlayerDetails.java</b><br /><br /><pre class="brush:java">//<br />// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.6 <br />// See <a href="https://java.sun.com/xml/jaxb">https://java.sun.com/xml/jaxb</a> <br />// Any modifications to this file will be lost upon recompilation of the source schema. <br />// Generated on: 2012.11.05 at 09:23:22 PM CET <br />//<br /><br /><br />package pl.grzejszczak.marcin.camel.jaxb.generated;<br /><br />import javax.xml.bind.annotation.XmlAccessType;<br />import javax.xml.bind.annotation.XmlAccessorType;<br />import javax.xml.bind.annotation.XmlElement;<br />import javax.xml.bind.annotation.XmlRootElement;<br />import javax.xml.bind.annotation.XmlType;<br /><br /><br />/**<br /> * Java class for anonymous complex type.<br /> * <br /> * <br /><br />The following schema fragment specifies the expected content contained within this class.<br /> * <br /> * <br /><br /><pre> * &lt;complexType&gt;<br /> *   &lt;complexContent&gt;<br /> *     &lt;restriction base="{https://www.w3.org/2001/XMLSchema}anyType"&gt;<br /> *       &lt;sequence&gt;<br /> *         &lt;element name="Name" type="{https://www.w3.org/2001/XMLSchema}string"/&gt;<br /> *         &lt;element name="Surname" type="{https://www.w3.org/2001/XMLSchema}string"/&gt;<br /> *         &lt;element name="Position" type="{}PositionType"/&gt;<br /> *         &lt;element name="Age" type="{https://www.w3.org/2001/XMLSchema}int"/&gt;<br /> *         &lt;element name="TeamName" type="{https://www.w3.org/2001/XMLSchema}string"/&gt;<br /> *       &lt;/sequence&gt;<br /> *     &lt;/restriction&gt;<br /> *   &lt;/complexContent&gt;<br /> * &lt;/complexType&gt;<br /> * </pre>*   *   */ @XmlAccessorType(XmlAccessType.FIELD) @XmlType(name = "", propOrder = {     "name",     "surname",     "position",     "age",     "teamName" }) @XmlRootElement(name = "PlayerDetails") public class PlayerDetails {      @XmlElement(name = "Name", required = true)     protected String name;     @XmlElement(name = "Surname", required = true)     protected String surname;     @XmlElement(name = "Position", required = true)     protected PositionType position;     @XmlElement(name = "Age")     protected int age;     @XmlElement(name = "TeamName", required = true)     protected String teamName;      /**      * Gets the value of the name property.      *       * @return      *     possible object is      *     {@link String }      *           */     public String getName() {         return name;     }      /**      * Sets the value of the name property.      *       * @param value      *     allowed object is      *     {@link String }      *           */     public void setName(String value) {         this.name = value;     }      /**      * Gets the value of the surname property.      *       * @return      *     possible object is      *     {@link String }      *           */     public String getSurname() {         return surname;     }      /**      * Sets the value of the surname property.      *       * @param value      *     allowed object is      *     {@link String }      *           */     public void setSurname(String value) {         this.surname = value;     }      /**      * Gets the value of the position property.      *       * @return      *     possible object is      *     {@link PositionType }      *           */     public PositionType getPosition() {         return position;     }      /**      * Sets the value of the position property.      *       * @param value      *     allowed object is      *     {@link PositionType }      *           */     public void setPosition(PositionType value) {         this.position = value;     }      /**      * Gets the value of the age property.      *       */     public int getAge() {         return age;     }      /**      * Sets the value of the age property.      *       */     public void setAge(int value) {         this.age = value;     }      /**      * Gets the value of the teamName property.      *       * @return      *     possible object is      *     {@link String }      *           */     public String getTeamName() {         return teamName;     }      /**      * Sets the value of the teamName property.      *       * @param value      *     allowed object is      *     {@link String }      *           */     public void setTeamName(String value) {         this.teamName = value;     }  }   </pre>The <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">@XmlRootElement(name = "PlayerDetails")</span> means that this class will output a Root node in the XML file. The <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">@XmlAccessorType(XmlAccessType.FIELD)</span> as the JavaDoc says means that  <i>"Every non static, non transient field in a JAXB-bound class will be automatically bound to XML, unless annotated by XmlTransient."</i> In other words, if you have a field annotated by the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">XmlTransient</span> annotation it won't get serialized. Then we have the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">@XmlType(name = "", propOrder = { "name", "surname", "position", "age", "teamName" })</span>which as JavaDoc sates <i>"</i><span class="Apple-style-span" style="background-color: white;"><i>Maps a class or an enum type to a XML Schema type</i></span><i>"</i>&nbsp;. In other words our class is mapped to the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">PlayerDetails</span>&nbsp;element in the schema. Finally we have the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">@XmlElement(name = "Name", required = true)</span> annotation which is a mapping of the XML node (element) to a field in the class.<br /><br />This is my message to be sent, received, enriched and routed:<br /><br /><b>RobertLewandowski.xml</b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;<br />&lt;PlayerDetails&gt;<br />    &lt;Name&gt;Robert&lt;/Name&gt;<br />    &lt;Surname&gt;Lewandowski&lt;/Surname&gt;<br />    &lt;Position&gt;ATT&lt;/Position&gt;<br />&lt;/PlayerDetails&gt;<br /></pre><br />Now off to my JMS configuration - I have configured the Queues of origin and destination<br /><br /><b>jms.properties</b><br /><br /><pre class="brush:xml">jms.origin=Initial.Queue<br />jms.destination=Routed.Queue<br /></pre><br />This is my Spring configuration (I added comments inside the config that explain the origin of those components):<br /><br /><b>jmsApplicationContext.xml</b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="https://www.springframework.org/schema/beans"<br /> xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance" xmlns:context="https://www.springframework.org/schema/context"<br /> xmlns:jms="https://www.springframework.org/schema/jms" xmlns:oxm="https://www.springframework.org/schema/oxm"<br /> xsi:schemaLocation="https://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context-3.0.xsd https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd https://www.springframework.org/schema/jms https://www.springframework.org/schema/jms/spring-jms-3.0.xsd https://www.springframework.org/schema/oxm https://www.springframework.org/schema/oxm/spring-oxm-3.0.xsd"&gt;<br /><br /> &lt;!-- Spring configuration based on annotations --&gt;<br /> &lt;context:annotation-config /&gt;<br /> &lt;!-- Show Spring where to search for the beans (in which packages) --&gt;<br /> &lt;context:component-scan base-package="pl.grzejszczak.marcin.camel" /&gt;<br /> <br /> &lt;!-- Show Spring where to search for the properties files --&gt;<br /> &lt;context:property-placeholder location="classpath:/camel/jms.properties" /&gt;<br /><br /> &lt;!-- The ActiveMQ connection factory with specification of the server URL --&gt;<br /> &lt;bean id="activeMQConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;<br />  &lt;property name="brokerURL" value="tcp://localhost:61616" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Spring's jms connection factory --&gt;<br /> &lt;bean id="cachingConnectionFactory"<br />  class="org.springframework.jms.connection.CachingConnectionFactory"&gt;<br />  &lt;property name="targetConnectionFactory" ref="activeMQConnectionFactory" /&gt;<br />  &lt;property name="sessionCacheSize" value="10" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- The name of the queue from which we will take the messages --&gt;<br /> &lt;bean id="origin" class="org.apache.activemq.command.ActiveMQQueue"&gt;<br />  &lt;constructor-arg value="${jms.origin}" /&gt;<br /> &lt;/bean&gt;<br /> &lt;!-- The name of the queue to which we will route the messages --&gt;<br /> &lt;bean id="destination" class="org.apache.activemq.command.ActiveMQQueue"&gt;<br />  &lt;constructor-arg value="${jms.destination}" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Configuration of the JmsTemplate together with the connection factory and the message converter --&gt;<br /> &lt;bean id="producerTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;<br />  &lt;property name="connectionFactory" ref="cachingConnectionFactory" /&gt;<br />  &lt;property name="messageConverter" ref="oxmMessageConverter" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Custom message sender sending messages to the initial queue --&gt;<br /> &lt;bean id="originPlayerSender" class="pl.grzejszczak.marcin.camel.manual.jms.PlayerDetailsSenderImpl"&gt;<br />  &lt;property name="destination" ref="origin" /&gt;<br /> &lt;/bean&gt;<br /> &lt;!-- Custom message sender sending messages to the destination queue --&gt;<br /> &lt;bean id="destinationPlayerSender" class="pl.grzejszczak.marcin.camel.manual.jms.PlayerDetailsSenderImpl"&gt;<br />  &lt;property name="destination" ref="destination" /&gt;<br /> &lt;/bean&gt;<br /><br /> &lt;!-- Custom message listener - listens to the initial queue  --&gt;<br /> &lt;bean id="originListenerImpl" class="pl.grzejszczak.marcin.camel.manual.jms.ListenerImpl"/&gt;<br /> &lt;!-- Custom message listener - listens to the destination queue  --&gt;<br /> &lt;bean id="destinationListenerImpl" class="pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl"/&gt;<br /><br /> &lt;!-- Spring's jms message listener container - specified the connection factory, the queue to be listened to and the component that listens to the queue --&gt;<br /> &lt;bean id="jmsOriginContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;<br />  &lt;property name="connectionFactory" ref="cachingConnectionFactory" /&gt;<br />  &lt;property name="destination" ref="origin" /&gt;<br />  &lt;property name="messageListener" ref="originListenerImpl" /&gt;<br /> &lt;/bean&gt;<br /> <br /> &lt;!-- Spring's jms message listener container - specified the connection factory, the queue to be listened to and the component that listens to the queue --&gt;<br /> &lt;bean id="jmsDestinationContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;<br />  &lt;property name="connectionFactory" ref="cachingConnectionFactory" /&gt;<br />  &lt;property name="destination" ref="destination" /&gt;<br />  &lt;property name="messageListener" ref="destinationListenerImpl" /&gt;<br /> &lt;/bean&gt;<br /> <br /> &lt;!-- Message converter - automatically marshalls and unmarshalls messages using the provided marshaller / unmarshaller--&gt;<br /> &lt;bean id="oxmMessageConverter" class="org.springframework.jms.support.converter.MarshallingMessageConverter"&gt;<br />          &lt;property name="marshaller" ref="marshaller" /&gt;<br />          &lt;property name="unmarshaller" ref="marshaller" /&gt;<br />     &lt;/bean&gt;<br /><br /> &lt;!-- Spring's JAXB implementation of marshaller - provided a class the JAXB generated class --&gt;<br />     &lt;oxm:jaxb2-marshaller id="marshaller"&gt;<br />          &lt;oxm:class-to-be-bound name="pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails" /&gt;<br />     &lt;/oxm:jaxb2-marshaller&gt;<br /><br />&lt;/beans&gt;<br /><br /></pre>Now let's take a look at the Java code - let's start with the class that has the main function<br /><br /><b>ActiveMQRouter.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel.manual;<br /><br />import java.io.File;<br />import java.util.Scanner;<br /><br />import javax.jms.JMSException;<br /><br />import org.springframework.context.ApplicationContext;<br />import org.springframework.context.support.ClassPathXmlApplicationContext;<br />import org.springframework.core.io.ClassPathResource;<br />import org.springframework.core.io.Resource;<br /><br />import pl.grzejszczak.marcin.camel.jaxb.PlayerDetailsConverter;<br />import pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails;<br />import pl.grzejszczak.marcin.camel.manual.jms.Sender;<br /><br />public class ActiveMQRouter {<br /><br /> /**<br />  * @param args<br />  * @throws JMSException<br />  */<br /> public static void main(String[] args) throws Exception {<br />  ApplicationContext context = new ClassPathXmlApplicationContext("/camel/jmsApplicationContext.xml");<br />  @SuppressWarnings("unchecked")<br />  Sender&lt;PlayerDetails&gt; sender = (Sender&lt;PlayerDetails&gt;) context.getBean("originPlayerSender");<br /><br />  Resource resource = new ClassPathResource("/camel/RobertLewandowski.xml");<br /><br />  Scanner scanner = new Scanner(new File(resource.getURI())).useDelimiter("\\Z");<br />  String contents = scanner.next();<br /><br />  PlayerDetailsConverter converter = context.getBean(PlayerDetailsConverter.class);<br /><br />  sender.sendMessage(converter.unmarshal(contents));<br /> }<br />}</pre><pre class="brush:java"></pre>What we can see here is that we initialize the Spring context from the classpath and retrieve the bean named <span style="font-family: 'Courier New', Courier, monospace;">originPlayerSender</span>. This component is used for sending a message to the initial queue. In order to have a message to send we are retrieving a file <span style="font-family: 'Courier New', Courier, monospace;">RobertLewandowski.xml</span> from the classpath and read it to a String variable through the <span style="font-family: 'Courier New', Courier, monospace;">Scanner</span> class. Next we use our custom <span style="font-family: 'Courier New', Courier, monospace;">PlayerDetailsConverter</span> class to unmarshall the String contents into a <span style="font-family: 'Courier New', Courier, monospace;">PlayerDetails</span> object, which in effect is sent by the <span style="font-family: 'Courier New', Courier, monospace;">originPlayerSender</span> to the origin queue.<br /><br />Now let's take a look at the sender logic:<br /><br /><b>PlayerDetailsSenderImpl.java</b><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel.manual.jms;<br /><br />import javax.jms.Destination;<br />import javax.jms.JMSException;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.jms.core.JmsTemplate;<br />import org.springframework.stereotype.Component;<br /><br />import pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails;<br /><br />@Component<br />public class PlayerDetailsSenderImpl implements Sender&lt;PlayerDetails&gt; {<br /><br /> private static final Logger LOGGER = LoggerFactory.getLogger(PlayerDetailsSenderImpl.class);<br /><br /> private Destination destination;<br /><br /> @Autowired<br /> private JmsTemplate jmsTemplate;<br /><br /> @Override<br /> public void sendMessage(final PlayerDetails object) throws JMSException {<br />  LOGGER.debug("Sending [{}] to topic [{}]", new Object[] { object, destination });<br />  jmsTemplate.convertAndSend(destination, object);<br /> }<br /><br /> public Destination getDestination() {<br />  return destination;<br /> }<br /><br /> public void setDestination(Destination destination) {<br />  this.destination = destination;<br /> }<br /><br />}<br /><br /></pre>This class is implementing my <span style="font-family: 'Courier New', Courier, monospace;">Sender</span> interface that provides the <span style="font-family: 'Courier New', Courier, monospace;">sendMessage</span> function. We are using the <span style="font-family: 'Courier New', Courier, monospace;">JmsTemplate</span> object to convert and send the message to the given <span style="font-family: 'Courier New', Courier, monospace;">destination</span> that is injected via Spring.<br /><br />Ok, now that we've sent the message someone has to retrieve it:<br /><br /><b>ListenerImpl.java</b><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel.manual.jms;<br /><br />import java.util.List;<br /><br />import javax.jms.BytesMessage;<br />import javax.jms.Message;<br />import javax.jms.MessageListener;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.beans.factory.annotation.Qualifier;<br />import org.springframework.jms.support.converter.MessageConverter;<br />import org.springframework.stereotype.Component;<br /><br />import pl.grzejszczak.marcin.camel.enricher.Enrichable;<br />import pl.grzejszczak.marcin.camel.jaxb.Convertable;<br />import pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails;<br /><br />@Component<br />public class ListenerImpl implements MessageListener {<br /><br /> private static final Logger LOG = LoggerFactory.getLogger(ListenerImpl.class);<br /><br /> @Autowired<br /> private Convertable&lt;PlayerDetails&gt; playerDetailsConverter;<br /><br /> @Autowired<br /> private List&lt;Enrichable&lt;PlayerDetails&gt;&gt; listOfEnrichers;<br /><br /> @Autowired<br /> private MessageConverter messageConverter;<br /><br /> @Autowired<br /> @Qualifier("destinationPlayerSender")<br /> private Sender&lt;PlayerDetails&gt; sender;<br /><br /> @Override<br /> public void onMessage(Message message) {<br />  if (!(message instanceof BytesMessage)) {<br />   LOG.error("Wrong msg!");<br />   return;<br />  }<br /><br />  PlayerDetails playerDetails = null;<br />  try {<br />   playerDetails = (PlayerDetails) messageConverter.fromMessage(message);<br /><br />   LOG.debug("Enriching the input message");<br />   for (Enrichable&lt;PlayerDetails&gt; enrichable : listOfEnrichers) {<br />    enrichable.enrich(playerDetails);<br />   }<br />   LOG.debug("Enriched text message: [{}]", new Object[] { playerDetailsConverter.marshal(playerDetails) });<br />   sender.sendMessage(playerDetails);<br />  } catch (Exception e) {<br />   LOG.error("Exception occured", e);<br />  }<br /><br /> }<br /><br />}<br /><br /></pre>This class has the list of all the classes implementing the <span style="font-family: 'Courier New', Courier, monospace;">Enrichable</span> interface thanks to which it will provide the enrichment of the message without the necessity of knowing the amount of enrichers in the system. There is also the <span style="font-family: 'Courier New', Courier, monospace;">PlayerDetailsConverter</span> class that helps with marshalling and unmarshalling <span style="font-family: 'Courier New', Courier, monospace;">PlayerDetails</span>. Once the message is enriched it is sent to the destination queue through the bean that implements the <span style="font-family: 'Courier New', Courier, monospace;">Sender</span> interface and has the id of <span style="font-family: 'Courier New', Courier, monospace;">destinationPlayerSender</span>. It is important to remember that what we receive from the queue is a <span style="font-family: 'Courier New', Courier, monospace;">BytesMessage</span> thus that's why we are doing the initial check.<br /><br />Let's take a look at one of the enrichers (the other one is a setting another field in the <span style="font-family: 'Courier New', Courier, monospace;">PlayerDetails</span> object)<br /><br /><b>ClubEnricher.java</b><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel.enricher;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.stereotype.Component;<br /><br />import pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails;<br /><br />@Component("ClubEnricher")<br />public class ClubEnricher implements Enrichable&lt;PlayerDetails&gt; {<br /><br /> private static final Logger LOGGER = LoggerFactory.getLogger(ClubEnricher.class);<br /><br /> @Override<br /> public void enrich(PlayerDetails inputObject) {<br />  LOGGER.debug("Enriching player [{}] with club data", new Object[] { inputObject.getSurname() });<br />  // Simulating accessing DB or some other service<br />  try {<br />   Thread.sleep(2000);<br />  } catch (InterruptedException e) {<br />   LOGGER.error("Exception while sleeping occured", e);<br />  }<br />  inputObject.setTeamName("Borussia Dortmund");<br /> }<br /><br />}<br /><br /></pre>As you can see the class is just simulating some access to the DB or any other service and afterwards is setting the team name in the input <span style="font-family: 'Courier New', Courier, monospace;">PlayerDetails </span>object.<br /><br />Let's now take a look a the conversion mechanism:<br /><br /><b>PlayerDetailsConverter.java</b><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel.jaxb;<br /><br />import java.io.ByteArrayOutputStream;<br />import java.io.OutputStream;<br /><br />import javax.xml.bind.JAXBContext;<br />import javax.xml.bind.JAXBException;<br />import javax.xml.bind.Marshaller;<br />import javax.xml.bind.Unmarshaller;<br /><br />import org.apache.activemq.util.ByteArrayInputStream;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.stereotype.Component;<br /><br />import pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails;<br /><br />@Component("PlayerDetailsConverter")<br />public class PlayerDetailsConverter implements Convertable&lt;PlayerDetails&gt; {<br /> private static final Logger LOGGER = LoggerFactory.getLogger(PlayerDetailsConverter.class);<br /><br /> private final JAXBContext jaxbContext;<br /> private final Marshaller jaxbMarshaller;<br /> private final Unmarshaller jaxbUnmarshaller;<br /><br /> public PlayerDetailsConverter() throws JAXBException {<br />  jaxbContext = JAXBContext.newInstance(PlayerDetails.class);<br />  jaxbMarshaller = jaxbContext.createMarshaller();<br />  jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);<br />  jaxbUnmarshaller = jaxbContext.createUnmarshaller();<br /> }<br /><br /> @Override<br /> public String marshal(PlayerDetails object) {<br />  OutputStream stream = new ByteArrayOutputStream();<br />  try {<br />   jaxbMarshaller.marshal(object, stream);<br />  } catch (JAXBException e) {<br />   LOGGER.error("Exception occured while marshalling", e);<br />  }<br />  return stream.toString();<br /> }<br /><br /> @Override<br /> public PlayerDetails unmarshal(String objectAsString) {<br />  try {<br />   return (PlayerDetails) jaxbUnmarshaller.unmarshal(new ByteArrayInputStream(objectAsString.getBytes()));<br />  } catch (JAXBException e) {<br />   LOGGER.error("Exception occured while marshalling", e);<br />  }<br />  return null;<br /> }<br /><br />}<br /><br /></pre>In the constructor we are setting some <span style="font-family: 'Courier New', Courier, monospace;">JAXB</span> components - the <span style="font-family: 'Courier New', Courier, monospace;">JAXBContext</span>,&nbsp;JAXB&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">Marshaller</span> and&nbsp;JAXB&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">Unmarshaller&nbsp;</span>that&nbsp;have the necessary marshal and unmarshal methods.<br /><br />Last but not least is the <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">FinalListenerImpl</span> that is listening to the inbound message from the destination queue and shuts the application.<br /><br /><b>FinalListenerImpl.java</b><br /><pre class="brush:java">package pl.grzejszczak.marcin.camel.manual.jms;<br /><br />import javax.jms.BytesMessage;<br />import javax.jms.Message;<br />import javax.jms.MessageListener;<br /><br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.jms.support.converter.MessageConverter;<br />import org.springframework.stereotype.Component;<br /><br />import pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails;<br /><br />@Component<br />public class FinalListenerImpl implements MessageListener {<br /><br /> private static final Logger LOG = LoggerFactory.getLogger(FinalListenerImpl.class);<br /><br /> @Autowired<br /> private MessageConverter messageConverter;<br /><br /> @Override<br /> public void onMessage(Message message) {<br />  if (!(message instanceof BytesMessage)) {<br />   LOG.error("Wrong msg!");<br />   return;<br />  }<br /><br />  PlayerDetails playerDetails = null;<br />  try {<br />   playerDetails = (PlayerDetails) messageConverter.fromMessage(message);<br /><br />   if (playerDetails.getTeamName() != null) {<br />    LOG.debug("Message already enriched! Shutting down the system");<br />    System.exit(0);<br />   } else {<br />    LOG.debug("The message should have been enriched but wasn't");<br />    System.exit(1);<br />   }<br /><br />  } catch (Exception e) {<br />   LOG.error("Exception occured", e);<br />  }<br /><br /> }<br /><br />}<br /><br /></pre>By using the <span style="font-family: Courier New, Courier, monospace;">MessageConverter</span>, after having verified if the message is of proper type, we check if the team name has already been filled in - if that is the case we are terminating the application.<br /><br />And the logs are as follows:<br /><br /><pre class="brush:xml">2012-11-05 [main] org.springframework.context.support.ClassPathXmlApplicationContext:495 Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@34fbb7cb: startup date [Mon Nov 05 21:47:00 CET 2012]; root of context hierarchy<br />2012-11-05 [main] org.springframework.beans.factory.xml.XmlBeanDefinitionReader:315 Loading XML bean definitions from class path resource [camel/jmsApplicationContext.xml]<br />2012-11-05 [main] org.springframework.beans.factory.config.PropertyPlaceholderConfigurer:177 Loading properties file from class path resource [camel/jms.properties]<br />2012-11-05 [main] org.springframework.beans.factory.support.DefaultListableBeanFactory:557 Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@3313beb5: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.internalPersistenceAnnotationProcessor,myRoute,AgeEnricher,ClubEnricher,PlayerDetailsConverter,finalListenerImpl,listenerImpl,playerDetailsSenderImpl,org.springframework.beans.factory.config.PropertyPlaceholderConfigurer#0,activeMQConnectionFactory,cachingConnectionFactory,origin,destination,producerTemplate,originPlayerSender,destinationPlayerSender,originListenerImpl,destinationListenerImpl,jmsOriginContainer,jmsDestinationContainer,oxmMessageConverter,marshaller,org.springframework.context.annotation.ConfigurationClassPostProcessor$ImportAwareBeanPostProcessor#0]; root of factory hierarchy<br />2012-11-05 [main] org.springframework.oxm.jaxb.Jaxb2Marshaller:436 Creating JAXBContext with classes to be bound [class pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails]<br />2012-11-05 [main] org.springframework.context.support.DefaultLifecycleProcessor:334 Starting beans in phase 2147483647<br />2012-11-05 [main] org.springframework.jms.connection.CachingConnectionFactory:291 Established shared JMS Connection: ActiveMQConnection {id=ID:marcin-SR700-38535-1352148424687-1:1,clientId=null,started=false}<br />2012-11-05 [main] pl.grzejszczak.marcin.camel.manual.jms.PlayerDetailsSenderImpl:26 Sending [pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails@6ae2d0b2] to topic [queue://Initial.Queue]<br />2012-11-05 [jmsOriginContainer-1] pl.grzejszczak.marcin.camel.manual.jms.ListenerImpl:49 Enriching the input message<br />2012-11-05 [jmsOriginContainer-1] pl.grzejszczak.marcin.camel.enricher.AgeEnricher:17 Enriching player [Lewandowski] with age data<br />2012-11-05 [jmsOriginContainer-1] pl.grzejszczak.marcin.camel.enricher.ClubEnricher:16 Enriching player [Lewandowski] with club data<br />2012-11-05 [jmsOriginContainer-1] pl.grzejszczak.marcin.camel.manual.jms.ListenerImpl:53 Enriched text message: [&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;<br />&lt;PlayerDetails&gt;<br />    &lt;Name&gt;Robert&lt;/Name&gt;<br />    &lt;Surname&gt;Lewandowski&lt;/Surname&gt;<br />    &lt;Position&gt;ATT&lt;/Position&gt;<br />    &lt;Age&gt;19&lt;/Age&gt;<br />    &lt;TeamName&gt;Borussia Dortmund&lt;/TeamName&gt;<br />&lt;/PlayerDetails&gt;<br />]<br />2012-11-05 [jmsOriginContainer-1] pl.grzejszczak.marcin.camel.manual.jms.PlayerDetailsSenderImpl:26 Sending [pl.grzejszczak.marcin.camel.jaxb.generated.PlayerDetails@3dca1588] to topic [queue://Routed.Queue]<br />2012-11-05 [jmsDestinationContainer-1] pl.grzejszczak.marcin.camel.manual.jms.FinalListenerImpl:35 Message already enriched! Shutting down the system<br /><br /></pre><br /><br />This is how thanks to the Spring JMS module and the JAXB library you can easilly create JMS listeners, senders and message convertors for the XML messages.<br /><br /></div>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        










<span class="glyphicon glyphicon-calendar"></span> <time datetime="2012-10-28T02:06:00+01:00"  data-updated="true" itemprop="datePublished dateCreated">ordinal</time>
        
           | <a href="/articles/2012/10/28/spring-aop-in-security-controlling/#disqus_thread" itemprop="discussionUrl"
             data-disqus-identifier="https://toomuchcoding.com/articles/2012/10/28/spring-aop-in-security-controlling/">Comments</a>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/articles/2012/10/28/spring-aop-in-security-controlling/" itemprop="url">Spring AOP in security - controlling creation of UI components via aspects</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><div class='post'>
<br /><br />The following post will show how in one of the projects that I took part in we used Spring's AOP to introduce some security related functionalities. The concept was such that in order for the user to see some UI components he needed to have a certain level of security privillages. If that requirement was not met then the UIComponent was not presented. Let's take a look at the project structure:<br />
<!--more-->
<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-SpxeeCEcyaE/UIx6drCJ6sI/AAAAAAAAAHw/ASHo5_3RQQ0/s1600/Aspects+project.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="https://3.bp.blogspot.com/-SpxeeCEcyaE/UIx6drCJ6sI/AAAAAAAAAHw/ASHo5_3RQQ0/s320/Aspects+project.png" width="254" /></a></div><br />Then there were also the <b><span style="font-family: inherit;">aopApplicationContext.xml :</span></b><br /><br /><pre class="brush:xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="https://www.springframework.org/schema/beans"<br /> xmlns:context="https://www.springframework.org/schema/context"<br /> xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance"<br /> xmlns:aop="https://www.springframework.org/schema/aop"<br /> xsi:schemaLocation="https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd<br />        https://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context-3.0.xsd<br />        https://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx-3.0.xsd<br />        https://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util-3.1.xsd<br />        https://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;<br /><br /> &lt;aop:aspectj-autoproxy /&gt;<br /> &lt;context:annotation-config /&gt;<br /> &lt;context:component-scan base-package="pl.grzejszczak.marcin.aop"&gt;<br />  &lt;context:exclude-filter type="annotation" expression="org.aspectj.lang.annotation.Aspect"/&gt;<br /> &lt;/context:component-scan&gt;<br /> &lt;bean class="pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor" factory-method="aspectOf"/&gt; <br /><br />&lt;/beans&gt;<br /><br /></pre>Now let's take a look at the most interesting lines of the Spring's application context.<br /><br />First we have all the required schemas - I don't think that this needs to be explained in more depth.<br/> Then we have:<br /><pre class="brush:xml">&lt;aop:aspectj-autoproxy/&gt;</pre><br /><br />which enables the <b>@AspectJ</b> support.<br /><br />Next there is the<br /><br /><pre class="brush:xml">&lt;context:annotation-config /&gt;<br />&lt;context:component-scan base-package="pl.grzejszczak.marcin.aop"&gt;<br />    &lt;context:exclude-filter type="annotation" expression="org.aspectj.lang.annotation.Aspect"/&gt;<br />&lt;/context:component-scan&gt;</pre><br />first we are turning on Spring configuration via annotations. Then deliberatly we exclude aspects from being initialized as beans by Spring itself. Why? Because...<br /><br /><pre class="brush:xml">&lt;bean class="pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor" factory-method="aspectOf"/&gt;</pre><br />we want to create the aspect by ourselves and provide the <span style="font-family: 'Courier New', Courier, monospace;">factory-method="aspectOf"</span> . By doing so our aspect will be included in the autowiring process of our beans - thus all the fields annotated with the <span style="font-family: 'Courier New', Courier, monospace;">@Autowired</span> annotation will get the beans injected.<br /><br />Now let's move on to the code:<br /><br /><b>UserServiceImpl.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.service;<br /><br />import org.springframework.stereotype.Service;<br /><br />import pl.grzejszczak.marcin.aop.type.Role;<br />import pl.grzejszczak.marcin.aop.user.UserHolder;<br /><br />@Service<br />public class UserServiceImpl implements UserService {<br /> private UserHolder userHolder;<br /><br /> @Override<br /> public UserHolder getCurrentUser() {<br />  return userHolder;<br /> }<br /><br /> @Override<br /> public void setCurrentUser(UserHolder userHolder) {<br />  this.userHolder = userHolder;<br /> }<br /><br /> @Override<br /> public Role getUserRole() {<br />  if (userHolder == null) {<br />   return null;<br />  }<br />  return userHolder.getUserRole();<br /> }<br />}<br /></pre><br />The class UserServiceImpl is immitating a service that would get the current user information from the db or from the current application context.<br /><br /><b>UserHolder.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.user;<br /><br />import pl.grzejszczak.marcin.aop.type.Role;<br /><br />public class UserHolder {<br /> private Role userRole;<br /><br /> public UserHolder(Role userRole) {<br />  this.userRole = userRole;<br /> }<br /><br /> public Role getUserRole() {<br />  return userRole;<br /> }<br /><br /> public void setUserRole(Role userRole) {<br />  this.userRole = userRole;<br /> }<br />}<br /></pre><br /><br />This is a simple holder class that holds information about current user Role.<br /><br /><b>Role.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.type;<br /><br /><br />public enum Role {<br /> ADMIN("ADM"), WRITER("WRT"), GUEST("GST");<br /><br /> private String name;<br /><br /> private Role(String name) {<br />  this.name = name;<br /> }<br /><br /> public static Role getRoleByName(String name) {<br /><br />  for (Role role : Role.values()) {<br /><br />   if (role.name.equals(name)) {<br />    return role;<br />   }<br />  }<br /><br />  throw new IllegalArgumentException("No such role exists [" + name + "]");<br /> }<br /><br /> public String getName() {<br />  return this.name;<br /> }<br /><br /> @Override<br /> public String toString() {<br />  return name;<br /> }<br />}<br /></pre><br />Role is an enum that defines a role for a person being an <i>Admin</i>, <i>Writer</i> or a <i>Guest</i>.<br /><br /><b>UIComponent.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.ui;<br /><br />public abstract class UIComponent {<br /> protected String componentName;<br /><br /> protected String getComponentName() {<br />  return componentName;<br /> }<br /><br />}<br /></pre><br />An abstraction over concrete implementations of some UI components.<br /><br /><b>SomeComponentForAdminAndGuest.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.ui;<br /><br />import pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation;<br />import pl.grzejszczak.marcin.aop.type.Role;<br /><br />@SecurityAnnotation(allowedRole = { Role.ADMIN, Role.GUEST })<br />public class SomeComponentForAdminAndGuest extends UIComponent {<br /><br /> public SomeComponentForAdminAndGuest() {<br />  this.componentName = "SomeComponentForAdmin";<br /> }<br /><br /> public static UIComponent getComponent() {<br />  return new SomeComponentForAdminAndGuest();<br /> }<br />}<br /></pre><br />This component is an example of a UI component extention that can be seen only by users who have roles of <i>Admin</i> or <i>Guest</i>.<br /><br /><b>SecurityAnnotation.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.annotation;<br /><br />import java.lang.annotation.Retention;<br />import java.lang.annotation.RetentionPolicy;<br /><br />import pl.grzejszczak.marcin.aop.type.Role;<br /><br />@Retention(RetentionPolicy.RUNTIME)<br />public @interface SecurityAnnotation {<br /> Role[] allowedRole();<br />}<br /></pre><br /><br />Annotation that defines a roles that can have this component created.<br /><br /><b>UIFactoryImpl.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop.ui;<br /><br />import org.apache.commons.lang.NullArgumentException;<br />import org.springframework.stereotype.Component;<br /><br />@Component<br />public class UIFactoryImpl implements UIFactory {<br /><br /> @Override<br /> public UIComponent createComponent(Class&lt;? extends UIComponent&gt; componentClass) throws Exception {<br />  if (componentClass == null) {<br />   throw new NullArgumentException("Provide class for the component");<br />  }<br />  return (UIComponent) Class.forName(componentClass.getName()).newInstance();<br /> }<br />}<br /></pre><br /><br />A factory class that given the class of an object that extends UIComponent returns a new instance of the given UIComponent.<br /><br /><b>SecurityInterceptor.java</b><br /><br /><pre class="brush:java"><br /><br />package pl.grzejszczak.marcin.aop.interceptor;<br /><br />import java.lang.annotation.Annotation;<br />import java.lang.reflect.AnnotatedElement;<br />import java.util.Arrays;<br />import java.util.List;<br /><br />import org.aspectj.lang.ProceedingJoinPoint;<br />import org.aspectj.lang.annotation.Around;<br />import org.aspectj.lang.annotation.Aspect;<br />import org.aspectj.lang.annotation.Pointcut;<br />import org.slf4j.Logger;<br />import org.slf4j.LoggerFactory;<br />import org.springframework.beans.factory.annotation.Autowired;<br /><br />import pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation;<br />import pl.grzejszczak.marcin.aop.service.UserService;<br />import pl.grzejszczak.marcin.aop.type.Role;<br />import pl.grzejszczak.marcin.aop.ui.UIComponent;<br /><br />@Aspect<br />public class SecurityInterceptor {<br /> private static final Logger LOGGER = LoggerFactory.getLogger(SecurityInterceptor.class);<br /><br /> public SecurityInterceptor() {<br />  LOGGER.debug(&quot;Security Interceptor created&quot;);<br /> }<br /><br /> @Autowired<br /> private UserService userService;<br /><br /> @Pointcut(&quot;execution(pl.grzejszczak.marcin.aop.ui.UIComponent pl.grzejszczak.marcin.aop.ui.UIFactory.createComponent(..))&quot;)<br /> private void getComponent(ProceedingJoinPoint thisJoinPoint) {<br /> }<br /><br /> @Around(&quot;getComponent(thisJoinPoint)&quot;)<br /> public UIComponent checkSecurity(ProceedingJoinPoint thisJoinPoint) throws Throwable {<br />  LOGGER.info(&quot;Intercepting creation of a component&quot;);<br /><br />  Object[] arguments = thisJoinPoint.getArgs();<br />  if (arguments.length == 0) {<br />   return null;<br />  }<br /><br />  Annotation annotation = checkTheAnnotation(arguments);<br />  boolean securityAnnotationPresent = (annotation != null);<br /><br />  if (securityAnnotationPresent) {<br />   boolean userHasRole = verifyRole(annotation);<br />   if (!userHasRole) {<br />    LOGGER.info(&quot;Current user doesn't have permission to have this component created&quot;);<br />    return null;<br />   }<br />  }<br />  LOGGER.info(&quot;Current user has required permissions for creating a component&quot;);<br />  return (UIComponent) thisJoinPoint.proceed();<br /> }<br /><br /> /**<br />  * Basing on the method's argument check if the class is annotataed with<br />  * {@link SecurityAnnotation}<br />  * <br />  * @param arguments<br />  * @return<br />  */<br /> private Annotation checkTheAnnotation(Object[] arguments) {<br />  Object concreteClass = arguments[0];<br />  LOGGER.info(&quot;Argument's class - [{}]&quot;, new Object[] { arguments });<br />  AnnotatedElement annotatedElement = (AnnotatedElement) concreteClass;<br />  Annotation annotation = annotatedElement.getAnnotation(SecurityAnnotation.class);<br />  LOGGER.info(&quot;Annotation present - [{}]&quot;, new Object[] { annotation });<br />  return annotation;<br /> }<br /><br /> /**<br />  * The function verifies if the current user has sufficient privilages to<br />  * have the component built<br />  * <br />  * @param annotation<br />  * @return<br />  */<br /> private boolean verifyRole(Annotation annotation) {<br />  LOGGER.info(&quot;Security annotation is present so checking if the user can use it&quot;);<br />  SecurityAnnotation annotationRule = (SecurityAnnotation) annotation;<br />  List&lt;Role&gt; requiredRolesList = Arrays.asList(annotationRule.allowedRole());<br />  Role userRole = userService.getUserRole();<br />  return requiredRolesList.contains(userRole);<br /> }<br />}<br /></pre><br /><br />This is the <b>aspect</b> defined at the <b>pointcut</b> of <b>executing</b> a function <span style="font-family: 'Courier New', Courier, monospace;">createComponent</span> of the <span style="font-family: 'Courier New', Courier, monospace;">UIFactory</span> interface. Inside the <b>Around</b> <b>advice</b> there is the logic that first checks what kind of an argument has been passed to the method <span style="font-family: 'Courier New', Courier, monospace;">createComponent</span> (for example&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">SomeComponentForAdminAndGuest.class</span>). Next it is checking if this class is annotated with <span style="font-family: 'Courier New', Courier, monospace;">SecurityAnnotation</span> and if that is the case it checks what kind of <span style="font-family: 'Courier New', Courier, monospace;">Roles</span> are required to have the component created. Afterwards it checks if the current user (from <span style="font-family: 'Courier New', Courier, monospace;">UserService</span> to <span style="font-family: 'Courier New', Courier, monospace;">UserHolder's</span> <span style="font-family: 'Courier New', Courier, monospace;">Roles</span>) has the required role to present the component. If that is the case <span style="font-family: 'Courier New', Courier, monospace;">thisJoinPoint.proceed()</span> is called which in effect returns the object of the class that extends <span style="font-family: 'Courier New', Courier, monospace;">UIComponent</span>.<br /><br />Now let's test it - here comes the&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">SpringJUnit4ClassRunner</span><br /><br /><b>AopTest.java</b><br /><br /><pre class="brush:java">package pl.grzejszczak.marcin.aop;<br /><br />import org.junit.Assert;<br />import org.junit.Test;<br />import org.junit.runner.RunWith;<br />import org.springframework.beans.factory.annotation.Autowired;<br />import org.springframework.test.context.ContextConfiguration;<br />import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br /><br />import pl.grzejszczak.marcin.aop.service.UserService;<br />import pl.grzejszczak.marcin.aop.type.Role;<br />import pl.grzejszczak.marcin.aop.ui.SomeComponentForAdmin;<br />import pl.grzejszczak.marcin.aop.ui.SomeComponentForAdminAndGuest;<br />import pl.grzejszczak.marcin.aop.ui.SomeComponentForGuest;<br />import pl.grzejszczak.marcin.aop.ui.SomeComponentForWriter;<br />import pl.grzejszczak.marcin.aop.ui.UIFactory;<br />import pl.grzejszczak.marcin.aop.user.UserHolder;<br /><br />@RunWith(SpringJUnit4ClassRunner.class)<br />@ContextConfiguration(locations = { "classpath:aopApplicationContext.xml" })<br />public class AopTest {<br /><br /> @Autowired<br /> private UIFactory uiFactory;<br /><br /> @Autowired<br /> private UserService userService;<br /><br /> @Test<br /> public void adminTest() throws Exception {<br />  userService.setCurrentUser(new UserHolder(Role.ADMIN));<br />  Assert.assertNotNull(uiFactory.createComponent(SomeComponentForAdmin.class));<br />  Assert.assertNotNull(uiFactory.createComponent(SomeComponentForAdminAndGuest.class));<br />  Assert.assertNull(uiFactory.createComponent(SomeComponentForGuest.class));<br />  Assert.assertNull(uiFactory.createComponent(SomeComponentForWriter.class));<br /> }<br />}<br /></pre><br /><br />And the logs:<br /><br /><pre class="brush:xml"><br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:26 Security Interceptor created<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:38 Intercepting creation of a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:48 Argument's class - [[class pl.grzejszczak.marcin.aop.ui.SomeComponentForAdmin]]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:54 Annotation present - [@pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation(allowedRole=[ADM])]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:57 Security annotation is present so checking if the user can use it<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:70 Current user has required permissions for creating a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:38 Intercepting creation of a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:48 Argument's class - [[class pl.grzejszczak.marcin.aop.ui.SomeComponentForAdminAndGuest]]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:54 Annotation present - [@pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation(allowedRole=[ADM, GST])]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:57 Security annotation is present so checking if the user can use it<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:70 Current user has required permissions for creating a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:38 Intercepting creation of a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:48 Argument's class - [[class pl.grzejszczak.marcin.aop.ui.SomeComponentForGuest]]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:54 Annotation present - [@pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation(allowedRole=[GST])]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:57 Security annotation is present so checking if the user can use it<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:66 Current user doesn't have permission to have this component created<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:38 Intercepting creation of a component<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:48 Argument's class - [[class pl.grzejszczak.marcin.aop.ui.SomeComponentForWriter]]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:54 Annotation present - [@pl.grzejszczak.marcin.aop.annotation.SecurityAnnotation(allowedRole=[WRT])]<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:57 Security annotation is present so checking if the user can use it<br />pl.grzejszczak.marcin.aop.interceptor.SecurityInterceptor:66 Current user doesn't have permission to have this component created<br /></pre><br />The unit test shows that for given Admin role only first two components get created whereas for the two others nulls are returned (due to the fact that user doesn't have proper rights).<br /><br />That is how in our project we used Spring's AOP to create a simple framework that would check if the user can have the given component created or not. Thanks to this after having programmed the aspects one doesn't have to remember about writing any security related code since it will be done for him.<br /><br />If you have any suggestions related to this post please feel free to comment it :)</div>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        










<span class="glyphicon glyphicon-calendar"></span> <time datetime="2012-10-24T23:22:00+02:00"  data-updated="true" itemprop="datePublished dateCreated">ordinal</time>
        
           | <a href="/articles/2012/10/24/mockito-invocationonmock-checking/#disqus_thread" itemprop="discussionUrl"
             data-disqus-identifier="https://toomuchcoding.com/articles/2012/10/24/mockito-invocationonmock-checking/">Comments</a>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/articles/2012/10/24/mockito-invocationonmock-checking/" itemprop="url">Mockito InvocationOnMock - checking an argument</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><div class='post'>
<br /><br />Hi!<br /><br />In one of my projects we had a very interesting situation in terms of testing. We couldn't mock an invocation of a static method due to the fact that PowerMock was not allowed to be used so there were plenty of objects and dependencies being initialized. What is more we were using a custom made dependency injection system that had a possibility of injecting a mock.<br />
<!--more-->
<br />The problem was such that during a test we wanted to assert whether one of the objects was in a very precise state. This object was created using the new operator so we couldn't mock it (again no PowerMock allowed). Fortunately this object got passed to a method of an object that we could mock...<br /><br />As presented below <span style="font-family: 'Courier New', Courier, monospace;">timeConsumingExternalService</span> is an object that we could mock via the custom dependency injection system whereas the <span style="font-family: 'Courier New', Courier, monospace;">SomePojo</span> class is an object whose state we would like to verify. <br /><br /><pre class="brush:java">timeConsumingExternalService.processSomeObject(new SomePojo("name", "surname", 1, 1.0));<br /></pre><br />So what we did was that in our mock to which the object got passed we created a new <span style="font-family: 'Courier New', Courier, monospace;">Answer&nbsp;</span>(the same <span style="font-family: 'Courier New', Courier, monospace;">Answer</span> that I spoke of <a href="https://toomuchcoding.blogspot.com/2012/10/simulation-of-time-consuming-actions-in.html">here</a>). Due to which we could access the <span style="font-family: 'Courier New', Courier, monospace;">InvocationOnMock</span> and the arguments passed to the method as such. <br /><br /><pre class="brush:java">Mockito.doAnswer(new Answer&lt;Object&gt;() {<br />   public Object answer(InvocationOnMock invocation) throws Throwable {<br />    Object[] object = invocation.getArguments();<br /><br />      if (object.length &gt; 0) {<br />          SomePojo somePojo = (SomePojo) object[0];<br /><br />          Assert.assertEquals("name", somePojo.getName());<br />          LOGGER.debug("Names are equal");<br />          Assert.assertEquals("surname", somePojo.getSurname());<br />          LOGGER.debug("Surnames are equal");<br />          Assert.assertTrue(1 == somePojo.getIntValue());<br />          LOGGER.debug("Ints are equal");<br />          Assert.assertTrue(1.0 == somePojo.getDoubleValue());<br />          LOGGER.debug("Doubles are equal");<br /><br />          LOGGER.debug("Object being an argument of the function [" + String.valueOf(somePojo) + "]");<br />  }<br />    return null;<br />   }<br />  }).when(timeConsumingExternalServiceMock).processSomeObject(Mockito.any(SomePojo.class));<br /></pre><br />Of course the logs regarding the equalities are unnecessary since if they wouldn't be equal we would have an assertion exception - I left them for the purpose of this post.<br /><br />And in the logs we can find: <br /><br /><pre class="brush:xml">pl.grzejszczak.marcin.ServiceIntegrationTest:48 Names are equal<br />pl.grzejszczak.marcin.ServiceIntegrationTest:50 Surnames are equal<br />pl.grzejszczak.marcin.ServiceIntegrationTest:52 Ints are equal<br />pl.grzejszczak.marcin.ServiceIntegrationTest:54 Doubles are equal<br />pl.grzejszczak.marcin.ServiceIntegrationTest:56 Object being an argument of the function [SomePojo [name=name, surname=surname, intValue=1, doubleValue=1.0]]<br /></pre><br />So in this way something that seems impossible to be verified can get verified :)<br /><br /><b><u>Update! </u></b><br /><br />Thanks to Holger's suggestion I took a look at the <span style="font-family: 'Courier New', Courier, monospace;">ArgumentCaptor</span> object and that is true that it is an elegant solution to retrieve information about the arguments executed on a method. Where <span style="font-family: 'Courier New', Courier, monospace;">InvocationOnMock</span> can give you much more information and possibilities (for instance regarding the method being executed or just execute the real method) for this particular case a much more elegant, easier and faster way of dealing with the issue would be:<br /><br /><br /><pre class="brush:java">  //service that executes the external service<br />  executorService.execute(someTask);<br /><br />  final ArgumentCaptor&lt;SomePojo&gt; argumentCaptor = ArgumentCaptor.forClass(SomePojo.class);<br />  Mockito.verify(timeConsumingExternalServiceMock).processSomeObject(argumentCaptor.capture());<br />  SomePojo somePojo = argumentCaptor.getValue();<br />  Assert.assertEquals("name", somePojo.getName());<br />  LOGGER.debug("Names are equal");<br />  Assert.assertEquals("surname", somePojo.getSurname());<br />  LOGGER.debug("Surnames are equal");<br />  Assert.assertTrue(1 == somePojo.getIntValue());<br />  LOGGER.debug("Ints are equal");<br />  Assert.assertTrue(1.0 == somePojo.getDoubleValue());<br />  LOGGER.debug("Doubles are equal");<br /></pre><br />The logs: <br /><pre class="brush:xml">pl.grzejszczak.marcin.junit.SomeTask:26 Before processing an object<br />pl.grzejszczak.marcin.junit.SomeTask:28 After processing an object<br />pl.grzejszczak.marcin.ServiceIntegrationTest:75 Names are equal<br />pl.grzejszczak.marcin.ServiceIntegrationTest:77 Surnames are equal<br />pl.grzejszczak.marcin.ServiceIntegrationTest:79 Ints are equal<br />pl.grzejszczak.marcin.ServiceIntegrationTest:81 Doubles are equal<br /></pre><br />Thanks again Holger!</div>
</div>
  
  


        </article>
      
    </div>

    <ul class="pager">
      
        <li class="previous"><a href="/posts/7">&larr;&nbsp;Older</a></li>
      
      <li><a href="/blog/archives">Blog Archives</a></li>
      
        <li class="next"><a href="/posts/5">Newer&nbsp;&rarr;</a></li>
      
    </ul>
  </div>

  
    <aside class="sidebar col-md-3">
        <section>
  <h1>About Me</h1>
  <p><img src="/images/ja.jpeg" style="float:left;margin:5px;border-width:0px;width:100%;height:100%"/>
  Co-author of <a href="https://smarttesting.pl">SmartTesting</a>, author of <a href="https://learning.oreilly.com/videos/hands-on-guide-to/9780135598436">Hands-On Guide to Spring Cloud Contract: Creating Consumer-Driven Contracts to Leverage Contract Tests and Improve Your Code</a> and co-author of <a href="https://bit.ly/appliedCD">Applied Continuous Delivery Live Lessons</a>. Co-founder of the Warsaw Groovy User Group, <a href="https://www.meetup.com/Warsaw-Cloud-Native-Meetup/">Warsaw Cloud Native Meetup</a> and the <a href="https://www.diverseit.io">DiverseIT</a> initiative. Author of <a href="https://www.packtpub.com/application-development/instant-mockito">"Mockito Instant"</a> and <a href="https://www.packtpub.com/application-development/mockito-cookbook">"Mockito Cookbook"</a> books.
  </p>

  <a>
  Working on Spring Observability, <a href="https://spring.io/projects/spring-cloud-sleuth/">Spring Cloud Sleuth</a>, <a href="https://spring.io/projects/spring-cloud-contract/">Spring Cloud Contract</a> projects at <a href="https://spring.io/">VMware</a>.
  </p>

  <p><a href="https://github.com/marcingrzejszczak">Github profile</a></p>
  
  <p><a rel="me" href="https://fosstodon.org/@toomuchcoding">Mastodon</a></p>

  <p><a href="https://twitter.com/MGrzejszczak">Twitter: @MGrzejszczak (please follow the Mastodon account - I'm moving off Twitter)</a></p>

  <p><a href="https://www.goodreads.com/author/show/7284553.Marcin_Grzejszczak">Goodreads account</a></p>
</section>

      </aside>
  
</div>

        </div>
      </div>
    </div>
    <footer role="contentinfo"><div class="container">
    <p class="text-muted credits">
  Copyright &copy; 2022 - Marcin Grzejszczak<br>
  <small>
      <span class="credit">Powered by <a href="https://octopress.org">Octopress</a></span>,
      <span class="credit">customized with <a href="https://github.com/kAworu/octostrap3">octostrap3</a></span>.
  </small>
</p>

</div>
</footer>
    

<script type="text/javascript">
      var disqus_shortname = 'toomuchcoding';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>


<script src="/assets/bootstrap/dist/js/bootstrap.min.js"></script>
<script src="/javascripts/modernizr.js"></script>


  </body>
</html>
